From b7ed50bc4f78f83c7a8307ae1c4c1f75a152f8af Mon Sep 17 00:00:00 2001
From: Jakub Kramarz <jkramarz@virtuslab.com>
Date: Tue, 16 Jun 2015 13:32:33 +0200
Subject: [PATCH 3/6] applied patch from "DMA SPI 8 bit write working in
 3.10.17"

---
 Makefile                                           |   2 +-
 arch/arm/Makefile                                  |   3 -
 arch/arm/kernel/entry-common.S                     |   3 +-
 arch/arm/mm/fault.c                                |  13 +-
 arch/mips/kernel/proc.c                            |   6 +-
 arch/mips/mm/c-r4k.c                               |   8 +-
 arch/mips/mm/tlbex.c                               |   3 +-
 arch/powerpc/Makefile                              |   5 +-
 arch/powerpc/boot/Makefile                         |   2 +-
 arch/powerpc/kernel/vdso32/sigtramp.S              |  34 -
 arch/powerpc/mm/slb.c                              |   1 -
 arch/x86/configs/i386_edison_defconfig             | 184 ++----
 arch/x86/include/asm/intel-mid.h                   |   3 +
 arch/x86/include/asm/intel_mid_pcihelpers.h        |  10 +
 arch/x86/kernel/cpu/vmware.c                       |   1 -
 arch/x86/pci/mrst.c                                |  11 +-
 arch/x86/platform/intel-mid/board.c                |   7 +-
 arch/x86/platform/intel-mid/device_libs/Makefile   |   2 -
 .../intel-mid/device_libs/platform_spidev.c        |   4 +-
 arch/x86/platform/intel-mid/intel_mid_sfi.c        |  20 -
 arch/x86/platform/intel-mid/intel_mid_weak_decls.h |   2 +
 arch/x86/platform/intel-mid/mrfl.c                 |   6 +
 drivers/dma/intel_mid_dma.c                        | 241 +++++--
 drivers/dma/intel_mid_dma_acpi.c                   | 100 ++-
 drivers/dma/intel_mid_dma_regs.h                   |   3 +-
 drivers/gpio/gpio-langwell.c                       |  15 +-
 drivers/hwmon/Kconfig                              |   9 -
 drivers/hwmon/Makefile                             |   1 -
 drivers/mmc/card/block.c                           | 200 +-----
 drivers/mmc/card/queue.c                           |   2 +-
 drivers/mmc/card/queue.h                           |   2 +-
 drivers/mmc/core/mmc.c                             |  16 -
 drivers/mmc/core/mmc_ops.c                         | 412 ------------
 drivers/mmc/host/sdhci.c                           |  10 -
 drivers/pci/pci-atom_soc.c                         |   1 +
 drivers/pci/pci-driver.c                           |   1 -
 drivers/pci/pci.c                                  |  17 +-
 drivers/pci/quirks.c                               |   8 +
 drivers/platform/x86/Kconfig                       |  17 -
 drivers/platform/x86/Makefile                      |   2 -
 drivers/pwm/pwm-intel-mid.c                        |  17 +-
 drivers/remoteproc/intel_mid_rproc_scu.c           |  11 +-
 drivers/spi/intel_mid_ssp_spi.c                    | 426 +++++-------
 drivers/tty/serial/pch_uart.c                      |  84 +--
 drivers/usb/host/pci-quirks.c                      |  14 +-
 drivers/usb/host/uhci-q.c                          |   4 +-
 drivers/usb/host/xhci.c                            |   3 -
 fs/Kconfig                                         |   2 -
 fs/Makefile                                        |   2 -
 fs/buffer.c                                        |   2 -
 fs/fat/Kconfig                                     |  32 -
 fs/fat/dir.c                                       |  17 +-
 fs/fat/namei_vfat.c                                | 113 +---
 fs/file_table.c                                    |   5 +-
 fs/inode.c                                         |   4 +-
 fs/namespace.c                                     |   3 -
 fs/nfs/Kconfig                                     |  13 -
 fs/nfs/client.c                                    |  12 +-
 fs/nfs/internal.h                                  |   7 +-
 fs/nfs/mount_clnt.c                                |   7 +-
 fs/nfs/super.c                                     |  33 +-
 fs/notify/group.c                                  |   4 -
 fs/notify/mark.c                                   |   4 -
 fs/open.c                                          |   1 -
 fs/proc/nommu.c                                    |   4 -
 fs/proc/task_mmu.c                                 |   6 -
 fs/proc/task_nommu.c                               |   4 -
 fs/splice.c                                        |  12 +-
 include/linux/fs.h                                 |   1 -
 include/linux/intel_mid_dma.h                      |   3 +
 include/linux/intel_mid_pm.h                       |   1 +
 include/linux/mfd/wm8994/pdata.h                   |  19 -
 include/linux/mfd/wm8994/registers.h               |   8 -
 include/linux/mm_types.h                           |   2 -
 include/linux/mmc/card.h                           |   6 -
 include/linux/mmc/core.h                           |  34 -
 include/linux/nfs_fs_sb.h                          |   3 -
 include/linux/nfs_xdr.h                            |   2 +-
 include/linux/pci_ids.h                            |  17 +-
 include/linux/splice.h                             |   6 -
 include/sound/compress_driver.h                    |  15 -
 include/sound/core.h                               |   5 -
 include/sound/pcm.h                                |   1 -
 include/sound/soc-dai.h                            |   4 +-
 include/sound/soc-dapm.h                           |   2 -
 include/sound/soc-dpcm.h                           |  22 -
 include/sound/soc.h                                |  35 -
 include/uapi/linux/Kbuild                          |   1 -
 include/uapi/linux/mmc/ioctl.h                     |  13 -
 include/uapi/linux/msdos_fs.h                      |   1 -
 include/uapi/linux/nfs_mount.h                     |   4 +-
 include/uapi/sound/compress_offload.h              |   8 +-
 init/Kconfig                                       |  25 -
 init/do_mounts.c                                   |   8 +-
 init/main.c                                        |   7 -
 kernel/Makefile                                    |   1 -
 kernel/fork.c                                      |   2 -
 mm/memory.c                                        |   2 -
 mm/mmap.c                                          |  10 -
 mm/nommu.c                                         |  10 -
 net/bluetooth/l2cap_core.c                         |  20 +-
 net/bluetooth/l2cap_sock.c                         |   5 +-
 net/ipv4/arp.c                                     |   9 +-
 net/ipv4/inet_fragment.c                           |   3 +-
 net/netfilter/nf_conntrack_proto_dccp.c            |   6 +-
 scripts/kconfig/menu.c                             |   2 +-
 scripts/mod/modpost.c                              |   6 +-
 security/commoncap.c                               |   2 -
 security/device_cgroup.c                           |   2 -
 sound/core/Kconfig                                 |   3 -
 sound/core/Makefile                                |   2 -
 sound/core/compress_offload.c                      | 123 +---
 sound/soc/Kconfig                                  |   2 +-
 sound/soc/Makefile                                 |   2 +-
 sound/soc/codecs/wm8994.c                          | 491 +++-----------
 sound/soc/codecs/wm8994.h                          |  14 -
 sound/soc/codecs/wm_hubs.c                         |  20 +-
 sound/soc/mid-x86/Kconfig                          |  13 +
 sound/soc/mid-x86/Makefile                         |   5 +
 sound/soc/mid-x86/mfld_machine.c                   | 447 +++++++++++++
 sound/soc/mid-x86/sst_dsp.h                        | 134 ++++
 sound/soc/mid-x86/sst_platform.c                   | 733 +++++++++++++++++++++
 sound/soc/mid-x86/sst_platform.h                   | 157 +++++
 sound/soc/soc-compress.c                           | 343 +---------
 sound/soc/soc-core.c                               |  36 +-
 sound/soc/soc-dapm.c                               |  13 +-
 sound/soc/soc-jack.c                               |  14 +-
 sound/soc/soc-pcm.c                                |  83 +--
 sound/soc/soc-utils.c                              |  34 +-
 tools/perf/Makefile                                |  12 +-
 tools/perf/bench/numa.c                            |   5 +-
 tools/perf/builtin-sched.c                         |  41 +-
 tools/perf/perf.h                                  |   2 -
 .../perf/scripts/python/Perf-Trace-Util/Context.c  |   4 -
 tools/perf/tests/attr.c                            |  20 +-
 tools/perf/tests/bp_signal.c                       |   2 +-
 tools/perf/tests/bp_signal_overflow.c              |   2 +-
 tools/perf/util/annotate.c                         |   2 +-
 tools/perf/util/include/linux/compiler.h           |   1 -
 .../util/scripting-engines/trace-event-python.c    |   4 -
 140 files changed, 2426 insertions(+), 2904 deletions(-)
 create mode 100644 sound/soc/mid-x86/Kconfig
 create mode 100644 sound/soc/mid-x86/Makefile
 create mode 100644 sound/soc/mid-x86/mfld_machine.c
 create mode 100644 sound/soc/mid-x86/sst_dsp.h
 create mode 100644 sound/soc/mid-x86/sst_platform.c
 create mode 100644 sound/soc/mid-x86/sst_platform.h

diff --git a/Makefile b/Makefile
index ec02856..5c7d3d6 100644
--- a/Makefile
+++ b/Makefile
@@ -406,7 +406,7 @@ export MODVERDIR := $(if $(KBUILD_EXTMOD),$(firstword $(KBUILD_EXTMOD))/).tmp_ve
 # Files to ignore in find ... statements
 
 RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o -name CVS \
-		   -o -name .pc -o -name .hg -o -name .git -o -name meta \) -prune -o
+		   -o -name .pc -o -name .hg -o -name .git \) -prune -o
 export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
 			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
 
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index a098bd3..1ba358b 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -283,9 +283,6 @@ archprepare:
 # Convert bzImage to zImage
 bzImage: zImage
 
-# These targets cannot be built in parallel
-.NOTPARALLEL: zImage Image xipImage bootpImage uImage
-
 zImage Image xipImage bootpImage uImage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@
 
diff --git a/arch/arm/kernel/entry-common.S b/arch/arm/kernel/entry-common.S
index 7dcdfae..bc5bc0a 100644
--- a/arch/arm/kernel/entry-common.S
+++ b/arch/arm/kernel/entry-common.S
@@ -484,8 +484,7 @@ __cr_alignment:
  * With EABI a couple syscalls are obsolete and defined as sys_ni_syscall.
  */
 #define ABI(native, compat) native
-
-#if defined(CONFIG_AEABI) && !defined(CONFIG_OABI_COMPAT)
+#ifdef CONFIG_AEABI
 #define OBSOLETE(syscall) sys_ni_syscall
 #else
 #define OBSOLETE(syscall) syscall
diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c
index e207aa5..5dbf13f 100644
--- a/arch/arm/mm/fault.c
+++ b/arch/arm/mm/fault.c
@@ -446,16 +446,8 @@ do_translation_fault(unsigned long addr, unsigned int fsr,
 
 	if (pud_none(*pud_k))
 		goto bad_area;
-	if (!pud_present(*pud)) {
+	if (!pud_present(*pud))
 		set_pud(pud, *pud_k);
-		/*
-		 * There is a small window during free_pgtables() where the
-		 * user *pud entry is 0 but the TLB has not been invalidated
-		 * and we get a level 2 (pmd) translation fault caused by the
-		 * intermediate TLB caching of the old level 1 (pud) entry.
-		 */
-		flush_tlb_kernel_page(addr);
-	}
 
 	pmd = pmd_offset(pud, addr);
 	pmd_k = pmd_offset(pud_k, addr);
@@ -478,9 +470,8 @@ do_translation_fault(unsigned long addr, unsigned int fsr,
 #endif
 	if (pmd_none(pmd_k[index]))
 		goto bad_area;
-	if (!pmd_present(pmd[index]))
-		copy_pmd(pmd, pmd_k);
 
+	copy_pmd(pmd, pmd_k);
 	return 0;
 
 bad_area:
diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
index 5d2a69c..acb3437 100644
--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -23,7 +23,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	unsigned int version = cpu_data[n].processor_id;
 	unsigned int fp_vers = cpu_data[n].fpu_id;
 	char fmt [64];
-	int cpu,i;
+	int i;
 
 #ifdef CONFIG_SMP
 	if (!cpu_online(n))
@@ -43,11 +43,9 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	seq_printf(m, "processor\t\t: %ld\n", n);
 	sprintf(fmt, "cpu model\t\t: %%s V%%d.%%d%s\n",
 		      cpu_data[n].options & MIPS_CPU_FPU ? "  FPU V%d.%d" : "");
-	cpu = get_cpu();
-	seq_printf(m, fmt, __cpu_name[cpu],
+	seq_printf(m, fmt, __cpu_name[n],
 		      (version >> 4) & 0x0f, version & 0x0f,
 		      (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
-	put_cpu();
 	seq_printf(m, "BogoMIPS\t\t: %u.%02u\n",
 		      cpu_data[n].udelay_val / (500000/HZ),
 		      (cpu_data[n].udelay_val / (5000/HZ)) % 100);
diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c
index d6414bf..21813be 100644
--- a/arch/mips/mm/c-r4k.c
+++ b/arch/mips/mm/c-r4k.c
@@ -385,12 +385,12 @@ static inline int has_valid_asid(const struct mm_struct *mm)
 
 static void r4k__flush_cache_vmap(void)
 {
-	r4k_on_each_cpu((void *)r4k_blast_dcache, NULL);
+	r4k_blast_dcache();
 }
 
 static void r4k__flush_cache_vunmap(void)
 {
-	r4k_on_each_cpu((void *)r4k_blast_dcache, NULL);
+	r4k_blast_dcache();
 }
 
 static inline void local_r4k_flush_cache_range(void * args)
@@ -616,7 +616,7 @@ static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
 	 * explicitly
 	 */
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
-		r4k_on_each_cpu((void *)r4k_blast_dcache, NULL);
+		r4k_blast_dcache();
 	} else {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_dcache_range(addr, addr + size);
@@ -650,7 +650,7 @@ static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 	}
 
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
-		r4k_on_each_cpu((void *)r4k_blast_dcache, NULL);
+		r4k_blast_dcache();
 	} else {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_inv_dcache_range(addr, addr + size);
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 0f25e00..afeef93 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -484,7 +484,6 @@ static void __cpuinit __maybe_unused build_tlb_probe_entry(u32 **p)
 	case CPU_R4700:
 	case CPU_R5000:
 	case CPU_NEVADA:
-	case CPU_4KC:
 		uasm_i_nop(p);
 		uasm_i_tlbp(p);
 		break;
@@ -551,7 +550,6 @@ static void __cpuinit build_tlb_write_entry(u32 **p, struct uasm_label **l,
 
 	case CPU_R4600:
 	case CPU_R4700:
-	case CPU_4KC:
 		uasm_i_nop(p);
 		tlbw(p);
 		uasm_i_nop(p);
@@ -576,6 +574,7 @@ static void __cpuinit build_tlb_write_entry(u32 **p, struct uasm_label **l,
 	case CPU_R10000:
 	case CPU_R12000:
 	case CPU_R14000:
+	case CPU_4KC:
 	case CPU_4KEC:
 	case CPU_M14KC:
 	case CPU_M14KEC:
diff --git a/arch/powerpc/Makefile b/arch/powerpc/Makefile
index 61675af..967fd23 100644
--- a/arch/powerpc/Makefile
+++ b/arch/powerpc/Makefile
@@ -192,9 +192,6 @@ relocs_check: arch/powerpc/relocs_check.pl vmlinux
 zImage: relocs_check
 endif
 
-# These targets cannot be built in parallel
-.NOTPARALLEL: $(BOOT_TARGETS)
-
 $(BOOT_TARGETS1): vmlinux
 	$(Q)$(MAKE) ARCH=ppc64 $(build)=$(boot) $(patsubst %,$(boot)/%,$@)
 $(BOOT_TARGETS2): vmlinux
@@ -241,7 +238,7 @@ endif
 archclean:
 	$(Q)$(MAKE) $(clean)=$(boot)
 
-archprepare: checkbin arch/powerpc/lib/crtsavres.o
+archprepare: checkbin
 
 # Use the file '.tmp_gas_check' for binutils tests, as gas won't output
 # to stdout and these checks are run even on install targets.
diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile
index 61a5cdf..6a15c96 100644
--- a/arch/powerpc/boot/Makefile
+++ b/arch/powerpc/boot/Makefile
@@ -20,7 +20,7 @@
 all: $(obj)/zImage
 
 BOOTCFLAGS    := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
-		 -fno-strict-aliasing -msoft-float -pipe \
+		 -fno-strict-aliasing -Os -msoft-float -pipe \
 		 -fomit-frame-pointer -fno-builtin -fPIC -nostdinc \
 		 -isystem $(shell $(CROSS32CC) -print-file-name=include)
 BOOTAFLAGS	:= -D__ASSEMBLY__ $(BOOTCFLAGS) -traditional -nostdinc
diff --git a/arch/powerpc/kernel/vdso32/sigtramp.S b/arch/powerpc/kernel/vdso32/sigtramp.S
index 78c88af..cf0c9c9 100644
--- a/arch/powerpc/kernel/vdso32/sigtramp.S
+++ b/arch/powerpc/kernel/vdso32/sigtramp.S
@@ -251,40 +251,6 @@ V_FUNCTION_END(__kernel_sigtramp_rt32)
   vsave_msr1 (31);							\
   vsave_msr2 (33, 32*16+12);						\
   vsave      (32, 32*16)
-#elif defined(CONFIG_SPE)
-#define EH_FRAME_VMX \
-  rsave (113, VREGS);							\
-  rsave (114, VREGS + 1*4);						\
-  rsave (115, VREGS + 2*4);						\
-  rsave (116, VREGS + 3*4);						\
-  rsave (117, VREGS + 4*4);						\
-  rsave (118, VREGS + 5*4);						\
-  rsave (119, VREGS + 6*4);						\
-  rsave (120, VREGS + 7*4);						\
-  rsave (121, VREGS + 8*4);						\
-  rsave (122, VREGS + 9*4);						\
-  rsave (123, VREGS + 10*4);						\
-  rsave (124, VREGS + 11*4);						\
-  rsave (125, VREGS + 12*4);						\
-  rsave (126, VREGS + 13*4);						\
-  rsave (127, VREGS + 14*4);						\
-  rsave (128, VREGS + 15*4);						\
-  rsave (129, VREGS + 16*4);						\
-  rsave (130, VREGS + 17*4);						\
-  rsave (131, VREGS + 18*4);						\
-  rsave (132, VREGS + 19*4);						\
-  rsave (133, VREGS + 20*4);						\
-  rsave (134, VREGS + 21*4);						\
-  rsave (135, VREGS + 22*4);						\
-  rsave (136, VREGS + 23*4);						\
-  rsave (137, VREGS + 24*4);						\
-  rsave (138, VREGS + 25*4);						\
-  rsave (139, VREGS + 26*4);						\
-  rsave (140, VREGS + 27*4);						\
-  rsave (141, VREGS + 28*4);						\
-  rsave (142, VREGS + 29*4);						\
-  rsave (143, VREGS + 30*4);						\
-  rsave (144, VREGS + 31*4);
 #else
 #define EH_FRAME_VMX
 #endif
diff --git a/arch/powerpc/mm/slb.c b/arch/powerpc/mm/slb.c
index eb42124..a538c80 100644
--- a/arch/powerpc/mm/slb.c
+++ b/arch/powerpc/mm/slb.c
@@ -313,7 +313,6 @@ void slb_initialize(void)
 	asm volatile("isync":::"memory");
 	asm volatile("slbmte  %0,%0"::"r" (0) : "memory");
 	asm volatile("isync; slbia; isync":::"memory");
-	mb();
 	create_shadowed_slbe(PAGE_OFFSET, mmu_kernel_ssize, lflags, 0);
 
 	create_shadowed_slbe(VMALLOC_START, mmu_kernel_ssize, vflags, 1);
diff --git a/arch/x86/configs/i386_edison_defconfig b/arch/x86/configs/i386_edison_defconfig
index 0215bf5..76dd198 100644
--- a/arch/x86/configs/i386_edison_defconfig
+++ b/arch/x86/configs/i386_edison_defconfig
@@ -1,6 +1,6 @@
 #
 # Automatically generated file; DO NOT EDIT.
-# Linux/x86 3.10.17 Kernel Configuration
+# Linux/i386 3.10.17 Kernel Configuration
 #
 # CONFIG_64BIT is not set
 CONFIG_X86_32=y
@@ -46,8 +46,8 @@ CONFIG_BUILDTIME_EXTABLE_SORT=y
 #
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_CROSS_COMPILE=""
-CONFIG_LOCALVERSION="-poky-edison"
-CONFIG_LOCALVERSION_AUTO=n
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_HAVE_KERNEL_GZIP=y
 CONFIG_HAVE_KERNEL_BZIP2=y
 CONFIG_HAVE_KERNEL_LZMA=y
@@ -153,7 +153,7 @@ CONFIG_NAMESPACES=y
 # CONFIG_IPC_NS is not set
 # CONFIG_USER_NS is not set
 # CONFIG_PID_NS is not set
-CONFIG_NET_NS=y
+# CONFIG_NET_NS is not set
 CONFIG_UIDGID_CONVERTED=y
 # CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
 CONFIG_SCHED_AUTOGROUP=y
@@ -175,7 +175,6 @@ CONFIG_SYSCTL_EXCEPTION_TRACE=y
 CONFIG_HOTPLUG=y
 CONFIG_HAVE_PCSPKR_PLATFORM=y
 CONFIG_EXPERT=y
-# CONFIG_UPTIME_LIMITED_KERNEL is not set
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
@@ -978,7 +977,7 @@ CONFIG_DEBUG_DEVRES=y
 # CONFIG_GENERIC_CPU_DEVICES is not set
 CONFIG_REGMAP=y
 CONFIG_REGMAP_I2C=y
-CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_SPI=m
 CONFIG_REGMAP_IRQ=y
 CONFIG_DMA_SHARED_BUFFER=y
 # CONFIG_CMA is not set
@@ -1355,7 +1354,7 @@ CONFIG_INPUT_TABLET=y
 # CONFIG_TABLET_USB_KBTAB is not set
 # CONFIG_TABLET_USB_WACOM is not set
 CONFIG_INPUT_TOUCHSCREEN=y
-CONFIG_TOUCHSCREEN_ADS7846=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
 # CONFIG_TOUCHSCREEN_AD7877 is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
 # CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
@@ -1544,8 +1543,8 @@ CONFIG_I2C_ALGOBIT=y
 CONFIG_I2C_DESIGNWARE_CORE_FORK=y
 CONFIG_I2C_DESIGNWARE_PCI_FORK=y
 # CONFIG_I2C_DESIGNWARE_PLATFORM_FORK is not set
-CONFIG_I2C_DW_SPEED_MODE_DEBUG=y
-# CONFIG_I2C_PMIC is not set
+# CONFIG_I2C_DW_SPEED_MODE_DEBUG is not set
+CONFIG_I2C_PMIC=y
 # CONFIG_I2C_DESIGNWARE_PCI is not set
 # CONFIG_I2C_EG20T is not set
 CONFIG_I2C_GPIO=y
@@ -1719,7 +1718,6 @@ CONFIG_BATTERY_MAX17042=y
 # CONFIG_POWER_RESET is not set
 # CONFIG_POWER_AVS is not set
 CONFIG_HWMON=y
-CONFIG_INTEL_MCU=y
 # CONFIG_HWMON_VID is not set
 # CONFIG_HWMON_DEBUG_CHIP is not set
 
@@ -2049,71 +2047,7 @@ CONFIG_VIDEOBUF2_VMALLOC=m
 #
 # Media drivers
 #
-CONFIG_MEDIA_USB_SUPPORT=y
-
-#
-# Webcam devices
-#
-CONFIG_USB_VIDEO_CLASS=m
-CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
-CONFIG_USB_GSPCA=m
-# CONFIG_USB_M5602 is not set
-# CONFIG_USB_STV06XX is not set
-# CONFIG_USB_GL860 is not set
-# CONFIG_USB_GSPCA_BENQ is not set
-# CONFIG_USB_GSPCA_CONEX is not set
-# CONFIG_USB_GSPCA_CPIA1 is not set
-# CONFIG_USB_GSPCA_ETOMS is not set
-# CONFIG_USB_GSPCA_FINEPIX is not set
-# CONFIG_USB_GSPCA_JEILINJ is not set
-# CONFIG_USB_GSPCA_JL2005BCD is not set
-# CONFIG_USB_GSPCA_KINECT is not set
-# CONFIG_USB_GSPCA_KONICA is not set
-# CONFIG_USB_GSPCA_MARS is not set
-# CONFIG_USB_GSPCA_MR97310A is not set
-# CONFIG_USB_GSPCA_NW80X is not set
-# CONFIG_USB_GSPCA_OV519 is not set
-# CONFIG_USB_GSPCA_OV534 is not set
-# CONFIG_USB_GSPCA_OV534_9 is not set
-# CONFIG_USB_GSPCA_PAC207 is not set
-# CONFIG_USB_GSPCA_PAC7302 is not set
-# CONFIG_USB_GSPCA_PAC7311 is not set
-# CONFIG_USB_GSPCA_SE401 is not set
-# CONFIG_USB_GSPCA_SN9C2028 is not set
-# CONFIG_USB_GSPCA_SN9C20X is not set
-# CONFIG_USB_GSPCA_SONIXB is not set
-# CONFIG_USB_GSPCA_SONIXJ is not set
-# CONFIG_USB_GSPCA_SPCA500 is not set
-# CONFIG_USB_GSPCA_SPCA501 is not set
-# CONFIG_USB_GSPCA_SPCA505 is not set
-# CONFIG_USB_GSPCA_SPCA506 is not set
-# CONFIG_USB_GSPCA_SPCA508 is not set
-# CONFIG_USB_GSPCA_SPCA561 is not set
-# CONFIG_USB_GSPCA_SPCA1528 is not set
-# CONFIG_USB_GSPCA_SQ905 is not set
-# CONFIG_USB_GSPCA_SQ905C is not set
-# CONFIG_USB_GSPCA_SQ930X is not set
-# CONFIG_USB_GSPCA_STK014 is not set
-# CONFIG_USB_GSPCA_STV0680 is not set
-# CONFIG_USB_GSPCA_SUNPLUS is not set
-# CONFIG_USB_GSPCA_T613 is not set
-# CONFIG_USB_GSPCA_TOPRO is not set
-# CONFIG_USB_GSPCA_TV8532 is not set
-# CONFIG_USB_GSPCA_VC032X is not set
-# CONFIG_USB_GSPCA_VICAM is not set
-# CONFIG_USB_GSPCA_XIRLINK_CIT is not set
-# CONFIG_USB_GSPCA_ZC3XX is not set
-# CONFIG_USB_PWC is not set
-# CONFIG_VIDEO_CPIA2 is not set
-# CONFIG_USB_ZR364XX is not set
-# CONFIG_USB_STKWEBCAM is not set
-# CONFIG_USB_S2255 is not set
-# CONFIG_USB_SN9C102 is not set
-
-#
-# Webcam, TV (analog/digital) USB devices
-#
-# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_MEDIA_USB_SUPPORT is not set
 # CONFIG_MEDIA_PCI_SUPPORT is not set
 # CONFIG_V4L_PLATFORM_DRIVERS is not set
 # CONFIG_V4L_MEM2MEM_DRIVERS is not set
@@ -2262,8 +2196,7 @@ CONFIG_AGP_INTEL=y
 # CONFIG_AGP_SWORKS is not set
 # CONFIG_AGP_VIA is not set
 # CONFIG_AGP_EFFICEON is not set
-CONFIG_VGA_ARB=y
-CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_VGA_ARB is not set
 CONFIG_DRM=y
 # CONFIG_DRM_TDFX is not set
 # CONFIG_DRM_R128 is not set
@@ -2287,10 +2220,10 @@ CONFIG_HDMI=y
 CONFIG_FB=y
 # CONFIG_FIRMWARE_EDID is not set
 # CONFIG_FB_DDC is not set
-# CONFIG_FB_BOOT_VESA_SUPPORT is not set
-# CONFIG_FB_CFB_FILLRECT is not set
-# CONFIG_FB_CFB_COPYAREA is not set
-# CONFIG_FB_CFB_IMAGEBLIT is not set
+CONFIG_FB_BOOT_VESA_SUPPORT=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
 # CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
 CONFIG_FB_SYS_FILLRECT=y
 CONFIG_FB_SYS_COPYAREA=y
@@ -2300,7 +2233,7 @@ CONFIG_FB_SYS_FOPS=y
 CONFIG_FB_DEFERRED_IO=y
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
-CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_BACKLIGHT is not set
 CONFIG_FB_MODE_HELPERS=y
 CONFIG_FB_TILEBLITTING=y
 
@@ -2315,7 +2248,7 @@ CONFIG_FB_TILEBLITTING=y
 # CONFIG_FB_IMSTT is not set
 # CONFIG_FB_VGA16 is not set
 # CONFIG_FB_UVESA is not set
-# CONFIG_FB_VESA is not set
+CONFIG_FB_VESA=y
 # CONFIG_FB_N411 is not set
 # CONFIG_FB_HGA is not set
 # CONFIG_FB_S1D13XXX is not set
@@ -2345,7 +2278,7 @@ CONFIG_FB_TILEBLITTING=y
 # CONFIG_FB_GEODE is not set
 # CONFIG_FB_TMIO is not set
 # CONFIG_FB_SMSCUFX is not set
-# CONFIG_FB_UDL is not set
+CONFIG_FB_UDL=y
 # CONFIG_FB_GOLDFISH is not set
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
@@ -2354,10 +2287,23 @@ CONFIG_FB_TILEBLITTING=y
 # CONFIG_FB_AUO_K190X is not set
 # CONFIG_EXYNOS_VIDEO is not set
 CONFIG_BACKLIGHT_LCD_SUPPORT=y
-# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+CONFIG_LCD_PLATFORM=y
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
 CONFIG_BACKLIGHT_CLASS_DEVICE=y
 CONFIG_BACKLIGHT_GENERIC=y
-# CONFIG_BACKLIGHT_PWM is not set
+CONFIG_BACKLIGHT_PWM=y
 # CONFIG_BACKLIGHT_SAHARA is not set
 # CONFIG_BACKLIGHT_ADP8860 is not set
 # CONFIG_BACKLIGHT_ADP8870 is not set
@@ -2383,10 +2329,11 @@ CONFIG_SOUND=y
 CONFIG_SND=y
 CONFIG_SND_TIMER=y
 CONFIG_SND_PCM=y
-# CONFIG_SND_COMPRESS_OFFLOAD is not set
-# CONFIG_SND_EFFECTS_OFFLOAD is not set
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_COMPRESS_OFFLOAD=m
 CONFIG_SND_JACK=y
-CONFIG_SND_SEQUENCER=y
+CONFIG_SND_SEQUENCER=m
 # CONFIG_SND_SEQ_DUMMY is not set
 # CONFIG_SND_MIXER_OSS is not set
 # CONFIG_SND_PCM_OSS is not set
@@ -2398,7 +2345,7 @@ CONFIG_SND_DYNAMIC_MINORS=y
 # CONFIG_SND_VERBOSE_PRINTK is not set
 # CONFIG_SND_DEBUG is not set
 CONFIG_SND_DMA_SGBUF=y
-# CONFIG_SND_RAWMIDI_SEQ is not set
+CONFIG_SND_RAWMIDI_SEQ=m
 # CONFIG_SND_OPL3_LIB_SEQ is not set
 # CONFIG_SND_OPL4_LIB_SEQ is not set
 # CONFIG_SND_SBAWE_SEQ is not set
@@ -2414,25 +2361,18 @@ CONFIG_SND_ALOOP=y
 # CONFIG_SND_PCI is not set
 # CONFIG_SND_SPI is not set
 CONFIG_SND_USB=y
-CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_USB_AUDIO=m
 # CONFIG_SND_USB_UA101 is not set
 # CONFIG_SND_USB_USX2Y is not set
 # CONFIG_SND_USB_CAIAQ is not set
 # CONFIG_SND_USB_US122L is not set
 # CONFIG_SND_USB_6FIRE is not set
-CONFIG_SND_SOC=y
+CONFIG_SND_SOC=m
 # CONFIG_SND_ATMEL_SOC is not set
 # CONFIG_SND_MFLD_MACHINE is not set
-CONFIG_SND_INTEL_SST=y
-CONFIG_SND_MRFLD_MACHINE=y
-CONFIG_SND_SST_PLATFORM=y
-CONFIG_SST_MRFLD_DPCM=y
-CONFIG_SND_SST_MACHINE=y
-CONFIG_SND_SOC_I2C_AND_SPI=y
+CONFIG_SND_SOC_I2C_AND_SPI=m
 # CONFIG_SND_SOC_ALL_CODECS is not set
-CONFIG_SND_SOC_WM_HUBS=y
-CONFIG_SND_SOC_WM8994=y
-# CONFIG_SND_SIMPLE_CARD is not set
+CONFIG_SND_SIMPLE_CARD=m
 # CONFIG_SOUND_PRIME is not set
 
 #
@@ -2627,7 +2567,7 @@ CONFIG_USB_SERIAL=y
 # CONFIG_USB_SERIAL_CH341 is not set
 # CONFIG_USB_SERIAL_WHITEHEAT is not set
 # CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
-CONFIG_USB_SERIAL_CP210X=m
+# CONFIG_USB_SERIAL_CP210X is not set
 # CONFIG_USB_SERIAL_CYPRESS_M8 is not set
 # CONFIG_USB_SERIAL_EMPEG is not set
 # CONFIG_USB_SERIAL_FTDI_SIO is not set
@@ -2736,23 +2676,24 @@ CONFIG_USB_LIBCOMPOSITE=m
 CONFIG_USB_F_ACM=m
 CONFIG_USB_U_SERIAL=m
 # CONFIG_USB_ZERO is not set
-# CONFIG_USB_AUDIO is not set
+CONFIG_USB_AUDIO=m
+# CONFIG_GADGET_UAC1 is not set
 # CONFIG_USB_ETH is not set
 # CONFIG_USB_G_NCM is not set
 # CONFIG_USB_GADGETFS is not set
 # CONFIG_USB_FUNCTIONFS is not set
 # CONFIG_USB_MASS_STORAGE is not set
 # CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_USB_MIDI_GADGET=m
 # CONFIG_USB_G_PRINTER is not set
 # CONFIG_USB_CDC_COMPOSITE is not set
 # CONFIG_USB_G_ACM_MS is not set
 CONFIG_USB_G_MULTI=m
 CONFIG_USB_G_MULTI_RNDIS=y
-CONFIG_USB_G_MULTI_CDC=y
-# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_MULTI_CDC is not set
+CONFIG_USB_G_HID=m
 # CONFIG_USB_G_DBGP is not set
-# CONFIG_USB_G_WEBCAM is not set
+CONFIG_USB_G_WEBCAM=m
 # CONFIG_UWB is not set
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
@@ -3107,7 +3048,6 @@ CONFIG_INTEL_MID_POWER_BUTTON=y
 # CONFIG_IBM_RTL is not set
 # CONFIG_SAMSUNG_LAPTOP is not set
 CONFIG_INTEL_SCU_FLIS=y
-CONFIG_INTEL_PSH_IPC=y
 
 #
 # Hardware Spinlock drivers
@@ -3298,6 +3238,7 @@ CONFIG_FS_MBCACHE=y
 # CONFIG_BTRFS_FS is not set
 # CONFIG_NILFS2_FS is not set
 CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
 CONFIG_FILE_LOCKING=y
 CONFIG_FSNOTIFY=y
 CONFIG_DNOTIFY=y
@@ -3328,10 +3269,8 @@ CONFIG_GENERIC_ACL=y
 CONFIG_FAT_FS=y
 CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
-# CONFIG_VFAT_FS_NO_DUALNAMES is not set
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_VFAT_NO_CREATE_WITH_LONGNAMES is not set
 # CONFIG_NTFS_FS is not set
 
 #
@@ -3374,26 +3313,9 @@ CONFIG_PSTORE_RAM=y
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
 # CONFIG_F2FS_FS is not set
-CONFIG_AUFS_FS=m
-CONFIG_AUFS_BRANCH_MAX_127=y
-# CONFIG_AUFS_BRANCH_MAX_511 is not set
-# CONFIG_AUFS_BRANCH_MAX_1023 is not set
-# CONFIG_AUFS_BRANCH_MAX_32767 is not set
-CONFIG_AUFS_SBILIST=y
-# CONFIG_AUFS_HNOTIFY is not set
-# CONFIG_AUFS_EXPORT is not set
-# CONFIG_AUFS_RDU is not set
-# CONFIG_AUFS_PROC_MAP is not set
-# CONFIG_AUFS_SP_IATTR is not set
-# CONFIG_AUFS_SHWH is not set
-# CONFIG_AUFS_BR_RAMFS is not set
-# CONFIG_AUFS_BR_FUSE is not set
-CONFIG_AUFS_BDEV_LOOP=y
-# CONFIG_AUFS_DEBUG is not set
 CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V2=y
-CONFIG_NFS_DEF_FILE_IO_SIZE=4096
 CONFIG_NFS_V3=y
 CONFIG_NFS_V3_ACL=y
 CONFIG_NFS_V4=y
@@ -3401,11 +3323,7 @@ CONFIG_NFS_V4=y
 # CONFIG_NFS_V4_1 is not set
 # CONFIG_NFS_USE_LEGACY_DNS is not set
 CONFIG_NFS_USE_KERNEL_DNS=y
-CONFIG_NFSD=y
-CONFIG_NFSD_V2_ACL=y
-CONFIG_NFSD_V3=y
-CONFIG_NFSD_V3_ACL=y
-# CONFIG_NFSD_V4 is not set
+# CONFIG_NFSD is not set
 CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_ACL_SUPPORT=y
@@ -3687,7 +3605,6 @@ CONFIG_CRYPTO=y
 #
 # Crypto core or helper
 #
-# CONFIG_CRYPTODEV is not set
 CONFIG_CRYPTO_ALGAPI=y
 CONFIG_CRYPTO_ALGAPI2=y
 CONFIG_CRYPTO_AEAD=y
@@ -3862,3 +3779,4 @@ CONFIG_CLZ_TAB=y
 # CONFIG_CORDIC is not set
 # CONFIG_DDR is not set
 CONFIG_MPILIB=y
+CONFIG_OID_REGISTRY=y
diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index c5860b4..75fe61a 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -161,6 +161,9 @@ struct intel_mid_ops {
 	DECLARE_INTEL_MID_OPS_INIT(penwell, INTEL_MID_CPU_CHIP_PENWELL) \
 	DECLARE_INTEL_MID_OPS_INIT(cloverview, INTEL_MID_CPU_CHIP_CLOVERVIEW) \
 	DECLARE_INTEL_MID_OPS_INIT(tangier, INTEL_MID_CPU_CHIP_TANGIER) \
+	DECLARE_INTEL_MID_OPS_INIT(anniedale, INTEL_MID_CPU_CHIP_ANNIEDALE) \
+	DECLARE_INTEL_MID_OPS_INIT(carboncanyon, \
+		INTEL_MID_CPU_CHIP_CARBONCANYON) \
 };
 
 static inline enum intel_mid_cpu_type intel_mid_identify_cpu(void)
diff --git a/arch/x86/include/asm/intel_mid_pcihelpers.h b/arch/x86/include/asm/intel_mid_pcihelpers.h
index d48026f..b7c079f 100644
--- a/arch/x86/include/asm/intel_mid_pcihelpers.h
+++ b/arch/x86/include/asm/intel_mid_pcihelpers.h
@@ -18,8 +18,18 @@
 #define PCI_ROOT_MSGBUS_WRITE           0x11
 #define PCI_ROOT_MSGBUS_DWORD_ENABLE    0xf0
 
+/* In BYT platform for all internal PCI devices d3 delay
+ * of 3 ms is sufficient. Default value of 10 ms is overkill.
+ */
+#define INTERNAL_PCI_PM_D3_WAIT		3
+
+#define ISP_SUB_CLASS			0x80
+#define SUB_CLASS_MASK			0xFF00
+
 u32 intel_mid_msgbus_read32_raw(u32 cmd);
 u32 intel_mid_msgbus_read32(u8 port, u32 addr);
 void intel_mid_msgbus_write32_raw(u32 cmd, u32 data);
 void intel_mid_msgbus_write32(u8 port, u32 addr, u32 data);
+u32 intel_mid_msgbus_read32_raw_ext(u32 cmd, u32 cmd_ext);
+void intel_mid_msgbus_write32_raw_ext(u32 cmd, u32 cmd_ext, u32 data);
 u32 intel_mid_soc_stepping(void);
diff --git a/arch/x86/kernel/cpu/vmware.c b/arch/x86/kernel/cpu/vmware.c
index 4c77d69..03a3632 100644
--- a/arch/x86/kernel/cpu/vmware.c
+++ b/arch/x86/kernel/cpu/vmware.c
@@ -21,7 +21,6 @@
  *
  */
 
-#include <linux/jiffies.h>
 #include <linux/dmi.h>
 #include <linux/module.h>
 #include <asm/div64.h>
diff --git a/arch/x86/pci/mrst.c b/arch/x86/pci/mrst.c
index f02406b..9e0efa2 100644
--- a/arch/x86/pci/mrst.c
+++ b/arch/x86/pci/mrst.c
@@ -206,6 +206,7 @@ static int pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 
 static int intel_mid_pci_irq_enable(struct pci_dev *dev)
 {
+#ifndef CONFIG_XEN
 	u8 pin;
 	struct io_apic_irq_attr irq_attr;
 
@@ -216,16 +217,22 @@ static int intel_mid_pci_irq_enable(struct pci_dev *dev)
 	 */
 	irq_attr.ioapic = mp_find_ioapic(dev->irq);
 	if (irq_attr.ioapic < 0)
-		return -1;
+		return -EINVAL;
 	irq_attr.ioapic_pin = dev->irq;
 	irq_attr.trigger = 1; /* level */
-	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER)
+	if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) ||
+		(intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE) ||
+		(intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CARBONCANYON))
 		irq_attr.polarity = 0; /* active high */
 	else
 		irq_attr.polarity = 1; /* active low */
 	io_apic_set_pci_routing(&dev->dev, dev->irq, &irq_attr);
 
 	return 0;
+#else
+	xen_register_gsi(dev->irq, -1, 0, 1);
+	return xen_pcifront_enable_irq(dev);
+#endif
 }
 
 struct pci_ops intel_mid_pci_ops = {
diff --git a/arch/x86/platform/intel-mid/board.c b/arch/x86/platform/intel-mid/board.c
index eb3d8a4..eb9d098 100644
--- a/arch/x86/platform/intel-mid/board.c
+++ b/arch/x86/platform/intel-mid/board.c
@@ -60,7 +60,6 @@
 #include "device_libs/platform_soc_thermal.h"
 #include "device_libs/platform_msic_adc.h"
 #include "device_libs/platform_bcove_adc.h"
-#include "device_libs/platform_mrfld_audio.h"
 #include "device_libs/platform_mrfl_thermal.h"
 
 /*
@@ -76,8 +75,6 @@
 #include "device_libs/platform_bq24261.h"
 #include "device_libs/platform_pcal9555a.h"
 
-#include "device_libs/platform_wm8994.h"
-
 /*
  * SPI devices
  */
@@ -150,15 +147,13 @@ struct devs_id __initconst device_ids[] = {
 					&ipc_device_handler},
 	{"bcove_thrm", SFI_DEV_TYPE_IPC, 1, &mrfl_thermal_platform_data,
 					&ipc_device_handler},
-	{"wm8994", SFI_DEV_TYPE_I2C, 0, &wm8994_platform_data, NULL},
+
 	/* IPC devices */
 	{"pmic_charger", SFI_DEV_TYPE_IPC, 1, &no_platform_data, NULL},
 	{"pmic_ccsm", SFI_DEV_TYPE_IPC, 1, &mrfl_pmic_ccsm_platform_data,
 						&ipc_device_handler},
 	{"i2c_pmic_adap", SFI_DEV_TYPE_IPC, 1, &mrfl_pmic_i2c_platform_data,
 						&ipc_device_handler},
-	{"mrfld_sst", SFI_DEV_TYPE_IPC, 1, &mrfld_sst_audio_platform_data,
-						&ipc_device_handler},
 	{"soc_thrm", SFI_DEV_TYPE_IPC, 1, &no_platform_data,
 						&soc_thrm_device_handler},
 	{},
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index 7fc1a26..750ac8f 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -1,5 +1,4 @@
 # IPC Devices
-obj-y += platform_sst_audio.o
 obj-y += platform_mrfl_regulator.o
 obj-y += platform_soc_thermal.o
 obj-$(subst m,y,$(CONFIG_SND_BYT_MACHINE)) += platform_byt_audio.o
@@ -37,7 +36,6 @@ obj-$(subst m,y,$(CONFIG_SENSORS_MPU3050)) += platform_mpu3050.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_tca6416.o
 obj-$(subst m,y,$(CONFIG_BQ24261_CHARGER)) += platform_bq24261.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_pcal9555a.o
-obj-$(subst m,y,$(CONFIG_SND_SOC_WM8994)) += platform_wm8994.o
 # SPI Devices
 obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
 obj-$(subst m,y,$(CONFIG_SPI_SPIDEV)) += platform_spidev.o
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c b/arch/x86/platform/intel-mid/device_libs/platform_spidev.c
index c6b3f7b..b1d2a2c 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_spidev.c
@@ -26,14 +26,14 @@ static struct intel_mid_ssp_spi_chip chip = {
 	.burst_size = DFLT_FIFO_BURST_SIZE,
 	.timeout = DFLT_TIMEOUT_VAL,
 	/* SPI DMA is currently not usable on Tangier */
-	.dma_enabled = false,
+	.dma_enabled = true,
 	.cs_control = tng_ssp_spi_cs_control,
 	.platform_pinmux = tng_ssp_spi_platform_pinmux,
 };
 
 static void tng_ssp_spi_cs_control(u32 command)
 {
-	gpio_set_value(tng_ssp_spi2_FS_gpio, (command != 0) ? 1 : 0);
+	gpio_set_value(tng_ssp_spi2_FS_gpio, (command == CS_ASSERT) ? 0 : 1);
 }
 
 static void tng_ssp_spi_platform_pinmux(void)
diff --git a/arch/x86/platform/intel-mid/intel_mid_sfi.c b/arch/x86/platform/intel-mid/intel_mid_sfi.c
index f73b84e..41f98c4 100644
--- a/arch/x86/platform/intel-mid/intel_mid_sfi.c
+++ b/arch/x86/platform/intel-mid/intel_mid_sfi.c
@@ -316,26 +316,6 @@ void intel_scu_devices_destroy(void)
 }
 EXPORT_SYMBOL_GPL(intel_scu_devices_destroy);
 
-static struct platform_device *psh_ipc;
-void intel_psh_devices_create(void)
-{
-	psh_ipc = platform_device_alloc("intel_psh_ipc", 0);
-	if (psh_ipc == NULL) {
-		pr_err("out of memory for platform device psh_ipc.\n");
-		return;
-	}
-
-	platform_device_add(psh_ipc);
-}
-EXPORT_SYMBOL_GPL(intel_psh_devices_create);
-
-void intel_psh_devices_destroy(void)
-{
-	if (psh_ipc)
-		platform_device_del(psh_ipc);
-}
-EXPORT_SYMBOL_GPL(intel_psh_devices_destroy);
-
 void __init install_irq_resource(struct platform_device *pdev, int irq)
 {
 	/* Single threaded */
diff --git a/arch/x86/platform/intel-mid/intel_mid_weak_decls.h b/arch/x86/platform/intel-mid/intel_mid_weak_decls.h
index 015bf42..008973a 100644
--- a/arch/x86/platform/intel-mid/intel_mid_weak_decls.h
+++ b/arch/x86/platform/intel-mid/intel_mid_weak_decls.h
@@ -13,6 +13,7 @@
 
 /* __attribute__((weak)) makes these declarations overridable */
 extern struct devs_id __initconst device_ids[] __attribute__((weak));
+extern struct devs_id *get_device_ptr(void) __attribute__((weak));
 /* For every CPU addition a new get_<cpuname>_ops interface needs
  * to be added.
  */
@@ -20,3 +21,4 @@ extern void * __init get_penwell_ops(void) __attribute__((weak));
 extern void * __init get_cloverview_ops(void) __attribute__((weak));
 extern void * __init get_tangier_ops(void) __attribute__((weak));
 extern void * __init get_anniedale_ops(void) __attribute__((weak));
+extern void * __init get_carboncanyon_ops(void) __attribute__((weak));
diff --git a/arch/x86/platform/intel-mid/mrfl.c b/arch/x86/platform/intel-mid/mrfl.c
index 0e952f8..642f60d 100644
--- a/arch/x86/platform/intel-mid/mrfl.c
+++ b/arch/x86/platform/intel-mid/mrfl.c
@@ -159,3 +159,9 @@ void *get_anniedale_ops()
 {
 	return &tangier_ops;
 }
+
+/* piggy back on anniedale ops right now */
+void *get_carboncanyon_ops()
+{
+	return &tangier_ops;
+}
diff --git a/drivers/dma/intel_mid_dma.c b/drivers/dma/intel_mid_dma.c
index 91c6f8f..b5d6fad 100644
--- a/drivers/dma/intel_mid_dma.c
+++ b/drivers/dma/intel_mid_dma.c
@@ -30,10 +30,10 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
+#include <asm/intel-mid.h>
 
 #include "dmaengine.h"
 
-#define MAX_CHAN	8 /*max ch across controllers*/
 #include "intel_mid_dma_regs.h"
 
 #define INTEL_MID_DMAC1_ID		0x0814
@@ -47,8 +47,12 @@
 #define INTEL_BYT_LPIO1_DMAC_ID		0x0F06
 #define INTEL_BYT_LPIO2_DMAC_ID		0x0F40
 #define INTEL_BYT_DMAC0_ID		0x0F28
+#define INTEL_CHT_DMAC0_ID             0x22A8
+#define INTEL_CHT_LPIO1_DMAC_ID		0x2286
+#define INTEL_CHT_LPIO2_DMAC_ID		0x22C0
 
 #define LNW_PERIPHRAL_MASK_SIZE		0x20
+#define ENABLE_PARTITION_UPDATE		(BIT(26))
 
 #define INFO(_max_chan, _ch_base, _block_size, _pimr_mask,	\
 		_pimr_base, _dword_trf, _pimr_offset, _pci_id,	\
@@ -78,7 +82,7 @@ Utility Functions*/
 static int get_ch_index(int status, unsigned int base)
 {
 	int i;
-	for (i = 0; i < MAX_CHAN; i++) {
+	for (i = 0; i < MID_MAX_CHAN; i++) {
 		if (status & (1 << (i + base)))
 			return i;
 	}
@@ -88,7 +92,9 @@ static int get_ch_index(int status, unsigned int base)
 static inline bool is_byt_lpio_dmac(struct middma_device *mid)
 {
 	return (mid->pci_id == INTEL_BYT_LPIO1_DMAC_ID ||
-		mid->pci_id == INTEL_BYT_LPIO2_DMAC_ID);
+		mid->pci_id == INTEL_BYT_LPIO2_DMAC_ID ||
+		mid->pci_id == INTEL_CHT_LPIO1_DMAC_ID ||
+		mid->pci_id == INTEL_CHT_LPIO2_DMAC_ID);
 }
 
 static void dump_dma_reg(struct dma_chan *chan)
@@ -444,7 +450,8 @@ static void midc_descriptor_complete(struct intel_mid_dma_chan *midc,
 	struct intel_mid_dma_lli	*llitem;
 	void *param_txd = NULL;
 
-	dma_cookie_complete(txd);
+	pr_debug("tx cookie after complete = %d\n", txd->cookie);
+
 	callback_txd = txd->callback;
 	param_txd = txd->callback_param;
 
@@ -458,6 +465,7 @@ static void midc_descriptor_complete(struct intel_mid_dma_chan *midc,
 			desc->current_lli = 0;
 	}
 	if (midc->raw_tfr) {
+		dma_cookie_complete(txd);
 		list_del(&desc->desc_node);
 		desc->status = DMA_SUCCESS;
 		if (desc->lli != NULL && desc->lli->llp != 0)
@@ -628,6 +636,7 @@ static dma_cookie_t intel_mid_dma_tx_submit(struct dma_async_tx_descriptor *tx)
 	}
 
 	cookie = dma_cookie_assign(tx);
+	pr_debug("Allocated cookie = %d\n", cookie);
 
 	if (list_empty(&midc->active_list))
 		list_add_tail(&desc->desc_node, &midc->active_list);
@@ -673,21 +682,34 @@ static inline void dma_wait_for_suspend(struct dma_chan *chan, unsigned int mask
 	struct middma_device	*mid = to_middma_device(chan->device);
 	struct intel_mid_dma_chan	*midc = to_intel_mid_dma_chan(chan);
 	int i;
+	const int max_loops = 100;
 
 	/* Suspend channel */
 	cfg_lo.cfg_lo = ioread32(midc->ch_regs + CFG_LOW);
 	cfg_lo.cfg_lo |= mask;
 	iowrite32(cfg_lo.cfg_lo, midc->ch_regs + CFG_LOW);
 	/* wait till FIFO gets empty */
-	/* FIFO should be cleared in couple of milli secs */
-	for (i = 0; i < 10; i++) {
+	/* FIFO should be cleared in a couple of milli secs,
+	   but most of the time after a 'cpu_relax' */
+	for (i = 0; i < max_loops; i++) {
 		cfg_lo.cfg_lo = ioread32(midc->ch_regs + CFG_LOW);
 		if (cfg_lo.cfgx.fifo_empty)
 			break;
-	/* use delay since this might called from atomic context */
-		mdelay(1);
+		/* use udelay since this might called from atomic context,
+		   and use incremental backoff time */
+		if (i)
+			udelay(i);
+		else
+			cpu_relax();
 	}
-	pr_debug("waited for %d ms for FIFO to get empty", i);
+
+	if (i == max_loops)
+		pr_info("Waited 5 ms for chan[%d] FIFO to get empty\n",
+			chan->chan_id);
+	else
+		pr_debug("waited for %d loops for chan[%d] FIFO to get empty",
+			i, chan->chan_id);
+
 	iowrite32(DISABLE_CHANNEL(midc->ch_id), mid->dma_base + DMA_CHAN_EN);
 
 	cfg_lo.cfg_lo = ioread32(midc->ch_regs + CFG_LOW);
@@ -778,11 +800,30 @@ static int intel_mid_dma_device_control(struct dma_chan *chan,
 	struct intel_mid_dma_chan	*midc = to_intel_mid_dma_chan(chan);
 	struct middma_device	*mid = to_middma_device(chan->device);
 	struct intel_mid_dma_desc	*desc, *_desc;
+	struct dma_async_tx_descriptor	*txd;
 
 	pr_debug("%s:CMD:%d for channel:%d\n", __func__, cmd, midc->ch_id);
 	if (cmd == DMA_SLAVE_CONFIG)
 		return dma_slave_control(chan, arg);
 
+	/*
+	 * Leverage the DMA_PAUSE/DMA_RESUME for tuntime PM managemnt.
+	 * DMA customer need make sure the channel is stopped before calling
+	 * the DMA_PAUSE here, and don't start DMA channel befor calling
+	 * DMA_RESUME.
+	 */
+	if (cmd == DMA_PAUSE) {
+		midc->in_use = 0;
+		pm_runtime_put(mid->dev);
+		return 0;
+	}
+
+	if (cmd == DMA_RESUME) {
+		midc->in_use = 1;
+		pm_runtime_get_sync(mid->dev);
+		return 0;
+	}
+
 	if (cmd != DMA_TERMINATE_ALL)
 		return -ENXIO;
 
@@ -791,6 +832,7 @@ static int intel_mid_dma_device_control(struct dma_chan *chan,
 		spin_unlock_bh(&midc->lock);
 		return 0;
 	}
+
 	/* Disable CH interrupts */
 	disable_dma_interrupt(midc);
 	/* clear channel interrupts */
@@ -799,6 +841,10 @@ static int intel_mid_dma_device_control(struct dma_chan *chan,
 	midc->busy = false;
 	midc->descs_allocated = 0;
 	list_for_each_entry_safe(desc, _desc, &midc->active_list, desc_node) {
+		if (desc->status == DMA_IN_PROGRESS) {
+			txd = &desc->txd;
+			dma_cookie_complete(txd);
+		}
 		list_del(&desc->desc_node);
 		if (desc->lli != NULL)
 			dma_pool_free(desc->lli_pool, desc->lli,
@@ -1023,29 +1069,67 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy_v2(
 	cfg_lo.cfgx_v2.dst_burst_align = 1;
 	cfg_lo.cfgx_v2.src_burst_align = 1;
 
-	/*calculate CFG_HI*/
-	if (mids->cfg_mode == LNW_DMA_MEM_TO_MEM) {
-		/*SW HS only*/
-		cfg_hi.cfg_hi = 0;
-	} else {
-		cfg_hi.cfg_hi = 0;
+	/* For  mem to mem transfer, it's SW HS only*/
+	cfg_hi.cfg_hi = 0;
+	/*calculate CFG_HI for mem to/from dev scenario */
+	if (mids->cfg_mode != LNW_DMA_MEM_TO_MEM) {
 		if (midc->dma->pimr_mask) {
+			/* device_instace => SSP0 = 0, SSP1 = 1, SSP2 = 2*/
+			if (mids->device_instance > 2) {
+				pr_err("Invalid SSP identifier\n");
+				return NULL;
+			}
+			cfg_hi.cfgx_v2.src_per = 0;
+			cfg_hi.cfgx_v2.dst_per = 0;
+			if (mids->dma_slave.direction == DMA_MEM_TO_DEV)
+				/* SSP DMA in Tx direction */
+				cfg_hi.cfgx_v2.dst_per = (2 * mids->device_instance) + 1;
+			else if (mids->dma_slave.direction == DMA_DEV_TO_MEM)
+				/* SSP DMA in Rx direction */
+				cfg_hi.cfgx_v2.src_per = (2 * mids->device_instance);
+			else
+				return NULL;
+
+		} else if (midc->dma->pci_id == INTEL_MRFLD_GP_DMAC2_ID) {
 			if (mids->dma_slave.direction == DMA_MEM_TO_DEV) {
 				cfg_hi.cfgx_v2.src_per = 0;
-				if (mids->device_instance == 0)
-					cfg_hi.cfgx_v2.dst_per = 1;
-				if (mids->device_instance == 1)
-					cfg_hi.cfgx_v2.dst_per = 3;
-			} else if (mids->dma_slave.direction == DMA_DEV_TO_MEM) {
-				if (mids->device_instance == 0)
-					cfg_hi.cfgx_v2.src_per = 0;
-				if (mids->device_instance == 1)
-					cfg_hi.cfgx_v2.src_per = 2;
+
+				if (mids->device_instance ==
+					MRFL_INSTANCE_SPI3)
+					cfg_hi.cfgx_v2.dst_per = 0xF;
+				else if (mids->device_instance ==
+					MRFL_INSTANCE_SPI5)
+					cfg_hi.cfgx_v2.dst_per = 0xD;
+				else if (mids->device_instance ==
+					MRFL_INSTANCE_SPI6)
+					cfg_hi.cfgx_v2.dst_per = 0xB;
+				else
+					cfg_hi.cfgx_v2.dst_per = midc->ch_id
+						- midc->dma->chan_base;
+			} else if (mids->dma_slave.direction
+				== DMA_DEV_TO_MEM) {
+				if (mids->device_instance ==
+					MRFL_INSTANCE_SPI3)
+					cfg_hi.cfgx_v2.src_per = 0xE;
+				else if (mids->device_instance ==
+					MRFL_INSTANCE_SPI5)
+					cfg_hi.cfgx_v2.src_per = 0xC;
+				else if (mids->device_instance ==
+					MRFL_INSTANCE_SPI6)
+					cfg_hi.cfgx_v2.src_per = 0xA;
+				else
+					cfg_hi.cfgx_v2.src_per = midc->ch_id
+						- midc->dma->chan_base;
+
 				cfg_hi.cfgx_v2.dst_per = 0;
+			} else {
+				cfg_hi.cfgx_v2.dst_per =
+					cfg_hi.cfgx_v2.src_per = 0;
 			}
 		} else {
-			cfg_hi.cfgx_v2.src_per = cfg_hi.cfgx_v2.dst_per =
-					midc->ch_id - midc->dma->chan_base;
+			cfg_hi.cfgx_v2.src_per =
+				cfg_hi.cfgx_v2.dst_per =
+				midc->ch_id - midc->dma->chan_base;
 		}
 	}
 	/*calculate CTL_HI*/
@@ -1549,17 +1633,17 @@ static irqreturn_t intel_mid_dma_interrupt(int irq, void *data)
 	u32 tfr_status, err_status, block_status;
 	u32 isr;
 
-	/* On Baytrail, the DMAC is sharing IRQ with other devices */
-	if (is_byt_lpio_dmac(mid) && mid->state == SUSPENDED)
-		return IRQ_NONE;
-
 	/*DMA Interrupt*/
 	pr_debug("MDMA:Got an interrupt on irq %d\n", irq);
 	if (!mid) {
 		pr_err("ERR_MDMA:null pointer mid\n");
-		return -EINVAL;
+		return IRQ_NONE;
 	}
 
+	/* On Baytrail, the DMAC is sharing IRQ with other devices */
+	if (is_byt_lpio_dmac(mid) && mid->state == SUSPENDED)
+		return IRQ_NONE;
+
 	/* Read the interrupt status registers */
 	tfr_status = ioread32(mid->dma_base + STATUS_TFR);
 	err_status = ioread32(mid->dma_base + STATUS_ERR);
@@ -1619,7 +1703,8 @@ static void config_dma_fifo_partition(struct middma_device *dma)
 	iowrite32(DMA_FIFO_SIZE, dma->dma_base + FIFO_PARTITION0_HI);
 	iowrite32(DMA_FIFO_SIZE, dma->dma_base + FIFO_PARTITION1_LO);
 	iowrite32(DMA_FIFO_SIZE, dma->dma_base + FIFO_PARTITION1_HI);
-	iowrite32(DMA_FIFO_SIZE | BIT(26), dma->dma_base + FIFO_PARTITION0_LO);
+	iowrite32(DMA_FIFO_SIZE | ENABLE_PARTITION_UPDATE,
+				dma->dma_base + FIFO_PARTITION0_LO);
 }
 
 /* v1 ops will be used for Medfield & CTP platforms */
@@ -1635,7 +1720,7 @@ static struct intel_mid_dma_ops v1_dma_ops = {
 	.dma_chan_suspend		= intel_mid_dma_chan_suspend_v1,
 };
 
-/* v2 ops will be used in Merrifield and beyond plantforms */
+/* v2 ops will be used in Merrifield and beyond platforms */
 static struct intel_mid_dma_ops v2_dma_ops = {
 	.device_alloc_chan_resources    = intel_mid_dma_alloc_chan_resources,
 	.device_free_chan_resources     = intel_mid_dma_free_chan_resources,
@@ -1836,14 +1921,21 @@ static int intel_mid_dma_probe(struct pci_dev *pdev,
 	struct middma_device *device;
 	u32 base_addr, bar_size;
 	struct intel_mid_dma_probe_info *info;
-	int err;
+	int err = -EINVAL;
 
 	pr_debug("MDMA: probe for %x\n", pdev->device);
 	info = (void *)id->driver_data;
 	pr_debug("MDMA: CH %d, base %d, block len %d, Periphral mask %x\n",
 				info->max_chan, info->ch_base,
 				info->block_size, info->pimr_mask);
-
+	/* REVERT ME: forcing failure of Audio DMA on CRC HVP  */
+	/* Temporary workaround waiting for root causing issue */
+	if ((info->pci_id == INTEL_MRFLD_DMAC0_ID)
+		&& (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CARBONCANYON)
+		&& (intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_HVP)) {
+		pr_err("Temporary WA : forcing failure of DMAC0 for CRC HVP\n");
+		goto err_enable_device;
+	}
 	err = pci_enable_device(pdev);
 	if (err)
 		goto err_enable_device;
@@ -1890,7 +1982,7 @@ static int intel_mid_dma_probe(struct pci_dev *pdev,
 		goto err_ioremap;
 
 	pm_runtime_put_noidle(&pdev->dev);
-	pm_runtime_forbid(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
 	return 0;
 
 err_ioremap:
@@ -2011,11 +2103,28 @@ static struct pci_device_id intel_mid_dma_ids[] = {
 		INFO(4, 0, SST_MAX_DMA_LEN_MRFLD, 0, 0, 0, 0, INTEL_MRFLD_GP_DMAC2_ID, &v2_dma_ops)},
 	{ PCI_VDEVICE(INTEL, INTEL_MRFLD_DMAC0_ID),
 		INFO(2, 6, SST_MAX_DMA_LEN_MRFLD, 0xFF0000, 0xFF340018, 0, 0x10, INTEL_MRFLD_DMAC0_ID, &v2_dma_ops)},
+
+	/* Moorfield */
+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_GP_DMAC2_MOOR),
+		INFO(4, 0, SST_MAX_DMA_LEN_MRFLD, 0, 0, 0, 0,
+				PCI_DEVICE_ID_INTEL_GP_DMAC2_MOOR, &v2_dma_ops)},
+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_AUDIO_DMAC0_MOOR),
+		INFO(2, 6, SST_MAX_DMA_LEN_MRFLD, 0xFF0000, 0xFF340018, 0, 0x10,
+				PCI_DEVICE_ID_INTEL_AUDIO_DMAC0_MOOR, &v2_dma_ops)},
+
 	/* Baytrail Low Speed Peripheral DMA */
 	{ PCI_VDEVICE(INTEL, INTEL_BYT_LPIO1_DMAC_ID),
 		INFO(6, 0, 2047, 0, 0, 1, 0, INTEL_BYT_LPIO1_DMAC_ID, &v1_dma_ops)},
 	{ PCI_VDEVICE(INTEL, INTEL_BYT_LPIO2_DMAC_ID),
 		INFO(6, 0, 2047, 0, 0, 1, 0, INTEL_BYT_LPIO2_DMAC_ID, &v1_dma_ops)},
+	/* Cherryview Low Speed Peripheral DMA */
+	{ PCI_VDEVICE(INTEL, INTEL_CHT_LPIO1_DMAC_ID),
+		INFO(6, 0, 2047, 0, 0, 1, 0, INTEL_CHT_LPIO1_DMAC_ID,
+			&v1_dma_ops)},
+	{ PCI_VDEVICE(INTEL, INTEL_CHT_LPIO2_DMAC_ID),
+		INFO(6, 0, 2047, 0, 0, 1, 0, INTEL_CHT_LPIO2_DMAC_ID,
+			&v1_dma_ops)},
+
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, intel_mid_dma_ids);
@@ -2025,16 +2134,65 @@ struct intel_mid_dma_probe_info dma_byt_info = {
 	.ch_base = 4,
 	.block_size = 131071,
 	.pimr_mask = 0x00FF0000,
-	.pimr_base = 0xDF540018,
+	.pimr_base = 0, /* get base addr from device table */
 	.dword_trf = 0,
 	.pimr_offset = 0x10,
 	.pci_id = INTEL_BYT_DMAC0_ID,
 	.pdma_ops = &v2_dma_ops,
 };
 
+struct intel_mid_dma_probe_info dma_byt1_info = {
+	.max_chan = 6,
+	.ch_base = 0,
+	.block_size = 2047,
+	.pimr_mask = 0,
+	.pimr_base = 0,
+	.dword_trf = 1,
+	.pimr_offset = 0,
+	.pci_id = INTEL_BYT_LPIO1_DMAC_ID,
+	.pdma_ops = &v1_dma_ops,
+};
+
+
+struct intel_mid_dma_probe_info dma_cht_info = {
+	.max_chan = 4,
+	.ch_base = 4,
+	.block_size = 131071,
+	.pimr_mask = 0x00FF0000,
+	.pimr_base = 0, /* get base addr from device table */
+	.dword_trf = 0,
+	.pimr_offset = 0x10,
+	.pci_id = INTEL_CHT_DMAC0_ID,
+	.pdma_ops = &v2_dma_ops,
+};
+
+struct intel_mid_dma_probe_info dma_cht1_info = {
+	.max_chan = 6,
+	.ch_base = 0,
+	.block_size = 2047,
+	.pimr_mask = 0,
+	.pimr_base = 0,
+	.dword_trf = 1,
+	.pimr_offset = 0,
+	.pci_id = INTEL_CHT_LPIO1_DMAC_ID,
+	.pdma_ops = &v1_dma_ops,
+};
+
+struct intel_mid_dma_probe_info dma_cht2_info = {
+	.max_chan = 6,
+	.ch_base = 0,
+	.block_size = 2047,
+	.pimr_mask = 0,
+	.pimr_base = 0,
+	.dword_trf = 1,
+	.pimr_offset = 0,
+	.pci_id = INTEL_CHT_LPIO2_DMAC_ID,
+	.pdma_ops = &v1_dma_ops,
+};
+
 static const struct dev_pm_ops intel_mid_dma_pm = {
-	SET_SYSTEM_SLEEP_PM_OPS(dma_suspend,
-			dma_resume)
+	.suspend_late = dma_suspend,
+	.resume_early = dma_resume,
 	SET_RUNTIME_PM_OPS(dma_runtime_suspend,
 			dma_runtime_resume,
 			dma_runtime_idle)
@@ -2066,6 +2224,11 @@ struct intel_mid_dma_probe_info *mid_get_acpi_driver_data(const char *hid)
 }
 static const struct acpi_device_id dma_acpi_ids[] = {
 	{ "DMA0F28", (kernel_ulong_t)&dma_byt_info },
+	{ "ADMA0F28", (kernel_ulong_t)&dma_byt_info },
+	{ "INTL9C60", (kernel_ulong_t)&dma_byt1_info },
+	{ "80862286", (kernel_ulong_t)&dma_cht1_info },
+	{ "808622C0", (kernel_ulong_t)&dma_cht2_info },
+	{ "ADMA22A8", (kernel_ulong_t)&dma_cht_info },
 	{ },
 };
 
diff --git a/drivers/dma/intel_mid_dma_acpi.c b/drivers/dma/intel_mid_dma_acpi.c
index 2bef1ab..e811026 100644
--- a/drivers/dma/intel_mid_dma_acpi.c
+++ b/drivers/dma/intel_mid_dma_acpi.c
@@ -69,19 +69,21 @@ static int mid_get_and_map_rsrc(void **dest, struct platform_device *pdev,
 		pr_err("%s: Invalid resource - %d", __func__, num);
 		return -EIO;
 	}
-	pr_debug("rsrc #%d = %#x", num, rsrc->start);
+	pr_debug("rsrc #%d = %#x", num, (unsigned int) rsrc->start);
 	*dest = devm_ioremap_nocache(&pdev->dev, rsrc->start, resource_size(rsrc));
 	if (!*dest) {
-		pr_err("%s: unable to map resource: %#x", __func__, rsrc->start);
+		pr_err("%s: unable to map resource: %#x", __func__, (unsigned int)rsrc->start);
 		return -EIO;
 	}
 	return 0;
 }
 
-static int mid_platform_get_resources(struct middma_device *mid_device,
+static int mid_platform_get_resources_fdk(struct middma_device *mid_device,
 				      struct platform_device *pdev)
 {
 	int ret;
+	struct resource *rsrc;
+
 	pr_debug("%s", __func__);
 
 	/* All ACPI resource request here */
@@ -91,12 +93,57 @@ static int mid_platform_get_resources(struct middma_device *mid_device,
 		return ret;
 	pr_debug("dma_base:%p", mid_device->dma_base);
 
-	ret = mid_get_and_map_rsrc(&mid_device->mask_reg, pdev, 1);
-	if (ret)
-		return ret;
-	/* mask_reg should point to ISRX register */
-	mid_device->mask_reg += 0x18;
-	pr_debug("pimr_base:%p", mid_device->mask_reg);
+	/* only get the resource from device table
+		mapping is performed in common code */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!rsrc) {
+		pr_warn("%s: Invalid resource for pimr", __func__);
+	} else {
+		/* add offset for ISRX register */
+		mid_device->pimr_base = rsrc->start + SHIM_ISRX_OFFSET;
+		pr_debug("pimr_base:%#x", mid_device->pimr_base);
+	}
+
+	mid_device->irq = platform_get_irq(pdev, 0);
+	if (mid_device->irq < 0) {
+		pr_err("invalid irq:%d", mid_device->irq);
+		return mid_device->irq;
+	}
+	pr_debug("irq from pdev is:%d", mid_device->irq);
+
+	return 0;
+}
+
+#define DMA_BASE_OFFSET 0x98000
+#define DMA_BASE_SIZE 0x4000
+
+static int mid_platform_get_resources_edk2(struct middma_device *mid_device,
+				      struct platform_device *pdev)
+{
+	struct resource *rsrc;
+	u32 dma_base_add;
+
+	pr_debug("%s", __func__);
+	/* All ACPI resource request here */
+	/* Get DDR addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!rsrc) {
+		pr_warn("%s: Invalid resource for pimr", __func__);
+		return -EINVAL;
+	}
+
+	pr_debug("rsrc %#x", (unsigned int)rsrc->start);
+	dma_base_add = rsrc->start + DMA_BASE_OFFSET;
+	mid_device->dma_base = devm_ioremap_nocache(&pdev->dev, dma_base_add, DMA_BASE_SIZE);
+	if (!mid_device->dma_base) {
+		pr_err("%s: unable to map resource: %#x", __func__, dma_base_add);
+		return -EIO;
+	}
+	pr_debug("dma_base:%p", mid_device->dma_base);
+
+	/* add offset for ISRX register */
+	mid_device->pimr_base = rsrc->start + SHIM_OFFSET + SHIM_ISRX_OFFSET;
+	pr_debug("pimr_base:%#x", mid_device->pimr_base);
 
 	mid_device->irq = platform_get_irq(pdev, 0);
 	if (mid_device->irq < 0) {
@@ -108,6 +155,23 @@ static int mid_platform_get_resources(struct middma_device *mid_device,
 	return 0;
 }
 
+static int mid_platform_get_resources(const char *hid,
+		struct middma_device *mid_device, struct platform_device *pdev)
+{
+	if (!strncmp(hid, "DMA0F28", 7))
+		return mid_platform_get_resources_fdk(mid_device, pdev);
+	if (!strncmp(hid, "INTL9C60", 8))
+		return mid_platform_get_resources_fdk(mid_device, pdev);
+	if (!strncmp(hid, "ADMA0F28", 8))
+		return mid_platform_get_resources_edk2(mid_device, pdev);
+	else if ((!strncmp(hid, "ADMA22A8", 8))) {
+		return mid_platform_get_resources_edk2(mid_device, pdev);
+	} else {
+		pr_err("Invalid device id..\n");
+		return -EINVAL;
+	}
+}
+
 int dma_acpi_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -117,6 +181,7 @@ int dma_acpi_probe(struct platform_device *pdev)
 	struct intel_mid_dma_probe_info *info;
 	const char *hid;
 	int ret;
+	struct acpi_dma_dev_list *listnode;
 
 	ret = acpi_bus_get_device(handle, &device);
 	if (ret) {
@@ -159,7 +224,7 @@ int dma_acpi_probe(struct platform_device *pdev)
 	if (!mid_device)
 		goto err_dma;
 
-	ret = mid_platform_get_resources(mid_device, pdev);
+	ret = mid_platform_get_resources(hid, mid_device, pdev);
 	if (ret) {
 		pr_err("Error while get resources:%d", ret);
 		goto err_dma;
@@ -168,8 +233,21 @@ int dma_acpi_probe(struct platform_device *pdev)
 	ret = mid_setup_dma(&pdev->dev);
 	if (ret)
 		goto err_dma;
+	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
-	acpi_dma_dev = &pdev->dev;
+	pm_runtime_allow(&pdev->dev);
+
+	listnode = devm_kzalloc(&pdev->dev, sizeof(*listnode), GFP_KERNEL);
+	if (!listnode) {
+		pr_err("dma dev list alloc failed\n");
+		ret = -ENOMEM;
+		goto err_dma;
+	}
+
+	strncpy(listnode->dma_hid, hid, HID_MAX_SIZE);
+	listnode->acpi_dma_dev = &pdev->dev;
+	list_add_tail(&listnode->dmadev_list, &dma_dev_list);
+
 	pr_debug("%s:completed", __func__);
 	return 0;
 err_dma:
diff --git a/drivers/dma/intel_mid_dma_regs.h b/drivers/dma/intel_mid_dma_regs.h
index 30160e4..89adc14 100644
--- a/drivers/dma/intel_mid_dma_regs.h
+++ b/drivers/dma/intel_mid_dma_regs.h
@@ -54,7 +54,6 @@
 #define DMA_CH_SIZE		0x58
 #define DMA_FIFO_SIZE 0x100080
 
-
 /*CH X REG = (DMA_CH_SIZE)*CH_NO + REG*/
 #define SAR			0x00 /* Source Address Register*/
 #define DAR			0x08 /* Destination Address Register*/
@@ -93,6 +92,8 @@
 #define FIFO_PARTITION1_HI	0x40C
 #define CH_SAI_ERR		0x410
 
+#define SHIM_OFFSET 0x140000
+#define SHIM_ISRX_OFFSET	0x18
 #define CTL_LO_BIT_LLP_DST_EN	27
 #define CTL_LO_BIT_LLP_SRC_EN	28
 
diff --git a/drivers/gpio/gpio-langwell.c b/drivers/gpio/gpio-langwell.c
index 2c44199..f8b907d 100644
--- a/drivers/gpio/gpio-langwell.c
+++ b/drivers/gpio/gpio-langwell.c
@@ -393,18 +393,9 @@ static void __iomem *gpio_reg_2bit(struct gpio_chip *chip, unsigned offset,
 
 static int lnw_gpio_request(struct gpio_chip *chip, unsigned offset)
 {
-	struct lnw_gpio *lnw = to_lnw_priv(chip);
-	u32 value;
-	void __iomem *gafr;
-	int shift, af;
-
-	if (lnw->type > CLOVERVIEW_GPIO_CORE)
-		return 0;
-
-	gafr = gpio_reg_2bit(chip, offset, GAFR);
-	value = readl(gafr);
-	shift = (offset % 16) << 1;
-	af = (value >> shift) & 3;
+	void __iomem *gafr = gpio_reg_2bit(chip, offset, GAFR);
+	u32 value = readl(gafr);
+	int shift = (offset % 16) << 1, af = (value >> shift) & 3;
 
 	if (af) {
 		value &= ~(3 << shift);
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 877aa4d..3899d25 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -838,15 +838,6 @@ config MSIC_GPADC
 	help
 	  Say Y here to enable MSIC GPADC driver on Intel Medfield Platform
 
-config INTEL_MCU
-	tristate "Intel generic MCU control interface"
-	help
-	  Say Y here to enable control interface for intel mcu
-
-	  This driver provide userspace tty interface for the control and
-	  message output.
-	  You could use normal read/write to complete those operation.
-
 config SENSORS_MAX1111
 	tristate "Maxim MAX1111 Serial 8-bit ADC chip and compatibles"
 	depends on SPI_MASTER
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 11e757a..4e1d647 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -141,7 +141,6 @@ obj-$(CONFIG_SENSORS_W83L786NG)	+= w83l786ng.o
 obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
 obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
 obj-$(CONFIG_MSIC_GPADC)        += intel_mid_gpadc.o
-obj-$(CONFIG_INTEL_MCU)        += intel_mcu_common.o
 
 obj-$(CONFIG_PMBUS)		+= pmbus/
 
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 1137130..72bab34 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -96,7 +96,6 @@ struct mmc_blk_data {
 #define MMC_BLK_CMD23	(1 << 0)	/* Can do SET_BLOCK_COUNT for multiblock */
 #define MMC_BLK_REL_WR	(1 << 1)	/* MMC Reliable write support */
 #define MMC_BLK_PACKED_CMD	(1 << 2)	/* MMC packed command support */
-#define MMC_BLK_SUSPENDED	(1 << 3)	/* MMC block device suspended */
 
 	unsigned int	usage;
 	unsigned int	read_only;
@@ -107,8 +106,7 @@ struct mmc_blk_data {
 #define MMC_BLK_WRITE		BIT(1)
 #define MMC_BLK_DISCARD		BIT(2)
 #define MMC_BLK_SECDISCARD	BIT(3)
-#define MMC_BLK_RPMB		BIT(4)
-#define MMC_BLK_USER		BIT(5)
+
 	/*
 	 * Only set in main mmc_blk_data associated
 	 * with mmc_card with mmc_set_drvdata, and keeps
@@ -148,9 +146,6 @@ static inline void mmc_blk_clear_packed(struct mmc_queue_req *mqrq)
 	packed->blocks = 0;
 }
 
-static int mmc_rpmb_req_process(struct mmc_blk_data *,
-		struct mmc_ioc_rpmb_req *);
-
 static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)
 {
 	struct mmc_blk_data *md;
@@ -166,6 +161,12 @@ static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)
 	return md;
 }
 
+int mmc_access_rpmb(struct mmc_queue *mq)
+{
+	struct mmc_blk_data *md = mq->data;
+	return md && md->part_type == EXT_CSD_PART_CONFIG_ACC_RPMB;
+}
+
 static inline int mmc_get_devidx(struct gendisk *disk)
 {
 	int devmaj = MAJOR(disk_devt(disk));
@@ -573,53 +574,12 @@ cmd_err:
 	return err;
 }
 
-static int mmc_blk_ioctl_rpmb_req(struct block_device *bdev,
-		struct mmc_ioc_rpmb_req __user *ptr)
-{
-	struct mmc_ioc_rpmb_req req;
-	struct mmc_blk_data *md = NULL;
-	int err = 0;
-
-	/* The caller must have CAP_SYS_RAWIO */
-	if (!capable(CAP_SYS_RAWIO))
-		return -EPERM;
-
-	memset(&req, 0, sizeof(req));
-
-	if (copy_from_user(&req, ptr, sizeof(req)))
-		return -EFAULT;
-
-	md = mmc_blk_get(bdev->bd_disk);
-	if (!md) {
-		pr_err("%s: NO eMMC block data. Try it later\n",
-				__func__);
-		return -ENODEV;
-	}
-	/* handle RPMB request event */
-	err = mmc_rpmb_req_process(md, &req);
-	if (err) {
-		mmc_blk_put(md);
-		return err;
-	}
-	/*
-	 * feedback to user space
-	 */
-	if (copy_to_user(ptr, &req, sizeof(req)))
-		return -EFAULT;
-
-	mmc_blk_put(md);
-	return 0;
-}
-
 static int mmc_blk_ioctl(struct block_device *bdev, fmode_t mode,
 	unsigned int cmd, unsigned long arg)
 {
 	int ret = -EINVAL;
 	if (cmd == MMC_IOC_CMD)
 		ret = mmc_blk_ioctl_cmd(bdev, (struct mmc_ioc_cmd __user *)arg);
-	else if (cmd == MMC_IOC_RPMB_REQ)
-		ret = mmc_blk_ioctl_rpmb_req(bdev,
-				(struct mmc_ioc_rpmb_req __user *)arg);
 	return ret;
 }
 
@@ -937,114 +897,6 @@ static inline void mmc_blk_reset_success(struct mmc_blk_data *md, int type)
 	md->reset_done &= ~type;
 }
 
-static int mmc_rpmb_req_process(struct mmc_blk_data *md,
-		struct mmc_ioc_rpmb_req *req)
-{
-	struct mmc_core_rpmb_req rpmb_req;
-	struct mmc_card *card = NULL;
-	int ret;
-
-	if (!md || !req)
-		return -EINVAL;
-
-	if (!(md->flags & MMC_BLK_CMD23) ||
-			(md->part_type != EXT_CSD_PART_CONFIG_ACC_RPMB))
-		return -EOPNOTSUPP;
-
-	card = md->queue.card;
-	if (!card || !mmc_card_mmc(card) || !card->ext_csd.rpmb_size)
-		return -ENODEV;
-
-	memset(&rpmb_req, 0, sizeof(struct mmc_core_rpmb_req));
-	rpmb_req.req = req;
-	/* check request */
-	ret = mmc_rpmb_pre_frame(&rpmb_req, card);
-	if (ret) {
-		pr_err("%s: prepare frame failed\n", mmc_hostname(card->host));
-		return ret;
-	}
-
-	mmc_claim_host(card->host);
-
-	if (md->flags & MMC_BLK_SUSPENDED) {
-		pr_warn("%s: MMC block device is already suspended\n",
-				mmc_hostname(card->host));
-		ret = -EPERM;
-		goto out;
-	}
-	/*
-	 * before start, let's change to RPMB partition first
-	 */
-	ret = mmc_blk_part_switch(card, md);
-	if (ret) {
-		pr_err("%s: Invalid RPMB partition switch (%d)!\n",
-				mmc_hostname(card->host), ret);
-		/*
-		 * In case partition is not in user data area, make
-		 * a force partition switch.
-		 * we need reset eMMC card at here
-		 */
-		ret = mmc_blk_reset(md, card->host, MMC_BLK_RPMB);
-		if (!ret)
-			mmc_blk_reset_success(md, MMC_BLK_RPMB);
-		else
-			pr_err("%s: eMMC card reset failed (%d)\n",
-					mmc_hostname(card->host), ret);
-		goto out;
-	}
-
-	ret = mmc_rpmb_partition_ops(&rpmb_req, card);
-	if (ret)
-		pr_err("%s: failed (%d) to handle RPMB request type (%d)!\n",
-				mmc_hostname(card->host), ret, req->type);
-out:
-	mmc_release_host(card->host);
-	mmc_rpmb_post_frame(&rpmb_req);
-	return ret;
-}
-
-int mmc_access_rpmb(struct mmc_queue *mq)
-{
-	struct mmc_blk_data *md = mq->data;
-	/*
-	 * If this is a RPMB partition access, return ture
-	 */
-	if (md && md->part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)
-		return true;
-
-	return false;
-}
-EXPORT_SYMBOL_GPL(mmc_access_rpmb);
-
-int mmc_rpmb_req_handle(struct device *emmc, struct mmc_ioc_rpmb_req *req)
-{
-	int ret = 0;
-	struct gendisk *disk    = NULL;
-	struct mmc_blk_data *md = NULL;
-
-	if (!emmc || !req)
-		return -EINVAL;
-
-	disk = dev_to_disk(emmc);
-	if (!disk) {
-		pr_err("%s: NO eMMC disk found. Try it later\n",
-				__func__);
-		return -ENODEV;
-	}
-
-	md = mmc_blk_get(disk);
-	if (!md) {
-		pr_err("%s: NO eMMC block data. Try it later\n",
-				__func__);
-		return -ENODEV;
-	}
-	ret = mmc_rpmb_req_process(md, req);
-	mmc_blk_put(md);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(mmc_rpmb_req_handle);
-
 static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
@@ -2053,16 +1905,11 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 
 	ret = mmc_blk_part_switch(card, md);
 	if (ret) {
-		pr_err("%s: switch part failed. Try to reset eMMC\n",
-				mmc_hostname(card->host));
-		if (mmc_blk_reset(md, card->host, MMC_BLK_USER)) {
-			if (req)
-				blk_end_request_all(req, -EIO);
-			ret = 0;
-			goto out;
+		if (req) {
+			blk_end_request_all(req, -EIO);
 		}
-		pr_info("%s: Reset eMMC success\n", mmc_hostname(card->host));
-		mmc_blk_reset_success(md, MMC_BLK_USER);
+		ret = 0;
+		goto out;
 	}
 
 	mq->flags &= ~MMC_QUEUE_NEW_REQUEST;
@@ -2525,19 +2372,6 @@ static int mmc_blk_suspend(struct mmc_card *card)
 		mmc_queue_suspend(&md->queue);
 		list_for_each_entry(part_md, &md->part, part) {
 			mmc_queue_suspend(&part_md->queue);
-			if (part_md->part_type ==
-				EXT_CSD_PART_CONFIG_ACC_RPMB) {
-				/*
-				 * RPMB partition is accessed by API directly.
-				 * Driver need to set a flag when suspending
-				 * MMC block device to notify API that the
-				 * accessing of RPMB partition needs to be
-				 * stopped
-				 */
-				mmc_claim_host(card->host);
-				part_md->flags |= MMC_BLK_SUSPENDED;
-				mmc_release_host(card->host);
-			}
 		}
 	}
 	return 0;
@@ -2557,18 +2391,6 @@ static int mmc_blk_resume(struct mmc_card *card)
 		mmc_queue_resume(&md->queue);
 		list_for_each_entry(part_md, &md->part, part) {
 			mmc_queue_resume(&part_md->queue);
-			if (part_md->part_type ==
-					EXT_CSD_PART_CONFIG_ACC_RPMB) {
-				/*
-				 * RPMB partition is accessed by API directly.
-				 * Driver need to clear MMC_BLK_SUSPENDED flag
-				 * to make sure the next RPMB partition access
-				 * request won't be blocked
-				 */
-				mmc_claim_host(card->host);
-				part_md->flags &= ~MMC_BLK_SUSPENDED;
-				mmc_release_host(card->host);
-			}
 		}
 	}
 	return 0;
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 88327f7..2c84ec5 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -38,7 +38,7 @@ static int mmc_prep_request(struct request_queue *q, struct request *req)
 		return BLKPREP_KILL;
 	}
 
-	if (mq && (mmc_card_removed(mq->card) || mmc_access_rpmb(mq)))
+	if (mq && mmc_card_removed(mq->card) || mmc_access_rpmb(mq))
 		return BLKPREP_KILL;
 
 	req->cmd_flags |= REQ_DONTPREP;
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index 3bbd4e6..23460e6 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -73,5 +73,5 @@ extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 extern int mmc_packed_init(struct mmc_queue *, struct mmc_card *);
 extern void mmc_packed_clean(struct mmc_queue *);
 
-extern int mmc_access_rpmb(struct mmc_queue *);
+int mmc_access_rpmb(struct mmc_queue *mq);
 #endif
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index fc39179..89d6082 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -504,9 +504,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		 * RPMB regions are defined in multiples of 128K.
 		 */
 		card->ext_csd.raw_rpmb_size_mult = ext_csd[EXT_CSD_RPMB_MULT];
-		card->ext_csd.rpmb_size = 128 *
-			card->ext_csd.raw_rpmb_size_mult;
-		card->ext_csd.rpmb_size <<= 2; /* Unit: half sector */
 		if (ext_csd[EXT_CSD_RPMB_MULT] && mmc_host_cmd23(card->host)) {
 			mmc_part_add(card, ext_csd[EXT_CSD_RPMB_MULT] << 17,
 				EXT_CSD_PART_CONFIG_ACC_RPMB,
@@ -558,17 +555,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		card->ext_csd.data_sector_size = 512;
 	}
 
-	/*
-	 * If use legacy reliable write, then the blk counts must not
-	 * big than the reliable write sectors
-	 */
-	if (!(card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN)) {
-		if (card->ext_csd.rel_sectors < RPMB_AVALIABLE_SECTORS)
-			card->rpmb_max_req = card->ext_csd.rel_sectors;
-		else
-			card->rpmb_max_req = RPMB_AVALIABLE_SECTORS;
-	} else
-		card->rpmb_max_req = RPMB_AVALIABLE_SECTORS;
 out:
 	return err;
 }
@@ -656,7 +642,6 @@ MMC_DEV_ATTR(enhanced_area_offset, "%llu\n",
 MMC_DEV_ATTR(enhanced_area_size, "%u\n", card->ext_csd.enhanced_area_size);
 MMC_DEV_ATTR(raw_rpmb_size_mult, "%#x\n", card->ext_csd.raw_rpmb_size_mult);
 MMC_DEV_ATTR(rel_sectors, "%#x\n", card->ext_csd.rel_sectors);
-MMC_DEV_ATTR(rpmb_size, "%d\n", card->ext_csd.rpmb_size);
 
 static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_cid.attr,
@@ -675,7 +660,6 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_enhanced_area_size.attr,
 	&dev_attr_raw_rpmb_size_mult.attr,
 	&dev_attr_rel_sectors.attr,
-	&dev_attr_rpmb_size.attr,
 	NULL,
 };
 
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 432af79..a3d0615 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -638,415 +638,3 @@ int mmc_send_hpi_cmd(struct mmc_card *card, u32 *status)
 
 	return 0;
 }
-
-static int mmc_rpmb_send_command(struct mmc_card *card, u8 *buf, __u16 blks,
-		__u16 type, u8 req_type)
-{
-	struct mmc_request mrq = {NULL};
-	struct mmc_command cmd = {0};
-	struct mmc_command sbc = {0};
-	struct mmc_data data = {0};
-	struct scatterlist sg;
-	u8 *transfer_buf = NULL;
-
-	mrq.sbc = &sbc;
-	mrq.cmd = &cmd;
-	mrq.data = &data;
-	mrq.stop = NULL;
-	transfer_buf = kzalloc(512 * blks, GFP_KERNEL);
-	if (!transfer_buf)
-		return -ENOMEM;
-
-	/*
-	 * set CMD23
-	 */
-	sbc.opcode = MMC_SET_BLOCK_COUNT;
-	sbc.arg = blks;
-	if ((req_type == RPMB_REQ) && (type == RPMB_WRITE_DATA ||
-				type == RPMB_PROGRAM_KEY))
-		sbc.arg |= 1 << 31;
-	sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
-
-	/*
-	 * set CMD25/18
-	 */
-	sg_init_one(&sg, transfer_buf, 512 * blks);
-	if (req_type == RPMB_REQ) {
-		cmd.opcode = MMC_WRITE_MULTIPLE_BLOCK;
-		sg_copy_from_buffer(&sg, 1, buf, 512 * blks);
-		data.flags |= MMC_DATA_WRITE;
-	} else {
-		cmd.opcode = MMC_READ_MULTIPLE_BLOCK;
-		data.flags |= MMC_DATA_READ;
-	}
-	cmd.arg = 0;
-	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
-	data.blksz = 512;
-	data.blocks = blks;
-	data.sg = &sg;
-	data.sg_len = 1;
-
-	mmc_set_data_timeout(&data, card);
-
-	mmc_wait_for_req(card->host, &mrq);
-
-	if (req_type != RPMB_REQ)
-		sg_copy_to_buffer(&sg, 1, buf, 512 * blks);
-
-	kfree(transfer_buf);
-
-	if (cmd.error)
-		return cmd.error;
-	if (data.error)
-		return data.error;
-	return 0;
-}
-
-void mmc_rpmb_post_frame(struct mmc_core_rpmb_req *rpmb_req)
-{
-	int i;
-	struct mmc_ioc_rpmb_req *p_req;
-	__u8 *buf_frame;
-
-	if (!rpmb_req || !rpmb_req->ready)
-		return;
-
-	p_req = rpmb_req->req;
-	buf_frame = rpmb_req->frame;
-
-	if (!p_req || !buf_frame)
-		return;
-	/*
-	 * Regarding to the check rules, here is the post
-	 * rules
-	 * All will return result.
-	 * GET_WRITE_COUNTER:
-	 *              must: write counter, nonce
-	 *              optional: MAC
-	 * WRITE_DATA:
-	 *              must: MAC, write counter
-	 * READ_DATA:
-	 *              must: nonce, data
-	 *              optional: MAC
-	 * PROGRAM_KEY:
-	 *              must: Nothing
-	 *
-	 * Except READ_DATA, all of these operations only need to parse
-	 * one frame. READ_DATA needs blks frames to get DATA
-	 */
-
-	memcpy(p_req->result, buf_frame + RPMB_RES_BEG, 2);
-	*p_req->result = be16_to_cpup(p_req->result);
-
-	if (p_req->type == RPMB_PROGRAM_KEY)
-		goto out;
-
-	if (p_req->type == RPMB_GET_WRITE_COUNTER ||
-			p_req->type == RPMB_WRITE_DATA) {
-		memcpy(p_req->wc, buf_frame + RPMB_WCOUNTER_BEG, 4);
-		*p_req->wc = be32_to_cpup(p_req->wc);
-	}
-
-	if (p_req->type == RPMB_GET_WRITE_COUNTER ||
-			p_req->type == RPMB_READ_DATA) {
-		/* nonce copy */
-		memcpy(p_req->nonce, buf_frame + RPMB_NONCE_BEG, 16);
-	}
-	/*
-	 * Take MAC within the last package
-	 */
-	if (p_req->type == RPMB_READ_DATA) {
-		__u8 *data = p_req->data;
-		for (i = 0; i < p_req->blk_cnt; i++) {
-			memcpy(data, buf_frame + i * 512 + RPMB_DATA_BEG, 256);
-			data += 256;
-		}
-		/*
-		 * MAC stored in the last package
-		 */
-		if (p_req->mac)
-			memcpy(p_req->mac, buf_frame + i * 512 + RPMB_MAC_BEG,
-					32);
-	} else if (p_req->mac)
-		memcpy(p_req->mac, buf_frame + RPMB_MAC_BEG, 32);
-out:
-	kfree(buf_frame);
-	rpmb_req->frame = NULL;
-	return;
-}
-EXPORT_SYMBOL_GPL(mmc_rpmb_post_frame);
-
-static int mmc_rpmb_request_check(struct mmc_card *card,
-		struct mmc_ioc_rpmb_req *p_req)
-{
-	/*
-	 * Some parameters are a must for the operation. Different
-	 * operation expect different paramters. Below code is
-	 * used for checking this.
-	 *
-	 * All operations will need result.
-	 * GET_WRITE_COUNTER:
-	 *              must: write counter, nonce
-	 *              optional: MAC
-	 * WRITE_DATA:
-	 *              must: MAC, data, write counter
-	 * READ_DATA:
-	 *              must: nonce, data
-	 *              optional: MAC
-	 * PROGRAM_KEY:
-	 *              must: MAC
-	 *
-	 * So here, we only check the 'must' paramters
-	 */
-	if (!p_req->result) {
-		pr_err("%s: Type %d has NULL pointer for result\n",
-				mmc_hostname(card->host), p_req->type);
-		return -EINVAL;
-	}
-
-	if (p_req->type == RPMB_GET_WRITE_COUNTER) {
-		if (!p_req->nonce || !p_req->wc) {
-			pr_err("%s: Type %d has NULL pointer for nonce/wc\n",
-					mmc_hostname(card->host), p_req->type);
-			return -EINVAL;
-		}
-		/*
-		 * used to allocate frame
-		 */
-		p_req->blk_cnt = 1;
-	} else if (p_req->type == RPMB_WRITE_DATA ||
-			p_req->type == RPMB_READ_DATA) {
-		if ((__u32)(p_req->addr + p_req->blk_cnt) >
-				card->ext_csd.rpmb_size) {
-			pr_err("%s Type %d: beyond the RPMB partition rang addr %d, blk_cnt %d, rpmb_size %d\n",
-					mmc_hostname(card->host),
-					p_req->type,
-					p_req->addr,
-					p_req->blk_cnt,
-					card->ext_csd.rpmb_size);
-			return -EINVAL;
-		}
-		if (p_req->blk_cnt == 0) {
-			pr_err("%s: Type %d has zero block count\n",
-					mmc_hostname(card->host),
-					p_req->blk_cnt);
-			return -EINVAL;
-		} else if (p_req->blk_cnt > card->rpmb_max_req) {
-			pr_err("%s: Type %d has invalid block count, cannot large than %d\n",
-					mmc_hostname(card->host),
-					p_req->blk_cnt,
-					card->rpmb_max_req);
-			return -EINVAL;
-		}
-		if (!p_req->data) {
-			pr_err("%s: Type %d has NULL pointer for data\n",
-					mmc_hostname(card->host), p_req->type);
-			return -EINVAL;
-		}
-		if (p_req->type == RPMB_WRITE_DATA) {
-			if (!p_req->wc || !p_req->mac) {
-				pr_err("%s: Type %d has NULL pointer for write counter/MAC\n",
-						mmc_hostname(card->host),
-						p_req->type);
-				return -EINVAL;
-			}
-		} else {
-			if (!p_req->nonce) {
-				pr_err("%s: Type %d has NULL pointer for nonce\n",
-						mmc_hostname(card->host),
-						p_req->type);
-				return -EINVAL;
-			}
-		}
-	} else if (p_req->type == RPMB_PROGRAM_KEY) {
-		if (!p_req->mac) {
-			pr_err("%s: Type %d has NULL pointer for MAC\n",
-					mmc_hostname(card->host), p_req->type);
-			return -EINVAL;
-		}
-		/*
-		 * used to allocate frame
-		 */
-		p_req->blk_cnt = 1;
-	} else
-		return -EOPNOTSUPP;
-
-	return 0;
-}
-
-/*
- * prepare the request of RPMB frame
- * RPMB frame is MSB first
- * convert needed bytes
- * return how many frames will be prepared
- */
-int mmc_rpmb_pre_frame(struct mmc_core_rpmb_req *rpmb_req,
-		struct mmc_card *card)
-{
-	int i, ret;
-	struct mmc_ioc_rpmb_req *p_req;
-	__u8 *buf_frame;
-	__u16 blk_cnt, addr, type;
-	__u32 w_counter;
-
-	if (!rpmb_req || !card)
-		return -EINVAL;
-
-	p_req = rpmb_req->req;
-	if (!p_req) {
-		pr_err("%s: mmc_ioc_rpmb_req is NULL. Wrong parameter\n",
-				mmc_hostname(card->host));
-		return -EINVAL;
-	}
-
-	/*
-	 * make sure these two items are clear
-	 */
-	rpmb_req->ready = 0;
-	rpmb_req->frame = NULL;
-
-	ret = mmc_rpmb_request_check(card, p_req);
-	if (ret)
-		return ret;
-
-	buf_frame = kzalloc(512 * p_req->blk_cnt, GFP_KERNEL);
-	if (!buf_frame) {
-		pr_err("%s: cannot allocate frame for type %d\n",
-				mmc_hostname(card->host), p_req->type);
-		return -ENOMEM;
-	}
-
-	type = cpu_to_be16p(&p_req->type);
-	if (p_req->type == RPMB_GET_WRITE_COUNTER ||
-			p_req->type == RPMB_READ_DATA) {
-		/*
-		 * One package prepared
-		 * This request needs Nonce and type
-		 * If is data read, then also need addr
-		 */
-		memcpy(buf_frame + RPMB_TYPE_BEG, &type, 2);
-		if (p_req->type == RPMB_READ_DATA) {
-			addr = cpu_to_be16p(&p_req->addr);
-			memcpy(buf_frame + RPMB_ADDR_BEG, &addr, 2);
-		}
-		/* convert Nonce code */
-		memcpy(buf_frame + RPMB_NONCE_BEG, p_req->nonce, 16);
-	} else if (p_req->type == RPMB_WRITE_DATA) {
-		__u8 *data = p_req->data;
-		/*
-		 * multiple package prepared
-		 * This request nees blk_cnt, addr, write_counter,
-		 * data and mac
-		 */
-		blk_cnt = cpu_to_be16p(&p_req->blk_cnt);
-		addr = cpu_to_be16p(&p_req->addr);
-		w_counter = cpu_to_be32p(p_req->wc);
-		for (i = 0; i < p_req->blk_cnt; i++) {
-			memcpy(buf_frame + i * 512 + RPMB_TYPE_BEG,
-					&type, 2);
-			memcpy(buf_frame + i * 512 + RPMB_BLKS_BEG,
-					&blk_cnt, 2);
-			memcpy(buf_frame + i * 512 + RPMB_ADDR_BEG,
-					&addr, 2);
-			memcpy(buf_frame + i * 512 + RPMB_WCOUNTER_BEG,
-					&w_counter, 4);
-			memcpy(buf_frame + i * 512 + RPMB_DATA_BEG,
-					data, 256);
-			data += 256;
-		}
-		/* convert MAC code */
-		memcpy(buf_frame + 512 * (i - 1) + RPMB_MAC_BEG,
-				p_req->mac, 32);
-	} else if (p_req->type == RPMB_PROGRAM_KEY) {
-		/*
-		 * One package prepared
-		 * This request only need mac
-		 */
-		memcpy(buf_frame + RPMB_TYPE_BEG, &type, 2);
-		/* convert MAC code */
-		memcpy(buf_frame + RPMB_MAC_BEG,
-				p_req->mac, 32);
-	} else {
-		pr_err("%s: We shouldn't be here\n", mmc_hostname(card->host));
-		kfree(buf_frame);
-		return -EINVAL;
-	}
-	rpmb_req->ready = 1;
-	rpmb_req->frame = buf_frame;
-	return 0;
-}
-EXPORT_SYMBOL_GPL(mmc_rpmb_pre_frame);
-
-int mmc_rpmb_partition_ops(struct mmc_core_rpmb_req *rpmb_req,
-		struct mmc_card *card)
-{
-	int err = 0;
-	struct mmc_ioc_rpmb_req *p_req;
-	__u16 type, blks;
-	__u8 *buf_frame;
-
-	if (!rpmb_req || !card)
-		return -EINVAL;
-
-	p_req = rpmb_req->req;
-	buf_frame = rpmb_req->frame;
-
-	if (!p_req || !rpmb_req->ready || !buf_frame) {
-		pr_err("%s: mmc_ioc_rpmb_req is not prepared\n",
-				mmc_hostname(card->host));
-		return -EINVAL;
-	}
-
-	type = p_req->type;
-	blks = p_req->blk_cnt;
-
-	/*
-	 * STEP 1: send request to RPMB partition
-	 */
-	if (type == RPMB_WRITE_DATA)
-		err = mmc_rpmb_send_command(card, buf_frame, blks,
-				type, RPMB_REQ);
-	else
-		err = mmc_rpmb_send_command(card, buf_frame, 1, type, RPMB_REQ);
-
-	if (err) {
-		pr_err("%s: request write counter failed (%d)\n",
-				mmc_hostname(card->host), err);
-		goto out;
-	}
-
-	memset(buf_frame, 0, 512 * blks);
-	/*
-	 * STEP 2: check write result
-	 * Only for WRITE_DATA or Program key
-	 */
-	if (type == RPMB_WRITE_DATA ||
-			type == RPMB_PROGRAM_KEY) {
-		buf_frame[RPMB_TYPE_BEG + 1] = RPMB_RESULT_READ;
-		err = mmc_rpmb_send_command(card, buf_frame, 1,
-				RPMB_RESULT_READ, RPMB_REQ);
-		if (err) {
-			pr_err("%s: request write counter failed (%d)\n",
-					mmc_hostname(card->host), err);
-			goto out;
-		}
-	}
-
-	/*
-	 * STEP 3: get response from RPMB partition
-	 */
-
-	if (type == RPMB_READ_DATA)
-		err = mmc_rpmb_send_command(card, buf_frame,
-				blks, type, RPMB_RESP);
-	else
-		err = mmc_rpmb_send_command(card, buf_frame,
-				1, type, RPMB_RESP);
-	if (err) {
-		pr_err("%s: response write counter failed (%d)\n",
-				mmc_hostname(card->host), err);
-	}
-out:
-	return err;
-}
-EXPORT_SYMBOL_GPL(mmc_rpmb_partition_ops);
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 1f7c796..8289777 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -2698,8 +2698,6 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 		 * The "data complete" interrupt is also used to
 		 * indicate that a busy state has ended. See comment
 		 * above in sdhci_cmd_irq().
-		 *
-		 * "data timeout" interrupt may also happen
 		 */
 		if (host->cmd && (host->cmd->flags & MMC_RSP_BUSY)) {
 			if (intmask & SDHCI_INT_DATA_END) {
@@ -2708,14 +2706,6 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 				else
 					host->r1b_busy_end = 1;
 				return;
-			} else if (intmask & SDHCI_INT_DATA_TIMEOUT) {
-				pr_err("%s: Got data interrupt 0x%08x for busy cmd %d\n",
-						mmc_hostname(host->mmc),
-						(unsigned)intmask,
-						host->cmd->opcode);
-				host->cmd->error = -ETIMEDOUT;
-				tasklet_schedule(&host->finish_tasklet);
-				return;
 			}
 		}
 
diff --git a/drivers/pci/pci-atom_soc.c b/drivers/pci/pci-atom_soc.c
index edc3e23..235e24a 100644
--- a/drivers/pci/pci-atom_soc.c
+++ b/drivers/pci/pci-atom_soc.c
@@ -69,6 +69,7 @@ static int __init mid_pci_init(void)
 	case INTEL_ATOM_MFLD:
 	case INTEL_ATOM_CLV:
 	case INTEL_ATOM_MRFLD:
+	case INTEL_ATOM_MOORFLD:
 		pci_set_platform_pm(&mid_pci_platform_pm);
 		break;
 	}
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 79277fb..d5e20d0 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -994,7 +994,6 @@ static int pci_pm_runtime_suspend(struct device *dev)
 	pci_dev->state_saved = false;
 	pci_dev->no_d3cold = false;
 	error = pm->runtime_suspend(dev);
-	suspend_report_result(pm->runtime_suspend, error);
 	if (error)
 		return error;
 	if (!pci_dev->d3cold_allowed)
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 83f6c6a..906e7e2 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -59,7 +59,11 @@ static void pci_dev_d3_sleep(struct pci_dev *dev)
 	if (delay < pci_pm_d3_delay)
 		delay = pci_pm_d3_delay;
 
-	msleep(delay);
+	if (delay) {
+		/* convert from ms to us */
+		delay = 1000*delay;
+		usleep_range(delay-10, delay+10);
+	}
 }
 
 #ifdef CONFIG_PCI_DOMAINS
@@ -675,7 +679,12 @@ static void __pci_start_power_transition(struct pci_dev *dev, pci_power_t state)
 		 * because have already delayed for the bridge.
 		 */
 		if (dev->runtime_d3cold) {
-			msleep(dev->d3cold_delay);
+			/*
+			 * msleep(0) will actually sleep for 1 jiffy.
+			 * if d3cold_delay is 0 we don't want to sleep at all.
+			*/
+			if (dev->d3cold_delay > 0)
+				msleep(dev->d3cold_delay);
 			/*
 			 * When powering on a bridge from D3cold, the
 			 * whole hierarchy may be powered on into
@@ -764,10 +773,6 @@ int pci_set_power_state(struct pci_dev *dev, pci_power_t state)
 		 */
 		return 0;
 
-	/* Check if we're already there */
-	if (dev->current_state == state)
-		return 0;
-
 	__pci_start_power_transition(dev, state);
 
 	/* This device is quirked not to be put into D3, so
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 02d48ec..25fd684 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -1067,6 +1067,12 @@ static void quirk_no_ata_d3(struct pci_dev *pdev)
 {
 	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
 }
+static void quirk_no_d3(struct pci_dev *pdev)
+{
+	dev_info(&pdev->dev, "Disabling D3");
+	pdev->dev_flags |= PCI_DEV_FLAGS_NO_D3;
+}
+
 /* Quirk the legacy ATA devices only. The AHCI ones are ok */
 DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_SERVERWORKS, PCI_ANY_ID,
 				PCI_CLASS_STORAGE_IDE, 8, quirk_no_ata_d3);
@@ -1080,6 +1086,8 @@ DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_AL, PCI_ANY_ID,
 DECLARE_PCI_FIXUP_CLASS_EARLY(PCI_VENDOR_ID_VIA, PCI_ANY_ID,
 				PCI_CLASS_STORAGE_IDE, 8, quirk_no_ata_d3);
 
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0F18, quirk_no_d3);
+
 /* This was originally an Alpha specific thing, but it really fits here.
  * The i82375 PCI/EISA bridge appears as non-classified. Fix that.
  */
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index d42f5ef..a1df080 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -812,21 +812,4 @@ config INTEL_SCU_FLIS
 	  We could read write the flis address and configure the
 	  pin pull up/down using these interfaces.
 
-config INTEL_PSH_IPC
-	bool "Intel PSH IPC Support"
-	depends on X86_INTEL_MID
-	---help---
-	  PSH(Platform Services Hub) is a low frequence IA core on Tangier Platform,
-	  whose power consumption is quite low. PSH runs RTOS software inside itself,
-	  which independently controls and collects sensor data, pre-processes the data,
-	  and communicates with Atom. Thus ATOM side could be put into low power mode
-	  with more time, while all the sensor data are collected without any lost.
-
-	  PSH IPC is used as a  bridge for OS sensor service to control and access PSH
-	  sensors communications between kernel and PSH. This is not needed for PC-type
-	  machines.
-
-	  Say Y here to get Intel PSH IPC support.
-
-
 endif # X86_PLATFORM_DEVICES
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 7d82ebf..c075bb2 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -53,5 +53,3 @@ obj-$(CONFIG_APPLE_GMUX)	+= apple-gmux.o
 obj-$(CONFIG_CHROMEOS_LAPTOP)	+= chromeos_laptop.o
 
 obj-$(CONFIG_PVPANIC)           += pvpanic.o
-
-obj-$(CONFIG_INTEL_PSH_IPC)     += intel_psh_ipc.o
diff --git a/drivers/pwm/pwm-intel-mid.c b/drivers/pwm/pwm-intel-mid.c
index 7897607..5564a1b 100644
--- a/drivers/pwm/pwm-intel-mid.c
+++ b/drivers/pwm/pwm-intel-mid.c
@@ -74,9 +74,15 @@ intel_mid_pwm_on_time_divisor(void __iomem *reg, union pwmctrl_reg *pwmctrl,
 	u64 on_time_divisor;
 
 	/* Calculate and set on time divisor */
-	on_time_divisor = duty_cycle * (u64)(PWM_COMPARE_UNIT_SIZE - 1UL);
-	do_div(on_time_divisor, period);
-	on_time_divisor = PWM_COMPARE_UNIT_SIZE - on_time_divisor - 1UL;
+	if (duty_cycle == period) {
+		on_time_divisor = 1UL;
+	} else {
+		on_time_divisor = duty_cycle *
+			(u64)(PWM_COMPARE_UNIT_SIZE - 1UL);
+		do_div(on_time_divisor, period);
+		on_time_divisor = PWM_COMPARE_UNIT_SIZE -
+			on_time_divisor - 1UL;
+	}
 
 	pwmctrl->full = readl(reg);
 	pwmctrl->part.on_time_divisor = on_time_divisor;
@@ -161,11 +167,6 @@ intel_mid_pwm_base_unit(void __iomem *reg, union pwmctrl_reg *pwmctrl,
 			fraction -= numerator;
 		}
 	}
-	/* If both the values are 0, the output will be somehow not correct.
-	 * So if it happens, change the fraction to 1.
-	 */
-	if ((0 == base_unit_fraction) && (0 == base_unit_integer))
-		base_unit_fraction = 1UL;
 
 	pwmctrl->full = readl(reg);
 	pwmctrl->part.base_unit_int = (u32)base_unit_integer;
diff --git a/drivers/remoteproc/intel_mid_rproc_scu.c b/drivers/remoteproc/intel_mid_rproc_scu.c
index 53a1cdc..fd5023b 100644
--- a/drivers/remoteproc/intel_mid_rproc_scu.c
+++ b/drivers/remoteproc/intel_mid_rproc_scu.c
@@ -257,7 +257,6 @@ static void intel_rproc_scu_kick(struct rproc *rproc, int vqid)
 	struct intel_mid_rproc *iproc;
 	struct rproc_vdev *rvdev;
 	struct device *dev = rproc->dev.parent;
-	static unsigned long ns_info_all_received;
 
 	iproc = (struct intel_mid_rproc *)rproc->priv;
 
@@ -269,21 +268,19 @@ static void intel_rproc_scu_kick(struct rproc *rproc, int vqid)
 
 	switch (idx) {
 	case RX_VRING:
-		if (iproc->ns_enabled && !ns_info_all_received) {
-			/* push messages with ns_info for ALL available
-			name services in the list (nslist) into
-			rx buffers. */
+		if (iproc->ns_enabled &&
+			!list_is_last(&iproc->ns_info->node, &nslist->list)) {
 			list_for_each_entry_continue(iproc->ns_info,
 				&nslist->list, node) {
 				ret = intel_mid_rproc_ns_handle(iproc,
-					iproc->ns_info);
+						iproc->ns_info);
 				if (ret) {
 					dev_err(dev, "ns handle error\n");
 					return;
 				}
+				break;
 			}
 
-			ns_info_all_received = 1;
 			intel_mid_rproc_vq_interrupt(rproc, vqid);
 		}
 		break;
diff --git a/drivers/spi/intel_mid_ssp_spi.c b/drivers/spi/intel_mid_ssp_spi.c
index f8e11ec..5964b3b 100644
--- a/drivers/spi/intel_mid_ssp_spi.c
+++ b/drivers/spi/intel_mid_ssp_spi.c
@@ -83,7 +83,8 @@ static void dump_trailer(const struct device *dev, char *buf, int len, int sz)
 static inline u8 ssp_cfg_get_mode(u8 ssp_cfg)
 {
 	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER ||
-	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE ||
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CARBONCANYON)
 		return (ssp_cfg) & 0x03;
 	else
 		return (ssp_cfg) & 0x07;
@@ -92,7 +93,8 @@ static inline u8 ssp_cfg_get_mode(u8 ssp_cfg)
 static inline u8 ssp_cfg_get_spi_bus_nb(u8 ssp_cfg)
 {
 	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER ||
-	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE ||
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CARBONCANYON)
 		return ((ssp_cfg) >> 2) & 0x07;
 	else
 		return ((ssp_cfg) >> 3) & 0x07;
@@ -101,7 +103,8 @@ static inline u8 ssp_cfg_get_spi_bus_nb(u8 ssp_cfg)
 static inline u8 ssp_cfg_is_spi_slave(u8 ssp_cfg)
 {
 	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER ||
-	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE ||
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CARBONCANYON)
 		return (ssp_cfg) & 0x20;
 	else
 		return (ssp_cfg) & 0x40;
@@ -747,10 +750,19 @@ static void int_transfer_complete_work(struct work_struct *work)
 
 static void poll_transfer_complete(struct ssp_drv_context *sspc)
 {
+	struct spi_message *msg;
+
 	/* Update total byte transfered return count actual bytes read */
 	sspc->cur_msg->actual_length += sspc->len - (sspc->rx_end - sspc->rx);
 
 	sspc->cur_msg->status = 0;
+	if (sspc->cs_control)
+		sspc->cs_control(CS_DEASSERT);
+
+	msg = sspc->cur_msg;
+	if (likely(msg->complete))
+		msg->complete(msg->context);
+	complete(&sspc->msg_done);
 }
 
 /**
@@ -793,9 +805,6 @@ static irqreturn_t ssp_int(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-/*
- * Perform a single transfer.
- */
 static void poll_transfer(unsigned long data)
 {
 	struct ssp_drv_context *sspc = (void *)data;
@@ -807,24 +816,25 @@ static void poll_transfer(unsigned long data)
 		delay = true;
 	}
 
-	while (sspc->tx < sspc->tx_end) {
-		/* [REVERT ME] Tangier simulator requires a delay */
-		if (delay)
-			udelay(10);
-		if (ssp_timing_wr) {
-			int timeout = 100;
-			/* It is used as debug UART on Tangier. Since
-			   baud rate = 115200, it needs at least 312us
-			   for one word transferring. Becuase of silicon
-			   issue, it MUST check SFIFOL here instead of
-			   TNF. It is the workaround for A0 stepping*/
-			while (--timeout &&
-					((read_SFIFOL(sspc->ioaddr)) & 0xFFFF))
+	if (sspc->tx)
+		while (sspc->tx != sspc->tx_end) {
+			/* [REVERT ME] Tangier simulator requires a delay */
+			if (delay)
 				udelay(10);
+			if (ssp_timing_wr) {
+				int timeout = 100;
+				/* It is used as debug UART on Tangier. Since
+				   baud rate = 115200, it needs at least 312us
+				   for one word transferring. Becuase of silicon
+				   issue, it MUST check SFIFOL here instead of
+				   TNF. It is the workaround for A0 stepping*/
+				while (--timeout &&
+					((read_SFIFOL(sspc->ioaddr)) & 0xFFFF))
+					udelay(10);
+			}
+			sspc->write(sspc);
+			sspc->read(sspc);
 		}
-		sspc->write(sspc);
-		sspc->read(sspc);
-	}
 
 	while (!sspc->read(sspc))
 		cpu_relax();
@@ -907,19 +917,9 @@ static void start_bitbanging(struct ssp_drv_context *sspc)
 static unsigned int ssp_get_clk_div(struct ssp_drv_context *sspc, int speed)
 {
 	if (sspc->quirks & QUIRKS_PLATFORM_MRFL)
-		/* The clock divider shall stay between 0 and 4095. */
-		return clamp(25000000 / speed - 1, 0, 4095);
-	else
-		return clamp(100000000 / speed - 1, 3, 4095);
-}
-
-
-static int ssp_get_speed(struct ssp_drv_context *sspc, int clk_div)
-{
-	if (sspc->quirks & QUIRKS_PLATFORM_MRFL)
-		return 25000000 / (clk_div + 1);
+		return max(25000000 / speed, 4) - 1;
 	else
-		return 100000000 / (clk_div + 1);
+		return max(100000000 / speed, 4) - 1;
 }
 
 /**
@@ -948,237 +948,133 @@ static int handle_message(struct ssp_drv_context *sspc)
 	struct chip_data *chip = NULL;
 	struct spi_transfer *transfer = NULL;
 	void *reg = sspc->ioaddr;
-	u32 cr0, saved_cr0, cr1, saved_cr1;
+	u32 cr1;
 	struct device *dev = &sspc->pdev->dev;
 	struct spi_message *msg = sspc->cur_msg;
-	u32 clk_div, saved_speed_hz;
-	u8 dma_enabled;
-	u32 timeout;
-	u8 chip_select;
-	u32 mask = 0;
-	int bits_per_word, saved_bits_per_word;
-	unsigned long flags;
+	u32 clk_div;
 
 	chip = spi_get_ctldata(msg->spi);
 
-	/* get every chip data we need to handle atomically the full message */
-	spin_lock_irqsave(&sspc->lock, flags);
-	saved_cr0 = chip->cr0;
-	saved_cr1 = chip->cr1;
-	saved_bits_per_word = msg->spi->bits_per_word;
-	saved_speed_hz = chip->speed_hz;
-	sspc->cs_control = chip->cs_control;
-	timeout = chip->timeout;
-	chip_select = chip->chip_select;
-	dma_enabled = chip->dma_enabled;
-	spin_unlock_irqrestore(&sspc->lock, flags);
+	/* We handle only one transfer message since the protocol module has to
+	   control the out of band signaling. */
+	transfer = list_entry(msg->transfers.next, struct spi_transfer,
+					transfer_list);
 
-	list_for_each_entry(transfer, &msg->transfers, transfer_list) {
+	/* Check transfer length */
+	if (unlikely((transfer->len > MAX_SPI_TRANSFER_SIZE) ||
+		(transfer->len == 0))) {
+		dev_warn(dev, "transfer length null or greater than %d\n",
+			MAX_SPI_TRANSFER_SIZE);
+		dev_warn(dev, "length = %d\n", transfer->len);
+		msg->status = -EINVAL;
 
-		/* Check transfer length */
-		if (unlikely((transfer->len > MAX_SPI_TRANSFER_SIZE) ||
-					(transfer->len == 0))) {
-			dev_warn(dev, "transfer length null or greater than %d\n",
-					MAX_SPI_TRANSFER_SIZE);
-			dev_warn(dev, "length = %d\n", transfer->len);
-			msg->status = -EINVAL;
+		if (msg->complete)
+			msg->complete(msg->context);
+		complete(&sspc->msg_done);
+		return 0;
+	}
 
-			if (msg->complete)
-				msg->complete(msg->context);
-			complete(&sspc->msg_done);
-			return 0;
-		}
+	/* Flush any remaining data (in case of failed previous transfer) */
+	flush(sspc);
 
-		/* If the bits_per_word field in non-zero in the spi_transfer provided
-		 * by the user-space, consider this value. Otherwise consider the
-		 * default bits_per_word field from the spi setting. */
-		if (transfer->bits_per_word) {
-			bits_per_word = transfer->bits_per_word;
-			cr0 = saved_cr0;
-			cr0 &= ~(SSCR0_EDSS | SSCR0_DSS);
-			cr0 |= SSCR0_DataSize(bits_per_word > 16 ?
-					bits_per_word - 16 : bits_per_word)
-				| (bits_per_word > 16 ? SSCR0_EDSS : 0);
-		} else {
-			/* Use default value. */
-			bits_per_word = saved_bits_per_word;
-			cr0 = saved_cr0;
-		}
+	sspc->tx  = (void *)transfer->tx_buf;
+	sspc->rx  = (void *)transfer->rx_buf;
+	sspc->len = transfer->len;
+	sspc->write = chip->write;
+	sspc->read = chip->read;
+	sspc->cs_control = chip->cs_control;
+	sspc->cs_change = transfer->cs_change;
 
-		if ((bits_per_word < MIN_BITS_PER_WORD
-					|| bits_per_word > MAX_BITS_PER_WORD)) {
-			dev_warn(dev, "invalid wordsize\n");
-			msg->status = -EINVAL;
-			if (msg->complete)
-				msg->complete(msg->context);
-			complete(&sspc->msg_done);
+	if (likely(chip->dma_enabled)) {
+		sspc->dma_mapped = map_dma_buffers(sspc);
+		if (unlikely(!sspc->dma_mapped))
 			return 0;
-		}
+	} else {
+		sspc->write = sspc->tx ? chip->write : null_writer;
+		sspc->read  = sspc->rx ? chip->read : null_reader;
+	}
+	sspc->tx_end = sspc->tx + transfer->len;
+	sspc->rx_end = sspc->rx + transfer->len;
+
+	/* [REVERT ME] Bug in status register clear for Tangier simulation */
+	if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) ||
+	    (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE) ||
+	    (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CARBONCANYON)) {
+		if ((intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_VP &&
+		    (intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_HVP)))
+			write_SSSR(sspc->clear_sr, reg);
+	} else /* Clear status  */
+		write_SSSR(sspc->clear_sr, reg);
 
-		/* Check message length and bit per words consistency */
-		if (bits_per_word <= 8)
-			mask = 0;
-		else if (bits_per_word <= 16)
-			mask = 1;
-		else if (bits_per_word <= 32)
-			mask = 3;
-
-		if (transfer->len & mask) {
-			dev_warn(dev,
-					"message rejected : data length %d not multiple of %d "
-					"while in %d bits mode\n",
-					transfer->len,
-					mask + 1,
-					(mask == 1) ? 16 : 32);
-			msg->status = -EINVAL;
-			if (msg->complete)
-				msg->complete(msg->context);
-			complete(&sspc->msg_done);
-			return 0;
-		}
+	/* setup the CR1 control register */
+	cr1 = chip->cr1 | sspc->cr1_sig;
 
-		/* Flush any remaining data (in case of failed previous transfer) */
-		flush(sspc);
-
-		dev_dbg(dev, "%d bits/word, mode %d\n",
-				bits_per_word, msg->spi->mode & 0x3);
-		if (bits_per_word <= 8) {
-			sspc->n_bytes = 1;
-			sspc->read = u8_reader;
-			sspc->write = u8_writer;
-		} else if (bits_per_word <= 16) {
-			sspc->n_bytes = 2;
-			sspc->read = u16_reader;
-			sspc->write = u16_writer;
-		} else if (bits_per_word <= 32) {
-			if (!ssp_timing_wr)
-				cr0 |= SSCR0_EDSS;
-			sspc->n_bytes = 4;
-			sspc->read = u32_reader;
-			sspc->write = u32_writer;
-		}
-		sspc->tx  = (void *)transfer->tx_buf;
-		sspc->rx  = (void *)transfer->rx_buf;
-		sspc->len = transfer->len;
-		sspc->cs_change = transfer->cs_change;
-
-		if (likely(dma_enabled)) {
-			sspc->dma_mapped = map_dma_buffers(sspc);
-			if (unlikely(!sspc->dma_mapped))
-				return 0;
-		}
-		sspc->tx  = (void *)transfer->tx_buf;
-		sspc->rx  = (void *)transfer->rx_buf;
-		sspc->len = transfer->len;
-		sspc->cs_control = chip->cs_control;
-		sspc->cs_change = transfer->cs_change;
-
-		if (likely(chip->dma_enabled)) {
-			sspc->dma_mapped = map_dma_buffers(sspc);
-			if (unlikely(!sspc->dma_mapped))
-				return 0;
-		} else {
-			sspc->write = sspc->tx ? sspc->write : null_writer;
-			sspc->read  = sspc->rx ? sspc->read : null_reader;
-		}
-		sspc->tx_end = sspc->tx + transfer->len;
-		sspc->rx_end = sspc->rx + transfer->len;
-
-		/* [REVERT ME] Bug in status register clear for Tangier simulation */
-		if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) ||
-				(intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)) {
-			if ((intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_VP &&
-						(intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_HVP)))
-				write_SSSR(sspc->clear_sr, reg);
-		} else /* Clear status  */
-			write_SSSR(sspc->clear_sr, reg);
+	if (likely(sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)) {
+		/* in case of len smaller than burst size, adjust the RX     */
+		/* threshold. All other cases will use the default threshold */
+		/* value. The RX fifo threshold must be aligned with the DMA */
+		/* RX transfer size, which may be limited to a multiple of 4 */
+		/* bytes due to 32bits DDR access.                           */
+		if  (sspc->len / sspc->n_bytes <= sspc->rx_fifo_threshold) {
+			u32 rx_fifo_threshold;
+
+			rx_fifo_threshold = (sspc->len & ~(4 - 1)) /
+						sspc->n_bytes;
+			cr1 &= ~(SSCR1_RFT);
+			cr1 |= SSCR1_RxTresh(rx_fifo_threshold) & SSCR1_RFT;
+		} else
+			write_SSTO(chip->timeout, reg);
+	}
 
-		/* setup the CR1 control register */
-		cr1 = saved_cr1 | sspc->cr1_sig;
-
-		if (likely(sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)) {
-			/* in case of len smaller than burst size, adjust the RX     */
-			/* threshold. All other cases will use the default threshold */
-			/* value. The RX fifo threshold must be aligned with the DMA */
-			/* RX transfer size, which may be limited to a multiple of 4 */
-			/* bytes due to 32bits DDR access.                           */
-			if  (sspc->len / sspc->n_bytes <= sspc->rx_fifo_threshold) {
-				u32 rx_fifo_threshold;
-
-				rx_fifo_threshold = (sspc->len & ~(4 - 1)) /
-					sspc->n_bytes;
-				cr1 &= ~(SSCR1_RFT);
-				cr1 |= SSCR1_RxTresh(rx_fifo_threshold) & SSCR1_RFT;
-			} else
-				write_SSTO(timeout, reg);
-		}
-		dev_dbg(dev, "transfer len:%d  n_bytes:%d  cr0:%x  cr1:%x",
-				sspc->len, sspc->n_bytes, cr0, cr1);
+	dev_dbg(dev, "transfer len:%d  n_bytes:%d  cr0:%x  cr1:%x",
+		sspc->len, sspc->n_bytes, chip->cr0, cr1);
 
-		/* first set CR1 */
+	/* first set CR1 */
+	if (intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_SLE)
 		write_SSCR1(cr1, reg);
 
-		if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER)
-			write_SSFS((1 << chip_select), reg);
-
-		/* recalculate the frequency for each transfer */
-		if (transfer->speed_hz)
-			clk_div = ssp_get_clk_div(sspc, transfer->speed_hz);
-		else
-			clk_div = ssp_get_clk_div(sspc, saved_speed_hz);
+	if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) ||
+		(intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE))
+		write_SSFS((1 << chip->chip_select), reg);
 
-		cr0 &= ~SSCR0_SCR;
-		cr0 |= (clk_div & 0xFFF) << 8;
+	/* recalculate the frequency for each transfer */
+	clk_div = ssp_get_clk_div(sspc, transfer->speed_hz);
+	chip->cr0 |= clk_div << 8;
 
-		/* Do bitbanging only if SSP not-enabled or not-synchronized */
-		if (unlikely(((read_SSSR(reg) & SSP_NOT_SYNC) ||
-						(!(read_SSCR0(reg) & SSCR0_SSE))) &&
-					(sspc->quirks & QUIRKS_BIT_BANGING))) {
+	/* Do bitbanging only if SSP not-enabled or not-synchronized */
+	if (unlikely(((read_SSSR(reg) & SSP_NOT_SYNC) ||
+		(!(read_SSCR0(reg) & SSCR0_SSE))) &&
+		(sspc->quirks & QUIRKS_BIT_BANGING))) {
 			start_bitbanging(sspc);
-		} else {
-			/* (re)start the SSP */
+	} else {
+		/* (re)start the SSP */
+		if (intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_SLE) {
 			if (ssp_timing_wr) {
 				dev_dbg(dev, "original cr0 before reset:%x",
-						cr0);
+					chip->cr0);
 				/*we should not disable TUM and RIM interrup*/
 				write_SSCR0(0x0000000F, reg);
-				cr0 &= ~(SSCR0_SSE);
-				dev_dbg(dev, "reset ssp:cr0:%x", cr0);
-				write_SSCR0(cr0, reg);
-				cr0 |= SSCR0_SSE;
-				dev_dbg(dev, "reset ssp:cr0:%x", cr0);
-				write_SSCR0(cr0, reg);
+				chip->cr0 &= ~(SSCR0_SSE);
+				dev_dbg(dev, "reset ssp:cr0:%x", chip->cr0);
+				write_SSCR0(chip->cr0, reg);
+				chip->cr0 |= SSCR0_SSE;
+				dev_dbg(dev, "reset ssp:cr0:%x", chip->cr0);
+				write_SSCR0(chip->cr0, reg);
 			} else
-				write_SSCR0(cr0, reg);
-		}
-
-		if (sspc->cs_control)
-			sspc->cs_control(CS_ASSERT);
-
-		if (likely(dma_enabled)) {
-			if (unlikely(sspc->quirks & QUIRKS_USE_PM_QOS))
-				pm_qos_update_request(&sspc->pm_qos_req,
-						MIN_EXIT_LATENCY);
-			dma_transfer(sspc);
-		} else {
-			/* Do the transfer syncronously */
-			poll_transfer((unsigned long)sspc);
-		}
-
-		if (list_is_last(&transfer->transfer_list, &msg->transfers)
-				|| sspc->cs_change) {
-			if (sspc->cs_control)
-				sspc->cs_control(CS_DEASSERT);
+				write_SSCR0(chip->cr0, reg);
 		}
+	}
 
-	} /* end of list_for_each_entry */
+	if (sspc->cs_control)
+		sspc->cs_control(CS_ASSERT);
 
-	/* Now we are done with this entire message */
-	if (!dma_enabled) {
-		if (likely(msg->complete))
-			msg->complete(msg->context);
-		complete(&sspc->msg_done);
-	}
+	if (likely(chip->dma_enabled)) {
+		if (unlikely(sspc->quirks & QUIRKS_USE_PM_QOS))
+			pm_qos_update_request(&sspc->pm_qos_req,
+				MIN_EXIT_LATENCY);
+		dma_transfer(sspc);
+	} else
+		tasklet_schedule(&sspc->poll_transfer);
 
 	return 0;
 }
@@ -1224,25 +1120,20 @@ static int setup(struct spi_device *spi)
 	u32 burst_size;
 	u32 clk_div;
 	static u32 one_time_setup = 1;
-	unsigned long flags;
 
-	spin_lock_irqsave(&sspc->lock, flags);
 	if (!spi->bits_per_word)
 		spi->bits_per_word = DFLT_BITS_PER_WORD;
 
 	if ((spi->bits_per_word < MIN_BITS_PER_WORD
-		|| spi->bits_per_word > MAX_BITS_PER_WORD)) {
-		spin_unlock_irqrestore(&sspc->lock, flags);
+		|| spi->bits_per_word > MAX_BITS_PER_WORD))
 		return -EINVAL;
-	}
 
 	chip = spi_get_ctldata(spi);
 	if (!chip) {
-		chip = kzalloc(sizeof(struct chip_data), GFP_ATOMIC);
+		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
 		if (!chip) {
 			dev_err(&spi->dev,
 			"failed setup: can't allocate chip data\n");
-			spin_unlock_irqrestore(&sspc->lock, flags);
 			return -ENOMEM;
 		}
 	}
@@ -1273,7 +1164,7 @@ static int setup(struct spi_device *spi)
 		/* Request platform-specific gpio and pinmux here since
 		 * it is not possible to get the intel_mid_ssp_spi_chip
 		 * structure in probe */
-		if (one_time_setup && !chip_info->dma_enabled
+		if (one_time_setup
 				&& chip_info->platform_pinmux) {
 			chip_info->platform_pinmux();
 			one_time_setup = 0;
@@ -1285,7 +1176,7 @@ static int setup(struct spi_device *spi)
 		dev_info(&spi->dev, "setting default chip values\n");
 
 		burst_size = DFLT_FIFO_BURST_SIZE;
-		chip->dma_enabled = 0;
+		chip->dma_enabled = 1;
 		if (sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)
 			chip->timeout = 0;
 		else
@@ -1301,7 +1192,7 @@ static int setup(struct spi_device *spi)
 	/*FIXME:this is workaround.
 	On MRST, in DMA mode, it is very strang that RX fifo can't reach
 	burst size.*/
-	if (sspc->quirks & QUIRKS_PLATFORM_MRFL && chip->dma_enabled)
+	if ((sspc->quirks & QUIRKS_PLATFORM_MRST) && chip->dma_enabled)
 		sspc->rx_fifo_threshold = 1;
 	tx_fifo_threshold = SPI_FIFO_SIZE - sspc->rx_fifo_threshold;
 	chip->cr1 |= (SSCR1_RxTresh(sspc->rx_fifo_threshold) &
@@ -1320,23 +1211,31 @@ static int setup(struct spi_device *spi)
 		chip->cr1 |= SSCR1_SCLKDIR | SSCR1_SFRMDIR;
 	chip->cr1 |= SSCR1_SCFR;        /* clock is not free running */
 
+	dev_dbg(&spi->dev, "%d bits/word, mode %d\n",
+		spi->bits_per_word, spi->mode & 0x3);
 	if (spi->bits_per_word <= 8) {
 		chip->n_bytes = 1;
+		chip->read = null_reader;
+		chip->write = u8_writer;
 	} else if (spi->bits_per_word <= 16) {
 		chip->n_bytes = 2;
+		chip->read = u16_reader;
+		chip->write = u16_writer;
 	} else if (spi->bits_per_word <= 32) {
+		if (!ssp_timing_wr)
+			chip->cr0 |= SSCR0_EDSS;
 		chip->n_bytes = 4;
+		chip->read = u32_reader;
+		chip->write = u32_writer;
 	} else {
 		dev_err(&spi->dev, "invalid wordsize\n");
-		spin_unlock_irqrestore(&sspc->lock, flags);
 		return -EINVAL;
 	}
 
 	if ((sspc->quirks & QUIRKS_SPI_SLAVE_CLOCK_MODE) == 0) {
-		clk_div = ssp_get_clk_div(sspc, spi->max_speed_hz);
-		chip->cr0 |= (clk_div & 0xFFF) << 8;
-		spi->max_speed_hz = ssp_get_speed(sspc, clk_div);
 		chip->speed_hz = spi->max_speed_hz;
+		clk_div = ssp_get_clk_div(sspc, chip->speed_hz);
+		chip->cr0 |= clk_div << 8;
 		dev_dbg(&spi->dev, "spi->max_speed_hz:%d clk_div:%x cr0:%x",
 			spi->max_speed_hz, clk_div, chip->cr0);
 	}
@@ -1346,9 +1245,9 @@ static int setup(struct spi_device *spi)
 	spi_set_ctldata(spi, chip);
 
 	/* setup of sspc members that will not change across transfers */
+	sspc->n_bytes = chip->n_bytes;
 
 	if (chip->dma_enabled) {
-		sspc->n_bytes = chip->n_bytes;
 		intel_mid_ssp_spi_dma_init(sspc);
 		sspc->cr1_sig = SSCR1_TSRE | SSCR1_RSRE;
 		sspc->mask_sr = SSSR_ROR | SSSR_TUR;
@@ -1360,7 +1259,6 @@ static int setup(struct spi_device *spi)
 	}
 	sspc->clear_sr = SSSR_TUR | SSSR_ROR | SSSR_TINT;
 
-	spin_unlock_irqrestore(&sspc->lock, flags);
 	return 0;
 }
 
@@ -1422,6 +1320,21 @@ static int intel_mid_ssp_spi_probe(struct pci_dev *pdev,
 		goto err_abort_probe;
 	}
 
+	/*
+	* KKSANAG
+	* Remove registering SSP6(pci:0000:00:07.2)
+	* or it will cause tons of unprovoked interrupts
+	* This issue will be fixed in RTL. Then no need of this
+	* fix
+	*/
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CARBONCANYON) {
+		dev_info(dev, "The devfn (%0xh)\n", pdev->devfn);
+		if (0x2 == (pdev->devfn & 0x03)) {
+			dev_info(dev, "The SSP6 needs to be disabled, causing spurious interrupts\n");
+			goto err_abort_probe;
+		}
+	}
+
 	dev_info(dev, "found PCI SSP controller (ID: %04xh:%04xh cfg: %02xh)\n",
 		pdev->vendor, pdev->device, ssp_cfg);
 
@@ -1505,7 +1418,8 @@ static int intel_mid_ssp_spi_probe(struct pci_dev *pdev,
 	status = request_irq(sspc->irq, ssp_int, IRQF_SHARED,
 		"intel_mid_ssp_spi", sspc);
 
-	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+	if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) ||
+		(intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)) {
 		if ((intel_mid_identify_sim() ==
 				INTEL_MID_CPU_SIMULATION_SLE) ||
 		    (intel_mid_identify_sim() ==
@@ -1515,7 +1429,8 @@ static int intel_mid_ssp_spi_probe(struct pci_dev *pdev,
 			 * also required in Si. */
 			disable_irq_nosync(sspc->irq);
 		}
-		if (intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_NONE)
+		if ((intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_NONE) ||
+		    (intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_SLE))
 			ssp_timing_wr = 1;
 	}
 
@@ -1538,6 +1453,7 @@ static int intel_mid_ssp_spi_probe(struct pci_dev *pdev,
 	INIT_LIST_HEAD(&sspc->queue);
 	init_completion(&sspc->msg_done);
 	spin_lock_init(&sspc->lock);
+	tasklet_init(&sspc->poll_transfer, poll_transfer, (unsigned long)sspc);
 	INIT_WORK(&sspc->pump_messages, pump_messages);
 	sspc->workqueue = create_singlethread_workqueue(dev_name(&pdev->dev));
 
diff --git a/drivers/tty/serial/pch_uart.c b/drivers/tty/serial/pch_uart.c
index 2c5a3e4..20e4c94 100644
--- a/drivers/tty/serial/pch_uart.c
+++ b/drivers/tty/serial/pch_uart.c
@@ -232,7 +232,7 @@ struct eg20t_port {
 	unsigned int iobase;
 	struct pci_dev *pdev;
 	int fifo_size;
-	unsigned int uartclk;
+	int uartclk;
 	int start_tx;
 	int start_rx;
 	int tx_empty;
@@ -373,62 +373,35 @@ static const struct file_operations port_regs_ops = {
 };
 #endif	/* CONFIG_DEBUG_FS */
 
-static struct dmi_system_id pch_uart_dmi_table[] = {
-	{
-		.ident = "CM-iTC",
-		{
-			DMI_MATCH(DMI_BOARD_NAME, "CM-iTC"),
-		},
-		(void *)CMITC_UARTCLK,
-	},
-	{
-		.ident = "FRI2",
-		{
-			DMI_MATCH(DMI_BIOS_VERSION, "FRI2"),
-		},
-		(void *)FRI2_64_UARTCLK,
-	},
-	{
-		.ident = "Fish River Island II",
-		{
-			DMI_MATCH(DMI_PRODUCT_NAME, "Fish River Island II"),
-		},
-		(void *)FRI2_48_UARTCLK,
-	},
-	{
-		.ident = "COMe-mTT",
-		{
-			DMI_MATCH(DMI_BOARD_NAME, "COMe-mTT"),
-		},
-		(void *)NTC1_UARTCLK,
-	},
-	{
-		.ident = "nanoETXexpress-TT",
-		{
-			DMI_MATCH(DMI_BOARD_NAME, "nanoETXexpress-TT"),
-		},
-		(void *)NTC1_UARTCLK,
-	},
-	{
-		.ident = "MinnowBoard",
-		{
-			DMI_MATCH(DMI_BOARD_NAME, "MinnowBoard"),
-		},
-		(void *)MINNOW_UARTCLK,
-	},
-};
-
 /* Return UART clock, checking for board specific clocks. */
-static unsigned int pch_uart_get_uartclk(void)
+static int pch_uart_get_uartclk(void)
 {
-	const struct dmi_system_id *d;
+	const char *cmp;
 
 	if (user_uartclk)
 		return user_uartclk;
 
-	d = dmi_first_match(pch_uart_dmi_table);
-	if (d)
-		return (unsigned long)d->driver_data;
+	cmp = dmi_get_system_info(DMI_BOARD_NAME);
+	if (cmp && strstr(cmp, "CM-iTC"))
+		return CMITC_UARTCLK;
+
+	cmp = dmi_get_system_info(DMI_BIOS_VERSION);
+	if (cmp && strnstr(cmp, "FRI2", 4))
+		return FRI2_64_UARTCLK;
+
+	cmp = dmi_get_system_info(DMI_PRODUCT_NAME);
+	if (cmp && strstr(cmp, "Fish River Island II"))
+		return FRI2_48_UARTCLK;
+
+	/* Kontron COMe-mTT10 (nanoETXexpress-TT) */
+	cmp = dmi_get_system_info(DMI_BOARD_NAME);
+	if (cmp && (strstr(cmp, "COMe-mTT") ||
+		    strstr(cmp, "nanoETXexpress-TT")))
+		return NTC1_UARTCLK;
+
+	cmp = dmi_get_system_info(DMI_BOARD_NAME);
+	if (cmp && strstr(cmp, "MinnowBoard"))
+		return MINNOW_UARTCLK;
 
 	return DEFAULT_UARTCLK;
 }
@@ -449,7 +422,7 @@ static void pch_uart_hal_disable_interrupt(struct eg20t_port *priv,
 	iowrite8(ier, priv->membase + UART_IER);
 }
 
-static int pch_uart_hal_set_line(struct eg20t_port *priv, unsigned int baud,
+static int pch_uart_hal_set_line(struct eg20t_port *priv, int baud,
 				 unsigned int parity, unsigned int bits,
 				 unsigned int stb)
 {
@@ -484,7 +457,7 @@ static int pch_uart_hal_set_line(struct eg20t_port *priv, unsigned int baud,
 	lcr |= bits;
 	lcr |= stb;
 
-	dev_dbg(priv->port.dev, "%s:baud = %u, div = %04x, lcr = %02x (%lu)\n",
+	dev_dbg(priv->port.dev, "%s:baud = %d, div = %04x, lcr = %02x (%lu)\n",
 		 __func__, baud, div, lcr, jiffies);
 	iowrite8(PCH_UART_LCR_DLAB, priv->membase + UART_LCR);
 	iowrite8(dll, priv->membase + PCH_UART_DLL);
@@ -1393,8 +1366,9 @@ static void pch_uart_shutdown(struct uart_port *port)
 static void pch_uart_set_termios(struct uart_port *port,
 				 struct ktermios *termios, struct ktermios *old)
 {
+	int baud;
 	int rtn;
-	unsigned int baud, parity, bits, stb;
+	unsigned int parity, bits, stb;
 	struct eg20t_port *priv;
 	unsigned long flags;
 
@@ -1527,7 +1501,6 @@ static int pch_uart_verify_port(struct uart_port *port,
 	return 0;
 }
 
-#if defined(CONFIG_CONSOLE_POLL) || defined(CONFIG_SERIAL_PCH_UART_CONSOLE)
 /*
  *	Wait for transmitter & holding register to empty
  */
@@ -1558,7 +1531,6 @@ static void wait_for_xmitr(struct eg20t_port *up, int bits)
 		}
 	}
 }
-#endif /* CONFIG_CONSOLE_POLL || CONFIG_SERIAL_PCH_UART_CONSOLE */
 
 #ifdef CONFIG_CONSOLE_POLL
 /*
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index b3e1f19..4c338ec 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -359,9 +359,6 @@ EXPORT_SYMBOL_GPL(usb_amd_dev_put);
  */
 void uhci_reset_hc(struct pci_dev *pdev, unsigned long base)
 {
-#ifdef CONFIG_MIPS_MALTA
-	int timeout = 10;
-#endif
 	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
 	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
 	 */
@@ -375,16 +372,9 @@ void uhci_reset_hc(struct pci_dev *pdev, unsigned long base)
 	outw(UHCI_USBCMD_HCRESET, base + UHCI_USBCMD);
 	mb();
 	udelay(5);
+	if (inw(base + UHCI_USBCMD) & UHCI_USBCMD_HCRESET)
+		dev_warn(&pdev->dev, "HCRESET not completed yet!\n");
 
-#ifdef CONFIG_MIPS_MALTA
-	while (inw(base + UHCI_USBCMD) & UHCI_USBCMD_HCRESET) {
-	        if (--timeout < 0) {
-			dev_warn(&pdev->dev, "HCRESET timed out!\n");
-			break;
-		}
-		udelay(5);
-	}
-#endif
 	/* Just to be safe, disable interrupt requests and
 	 * make sure the controller is stopped.
 	 */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 6c55d88..da6f56d 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -71,9 +71,7 @@ static void uhci_fsbr_off(struct uhci_hcd *uhci)
 static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct urb_priv *urbp = urb->hcpriv;
-#ifdef CONFIG_MIPS_MALTA
-       return;
-#endif
+
 	if (!(urb->transfer_flags & URB_NO_FSBR))
 		urbp->fsbr = 1;
 }
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 04de933..4a5251f 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -317,9 +317,6 @@ static void xhci_cleanup_msix(struct xhci_hcd *xhci)
 
 	xhci_free_irq(xhci);
 
-	if (xhci->quirks & XHCI_PLAT)
-		return;
-
 	if (xhci->msix_entries) {
 		pci_disable_msix(pdev);
 		kfree(xhci->msix_entries);
diff --git a/fs/Kconfig b/fs/Kconfig
index 056db61..c229f82 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -193,7 +193,6 @@ source "fs/hfsplus/Kconfig"
 source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
-source "fs/yaffs2/Kconfig"
 source "fs/jffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
@@ -213,7 +212,6 @@ source "fs/ufs/Kconfig"
 source "fs/exofs/Kconfig"
 source "fs/f2fs/Kconfig"
 source "fs/efivarfs/Kconfig"
-source "fs/aufs/Kconfig"
 
 endif # MISC_FILESYSTEMS
 
diff --git a/fs/Makefile b/fs/Makefile
index 04e97df..4fe6df3 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -126,5 +126,3 @@ obj-y				+= exofs/ # Multiple modules
 obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
 obj-$(CONFIG_EFIVAR_FS)		+= efivarfs/
-obj-$(CONFIG_AUFS_FS)           += aufs/
-obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff --git a/fs/buffer.c b/fs/buffer.c
index 7e0240f..d2a4d1b 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2388,8 +2388,6 @@ int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 	 * fault so this update may be superfluous but who really cares...
 	 */
 	file_update_time(vma->vm_file);
-	if (vma->vm_prfile)
-		file_update_time(vma->vm_prfile);
 
 	ret = __block_page_mkwrite(vma, vmf, get_block);
 	sb_end_pagefault(sb);
diff --git a/fs/fat/Kconfig b/fs/fat/Kconfig
index 6bd12c0..182f9ff 100644
--- a/fs/fat/Kconfig
+++ b/fs/fat/Kconfig
@@ -74,27 +74,6 @@ config VFAT_FS
 	  To compile this as a module, choose M here: the module will be called
 	  vfat.
 
-config VFAT_FS_NO_DUALNAMES
-	bool "disable VFAT dual names support (patent workaround)"
-	depends on VFAT_FS
-	help
-	  This option disables support for dual filenames on VFAT filesystems.
-	  If this option is enabled then file creation will either put
-	  a short (8.3) name or a long name on the file, but never both.
-	  The field where a shortname would normally go is filled with
-	  invalid characters such that it cannot be considered a valid
-	  short filename.
-
-	  That means that long filenames created with this option
-	  disabled will not be accessible at all to operating systems
-	  that do not understand the FAT long filename extensions.
-
-	  Users considering disabling this option should consider the
-	  implications of any patents that may exist on dual filenames
-	  in VFAT.
-
-	  If unsure, say N
-
 config FAT_DEFAULT_CODEPAGE
 	int "Default codepage for FAT"
 	depends on MSDOS_FS || VFAT_FS
@@ -119,14 +98,3 @@ config FAT_DEFAULT_IOCHARSET
 
 	  Enable any character sets you need in File Systems/Native Language
 	  Support.
-
-config VFAT_NO_CREATE_WITH_LONGNAMES
-	bool "Disable creating files with long names"
-	depends on VFAT_FS
-	default n
-	help
-	  Set this to disable support for creating files or directories with
-	  names longer than 8.3 (the original DOS maximum file name length)
-	  e.g. naming a file FILE1234.TXT would be allowed but creating or
-	  renaming a file to FILE12345.TXT or FILE1234.TEXT would not
-	  be permitted.  Reading files with long file names is still permitted.
diff --git a/fs/fat/dir.c b/fs/fat/dir.c
index 9c94efd3..7a6f02c 100644
--- a/fs/fat/dir.c
+++ b/fs/fat/dir.c
@@ -372,8 +372,7 @@ static int fat_parse_short(struct super_block *sb,
 		dotoffset = 1;
 	}
 
-	memcpy(work, de->name, sizeof(de->name));
-
+	memcpy(work, de->name, sizeof(work));
 	/* see namei.c, msdos_format_name */
 	if (work[0] == 0x05)
 		work[0] = 0xE5;
@@ -503,13 +502,6 @@ parse_record:
 				goto end_of_dir;
 		}
 
-		/*
-		 * The FAT_NO_83NAME flag is used to mark files
-		 * created with no 8.3 short name
-		 */
-		if (de->lcase & FAT_NO_83NAME)
-			goto compare_longname;
-
 		/* Never prepend '.' to hidden files here.
 		 * That is done only for msdos mounts (and only when
 		 * 'dotsOK=yes'); if we are executing here, it is in the
@@ -523,7 +515,6 @@ parse_record:
 		if (fat_name_match(sbi, name, name_len, bufname, len))
 			goto found;
 
-compare_longname:
 		if (nr_slots) {
 			void *longname = unicode + FAT_MAX_UNI_CHARS;
 			int size = PATH_MAX - FAT_MAX_UNI_SIZE;
@@ -620,8 +611,6 @@ parse_record:
 		if (de->attr != ATTR_EXT && IS_FREE(de->name))
 			goto record_end;
 	} else {
-		if (de->lcase & FAT_NO_83NAME)
-			goto record_end;
 		if ((de->attr & ATTR_VOLUME) || IS_FREE(de->name))
 			goto record_end;
 	}
@@ -964,10 +953,6 @@ int fat_scan(struct inode *dir, const unsigned char *name,
 	sinfo->bh = NULL;
 	while (fat_get_short_entry(dir, &sinfo->slot_off, &sinfo->bh,
 				   &sinfo->de) >= 0) {
-		/* skip files marked as having no 8.3 short name  */
-		if (sinfo->de->lcase & FAT_NO_83NAME)
-			continue;
-
 		if (!strncmp(sinfo->de->name, name, MSDOS_NAME)) {
 			sinfo->slot_off -= sizeof(*sinfo->de);
 			sinfo->nr_slots = 1;
diff --git a/fs/fat/namei_vfat.c b/fs/fat/namei_vfat.c
index 0c26e0a..2da9520 100644
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -21,7 +21,6 @@
 #include <linux/slab.h>
 #include <linux/buffer_head.h>
 #include <linux/namei.h>
-#include <linux/random.h>
 #include "fat.h"
 
 /*
@@ -329,17 +328,6 @@ static int vfat_create_shortname(struct inode *dir, struct nls_table *nls,
 	int sz = 0, extlen, baselen, i, numtail_baselen, numtail2_baselen;
 	int is_shortname;
 	struct shortname_info base_info, ext_info;
-	unsigned opts_shortname = opts->shortname;
-
-#ifdef CONFIG_VFAT_FS_NO_DUALNAMES
-	/*
-	 * When we do not have dualnames, we want to maximise the
-	 * chance that a file will be able to be represented with just
-	 * a 8.3 entry. We can do that by using the WINNT case
-	 * handling extensions to FAT.
-	 */
-	opts_shortname = VFAT_SFN_CREATE_WINNT;
-#endif
 
 	is_shortname = 1;
 	INIT_SHORTNAME_INFO(&base_info);
@@ -448,22 +436,13 @@ static int vfat_create_shortname(struct inode *dir, struct nls_table *nls,
 	memcpy(name_res, base, baselen);
 	memcpy(name_res + 8, ext, extlen);
 	*lcase = 0;
-
-#ifdef CONFIG_VFAT_NO_CREATE_WITH_LONGNAMES
-	if (is_shortname == 0)
-		return -ENAMETOOLONG;
-	if (!base_info.valid || !ext_info.valid)
-		return -EINVAL;
-	opts_shortname = VFAT_SFN_CREATE_WINNT;
-#endif
-
 	if (is_shortname && base_info.valid && ext_info.valid) {
 		if (vfat_find_form(dir, name_res) == 0)
 			return -EEXIST;
 
-		if (opts_shortname & VFAT_SFN_CREATE_WIN95) {
+		if (opts->shortname & VFAT_SFN_CREATE_WIN95) {
 			return (base_info.upper && ext_info.upper);
-		} else if (opts_shortname & VFAT_SFN_CREATE_WINNT) {
+		} else if (opts->shortname & VFAT_SFN_CREATE_WINNT) {
 			if ((base_info.upper || base_info.lower) &&
 			    (ext_info.upper || ext_info.lower)) {
 				if (!base_info.upper && base_info.lower)
@@ -602,66 +581,6 @@ xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,
 	return 0;
 }
 
-#ifdef CONFIG_VFAT_FS_NO_DUALNAMES
-/*
- * This function creates a dummy 8.3 entry which is as compatible as
- * possible with existing FAT devices, while not being a valid
- * filename under windows or Linux
- */
-static void vfat_build_dummy_83_buffer(struct inode *dir, char *msdos_name,
-				       int is_dir)
-{
-	/*
-	 * These characters are all invalid in 8.3 names, plus have
-	 * been shown to be harmless on all tested devices
-	 */
-	const char invalidchar[] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x0B,
-				     0x0C, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,
-				     0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,
-				     0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x22, 0x2a,
-				     0x3a, 0x3c, 0x3e, 0x3f, 0x5b, 0x5d, 0x7c };
-	int i, tilde_pos, slash_pos;
-	u32 rand_num = random32();
-
-	/* We need a '~' in the prefix to make Win98 happy. */
-	tilde_pos = rand_num % 8;
-	rand_num >>= 3;
-
-	/*
-	 * the '/' makes sure that even unpatched Linux systems can't
-	 * get at files by the 8.3 entry. Don't put in a / in
-	 * directories as it can cause problems with some
-	 * photo frames
-	 */
-	if (is_dir)
-		slash_pos = -1;
-	else {
-		slash_pos = (tilde_pos + 1 + rand_num % 7) % 8;
-		rand_num >>= 3;
-	}
-
-	/*
-	 * fill in the first 8 bytes with invalid characters. Note
-	 * that we need to be careful not to run out of randomness. We
-	 * leave the 3 byte extension in place as some cheap MP3
-	 * players need them.
-	 */
-	for (i = 0; i < 8; i++) {
-		if (i == tilde_pos)
-			msdos_name[i] = '~';
-		else if (i == slash_pos)
-			msdos_name[i] = '/';
-		else {
-			msdos_name[i] =
-				invalidchar[rand_num % sizeof(invalidchar)];
-			rand_num /= sizeof(invalidchar);
-			if (rand_num < sizeof(invalidchar))
-				rand_num = random32();
-		}
-	}
-}
-#endif
-
 static int vfat_build_slots(struct inode *dir, const unsigned char *name,
 			    int len, int is_dir, int cluster,
 			    struct timespec *ts,
@@ -669,19 +588,15 @@ static int vfat_build_slots(struct inode *dir, const unsigned char *name,
 {
 	struct msdos_sb_info *sbi = MSDOS_SB(dir->i_sb);
 	struct fat_mount_options *opts = &sbi->options;
+	struct msdos_dir_slot *ps;
 	struct msdos_dir_entry *de;
-	unsigned char lcase;
+	unsigned char cksum, lcase;
 	unsigned char msdos_name[MSDOS_NAME];
 	wchar_t *uname;
 	__le16 time, date;
 	u8 time_cs;
-	int err, ulen, usize;
-#ifndef CONFIG_VFAT_NO_CREATE_WITH_LONGNAMES
-	int i;
-	struct msdos_dir_slot *ps;
-	unsigned char cksum;
+	int err, ulen, usize, i;
 	loff_t offset;
-#endif
 
 	*nr_slots = 0;
 
@@ -708,16 +623,6 @@ static int vfat_build_slots(struct inode *dir, const unsigned char *name,
 		goto shortname;
 	}
 
-#ifdef CONFIG_VFAT_FS_NO_DUALNAMES
-	printk_once(KERN_INFO
-		    "VFAT: not creating 8.3 short filenames for long names\n");
-	vfat_build_dummy_83_buffer(dir, msdos_name, is_dir);
-	lcase = FAT_NO_83NAME;
-#endif
-
-#ifdef CONFIG_VFAT_NO_CREATE_WITH_LONGNAMES
-	de = (struct msdos_dir_entry *)slots;
-#else
 	/* build the entry of long file name */
 	cksum = fat_checksum(msdos_name);
 
@@ -735,7 +640,6 @@ static int vfat_build_slots(struct inode *dir, const unsigned char *name,
 	}
 	slots[0].id |= 0x40;
 	de = (struct msdos_dir_entry *)ps;
-#endif
 
 shortname:
 	/* build the entry of 8.3 alias name */
@@ -1164,11 +1068,7 @@ static struct dentry *vfat_mount(struct file_system_type *fs_type,
 
 static struct file_system_type vfat_fs_type = {
 	.owner		= THIS_MODULE,
-#ifdef CONFIG_VFAT_NO_CREATE_WITH_LONGNAMES
-	.name		= "lfat",
-#else
 	.name		= "vfat",
-#endif
 	.mount		= vfat_mount,
 	.kill_sb	= kill_block_super,
 	.fs_flags	= FS_REQUIRES_DEV,
@@ -1188,9 +1088,6 @@ static void __exit exit_vfat_fs(void)
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("VFAT filesystem support");
 MODULE_AUTHOR("Gordon Chaffee");
-#ifdef CONFIG_VFAT_NO_CREATE_WITH_LONGNAMES
-MODULE_ALIAS("lfat");
-#endif
 
 module_init(init_vfat_fs)
 module_exit(exit_vfat_fs)
diff --git a/fs/file_table.c b/fs/file_table.c
index e271e28..485dc0e 100644
--- a/fs/file_table.c
+++ b/fs/file_table.c
@@ -36,8 +36,7 @@ struct files_stat_struct files_stat = {
 	.max_files = NR_FILE
 };
 
-DEFINE_LGLOCK(files_lglock);
-EXPORT_SYMBOL(files_lglock);
+DEFINE_STATIC_LGLOCK(files_lglock);
 
 /* SLAB cache for file structures */
 static struct kmem_cache *filp_cachep __read_mostly;
@@ -406,8 +405,6 @@ void file_sb_list_del(struct file *file)
 	}
 }
 
-EXPORT_SYMBOL(file_sb_list_del);
-
 #ifdef CONFIG_SMP
 
 /*
diff --git a/fs/inode.c b/fs/inode.c
index bff7670..00d5fc3 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -56,7 +56,6 @@ static struct hlist_head *inode_hashtable __read_mostly;
 static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);
 
 __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);
-EXPORT_SYMBOL(inode_sb_list_lock);
 
 /*
  * Empty aops. Can be used for the cases where the user does not
@@ -1499,7 +1498,7 @@ static int relatime_need_update(struct vfsmount *mnt, struct inode *inode,
  * This does the actual work of updating an inodes time or version.  Must have
  * had called mnt_want_write() before calling this.
  */
-int update_time(struct inode *inode, struct timespec *time, int flags)
+static int update_time(struct inode *inode, struct timespec *time, int flags)
 {
 	if (inode->i_op->update_time)
 		return inode->i_op->update_time(inode, time, flags);
@@ -1515,7 +1514,6 @@ int update_time(struct inode *inode, struct timespec *time, int flags)
 	mark_inode_dirty_sync(inode);
 	return 0;
 }
-EXPORT_SYMBOL(update_time);
 
 /**
  *	touch_atime	-	update the access time
diff --git a/fs/namespace.c b/fs/namespace.c
index f32874b..a45ba4f 100644
--- a/fs/namespace.c
+++ b/fs/namespace.c
@@ -54,7 +54,6 @@ EXPORT_SYMBOL_GPL(fs_kobj);
  * tree or hash is modified or when a vfsmount structure is modified.
  */
 DEFINE_BRLOCK(vfsmount_lock);
-EXPORT_SYMBOL(vfsmount_lock);
 
 static inline unsigned long hash(struct vfsmount *mnt, struct dentry *dentry)
 {
@@ -428,7 +427,6 @@ void __mnt_drop_write(struct vfsmount *mnt)
 	mnt_dec_writers(real_mount(mnt));
 	preempt_enable();
 }
-EXPORT_SYMBOL_GPL(__mnt_drop_write);
 
 /**
  * mnt_drop_write - give up write access to a mount
@@ -1458,7 +1456,6 @@ int iterate_mounts(int (*f)(struct vfsmount *, void *), void *arg,
 	}
 	return 0;
 }
-EXPORT_SYMBOL(iterate_mounts);
 
 static void cleanup_group_ids(struct mount *mnt, struct mount *end)
 {
diff --git a/fs/nfs/Kconfig b/fs/nfs/Kconfig
index 169e5ab..13ca196 100644
--- a/fs/nfs/Kconfig
+++ b/fs/nfs/Kconfig
@@ -39,19 +39,6 @@ config NFS_V2
 
 	  If unsure, say Y.
 
-config NFS_DEF_FILE_IO_SIZE
-	int "Default size for NFS I/O read and write at runtime"
-	depends on NFS_FS
-	default "4096"
-	help
-	  To change the default rsize and wsize supported by the NFS client,
-	  adjust NFS_DEF_FILE_IO_SIZE.  64KB is a typical maximum, but some
-	  servers can support a megabyte or more.  The default is left at 4096
-	  bytes, which is reasonable for NFS over UDP, however, for some
-	  systems, setting a smaller value like 1024 can work around
-	  limitations in the driver or hardware and result in overall
-	  improved performance.
-
 config NFS_V3
 	tristate "NFS client support for NFS version 3"
 	depends on NFS_FS
diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index 818697c..c513b0c 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -9,6 +9,7 @@
  * 2 of the License, or (at your option) any later version.
  */
 
+
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/sched.h>
@@ -69,7 +70,7 @@ static const struct rpc_version *nfs_version[5] = {
 	[4] = NULL,
 };
 
-struct rpc_program nfs_program = {
+const struct rpc_program nfs_program = {
 	.name			= "nfs",
 	.number			= NFS_PROGRAM,
 	.nrvers			= ARRAY_SIZE(nfs_version),
@@ -160,7 +161,6 @@ struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *cl_init)
 	try_module_get(clp->cl_nfs_mod->owner);
 
 	clp->rpc_ops = clp->cl_nfs_mod->rpc_ops;
-	clp->nfs_prog = cl_init->nfs_prog;
 
 	atomic_set(&clp->cl_count, 1);
 	clp->cl_cons_state = NFS_CS_INITING;
@@ -418,9 +418,6 @@ static struct nfs_client *nfs_match_client(const struct nfs_client_initdata *dat
 		/* Match nfsv4 minorversion */
 		if (clp->cl_minorversion != data->minorversion)
 			continue;
-		if (clp->nfs_prog != data->nfs_prog)
-			continue;
-
 		/* Match the full socket address */
 		if (!nfs_sockaddr_cmp(sap, clap))
 			continue;
@@ -602,10 +599,6 @@ int nfs_create_rpc_client(struct nfs_client *clp,
 	if (!IS_ERR(clp->cl_rpcclient))
 		return 0;
 
-	if (clp->nfs_prog)
-		nfs_program.number = clp->nfs_prog;
-	else
-		nfs_program.number = NFS_PROGRAM;
 	clnt = rpc_create(&args);
 	if (IS_ERR(clnt)) {
 		dprintk("%s: cannot create RPC client. Error = %ld\n",
@@ -749,7 +742,6 @@ static int nfs_init_server(struct nfs_server *server,
 		.nfs_mod = nfs_mod,
 		.proto = data->nfs_server.protocol,
 		.net = data->net,
-		.nfs_prog = data->nfs_prog,
 	};
 	struct rpc_timeout timeparms;
 	struct nfs_client *clp;
diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 13a36e2..91e59a3 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -73,7 +73,6 @@ struct nfs_client_initdata {
 	int proto;
 	u32 minorversion;
 	struct net *net;
-	int nfs_prog;
 };
 
 /*
@@ -85,8 +84,6 @@ struct nfs_parsed_mount_data {
 	unsigned int		timeo, retrans;
 	unsigned int		acregmin, acregmax,
 				acdirmin, acdirmax;
-	int			nfs_prog;
-	int			mount_prog;
 	unsigned int		namlen;
 	unsigned int		options;
 	unsigned int		bsize;
@@ -143,11 +140,11 @@ struct nfs_mount_info {
 	struct nfs_fh *mntfh;
 };
 
-extern int nfs_mount(struct nfs_mount_request *info, int prog);
+extern int nfs_mount(struct nfs_mount_request *info);
 extern void nfs_umount(const struct nfs_mount_request *info);
 
 /* client.c */
-extern struct rpc_program nfs_program;
+extern const struct rpc_program nfs_program;
 extern void nfs_clients_init(struct net *net);
 extern struct nfs_client *nfs_alloc_client(const struct nfs_client_initdata *);
 int nfs_create_rpc_client(struct nfs_client *, const struct rpc_timeout *, rpc_authflavor_t);
diff --git a/fs/nfs/mount_clnt.c b/fs/nfs/mount_clnt.c
index 09eeebc..91a6faf 100644
--- a/fs/nfs/mount_clnt.c
+++ b/fs/nfs/mount_clnt.c
@@ -67,7 +67,7 @@ enum {
 	MOUNTPROC3_EXPORT	= 5,
 };
 
-static struct rpc_program mnt_program;
+static const struct rpc_program mnt_program;
 
 /*
  * Defined by OpenGroup XNFS Version 3W, chapter 8
@@ -141,7 +141,7 @@ struct mnt_fhstatus {
  *
  * Uses default timeout parameters specified by underlying transport.
  */
-int nfs_mount(struct nfs_mount_request *info, int m_prog)
+int nfs_mount(struct nfs_mount_request *info)
 {
 	struct mountres	result = {
 		.fh		= info->fh,
@@ -175,7 +175,6 @@ int nfs_mount(struct nfs_mount_request *info, int m_prog)
 	if (info->noresvport)
 		args.flags |= RPC_CLNT_CREATE_NONPRIVPORT;
 
-	mnt_program.number = m_prog;
 	mnt_clnt = rpc_create(&args);
 	if (IS_ERR(mnt_clnt))
 		goto out_clnt_err;
@@ -515,7 +514,7 @@ static const struct rpc_version *mnt_version[] = {
 
 static struct rpc_stat mnt_stats;
 
-static struct rpc_program mnt_program = {
+static const struct rpc_program mnt_program = {
 	.name		= "mount",
 	.number		= NFS_MNT_PROGRAM,
 	.nrvers		= ARRAY_SIZE(mnt_version),
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index 5712e3b..2d7525f 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -103,8 +103,6 @@ enum {
 	Opt_mountport,
 	Opt_mountvers,
 	Opt_minorversion,
-	Opt_mountprog,
-	Opt_nfsprog,
 
 	/* Mount options that take string arguments */
 	Opt_nfsvers,
@@ -170,8 +168,6 @@ static const match_table_t nfs_mount_option_tokens = {
 	{ Opt_mountport, "mountport=%s" },
 	{ Opt_mountvers, "mountvers=%s" },
 	{ Opt_minorversion, "minorversion=%s" },
-	{ Opt_mountprog, "mountprog=%s" },
-	{ Opt_nfsprog, "nfsprog=%s" },
 
 	{ Opt_nfsvers, "nfsvers=%s" },
 	{ Opt_nfsvers, "vers=%s" },
@@ -921,8 +917,6 @@ static struct nfs_parsed_mount_data *nfs_alloc_parsed_mount_data(void)
 		data->acregmax		= NFS_DEF_ACREGMAX;
 		data->acdirmin		= NFS_DEF_ACDIRMIN;
 		data->acdirmax		= NFS_DEF_ACDIRMAX;
-		data->nfs_prog		= NFS_PROGRAM;
-		data->mount_prog	= NFS_MNT_PROGRAM;
 		data->mount_server.port	= NFS_UNSPEC_PORT;
 		data->nfs_server.port	= NFS_UNSPEC_PORT;
 		data->nfs_server.protocol = XPRT_TRANSPORT_TCP;
@@ -1322,26 +1316,6 @@ static int nfs_parse_mount_options(char *raw,
 				goto out_invalid_value;
 			mnt->acdirmax = option;
 			break;
-		case Opt_mountprog:
-			string = match_strdup(args);
-			if (string == NULL)
-				goto out_nomem;
-			rc = strict_strtoul(string, 10, &option);
-			kfree(string);
-			if (rc != 0)
-				goto out_invalid_value;
-			mnt->mount_prog = option;
-			break;
-		case Opt_nfsprog:
-			string = match_strdup(args);
-			if (string == NULL)
-				goto out_nomem;
-			rc = strict_strtoul(string, 10, &option);
-			kfree(string);
-			if (rc != 0)
-			       goto out_invalid_value;
-			mnt->nfs_prog = option;
-			break;
 		case Opt_actimeo:
 			if (nfs_get_option_ul(args, &option))
 				goto out_invalid_value;
@@ -1775,7 +1749,7 @@ static int nfs_request_mount(struct nfs_parsed_mount_data *args,
 	 * Now ask the mount server to map our export path
 	 * to a file handle.
 	 */
-	status = nfs_mount(&request,args->mount_prog);
+	status = nfs_mount(&request);
 	if (status != 0) {
 		dfprintk(MOUNT, "NFS: unable to mount server %s, error %d\n",
 				request.hostname, status);
@@ -1902,7 +1876,6 @@ static int nfs23_validate_mount_data(void *options,
 {
 	struct nfs_mount_data *data = (struct nfs_mount_data *)options;
 	struct sockaddr *sap = (struct sockaddr *)&args->nfs_server.address;
-	args->nfs_prog		= NFS_PROGRAM;
 
 	if (data == NULL)
 		goto out_no_data;
@@ -1923,8 +1896,6 @@ static int nfs23_validate_mount_data(void *options,
 			goto out_no_sec;
 	case 5:
 		memset(data->context, 0, sizeof(data->context));
-	case 7:
-		args->nfs_prog = (data->version >= 7) ? data->nfs_prog : NFS_PROGRAM;
 	case 6:
 		if (data->flags & NFS_MOUNT_VER3) {
 			if (data->root.size > NFS3_FHSIZE || data->root.size == 0)
@@ -2654,8 +2625,6 @@ static int nfs4_validate_mount_data(void *options,
 
 	args->version = 4;
 
-	args->nfs_prog = NFS_PROGRAM;
-
 	switch (data->version) {
 	case 1:
 		if (data->host_addrlen > sizeof(args->nfs_server.address))
diff --git a/fs/notify/group.c b/fs/notify/group.c
index 2ff2a0f..bd2625b 100644
--- a/fs/notify/group.c
+++ b/fs/notify/group.c
@@ -22,7 +22,6 @@
 #include <linux/srcu.h>
 #include <linux/rculist.h>
 #include <linux/wait.h>
-#include <linux/module.h>
 
 #include <linux/fsnotify_backend.h>
 #include "fsnotify.h"
@@ -66,7 +65,6 @@ void fsnotify_get_group(struct fsnotify_group *group)
 {
 	atomic_inc(&group->refcnt);
 }
-EXPORT_SYMBOL(fsnotify_get_group);
 
 /*
  * Drop a reference to a group.  Free it if it's through.
@@ -76,7 +74,6 @@ void fsnotify_put_group(struct fsnotify_group *group)
 	if (atomic_dec_and_test(&group->refcnt))
 		fsnotify_final_destroy_group(group);
 }
-EXPORT_SYMBOL(fsnotify_put_group);
 
 /*
  * Create a new fsnotify_group and hold a reference for the group returned.
@@ -105,7 +102,6 @@ struct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *ops)
 
 	return group;
 }
-EXPORT_SYMBOL(fsnotify_alloc_group);
 
 int fsnotify_fasync(int fd, struct file *file, int on)
 {
diff --git a/fs/notify/mark.c b/fs/notify/mark.c
index a6bb87d..fc6b49b 100644
--- a/fs/notify/mark.c
+++ b/fs/notify/mark.c
@@ -115,7 +115,6 @@ void fsnotify_put_mark(struct fsnotify_mark *mark)
 		mark->free_mark(mark);
 	}
 }
-EXPORT_SYMBOL(fsnotify_put_mark);
 
 /*
  * Any time a mark is getting freed we end up here.
@@ -198,7 +197,6 @@ void fsnotify_destroy_mark(struct fsnotify_mark *mark,
 	fsnotify_destroy_mark_locked(mark, group);
 	mutex_unlock(&group->mark_mutex);
 }
-EXPORT_SYMBOL(fsnotify_destroy_mark);
 
 void fsnotify_set_mark_mask_locked(struct fsnotify_mark *mark, __u32 mask)
 {
@@ -283,7 +281,6 @@ err:
 
 	return ret;
 }
-EXPORT_SYMBOL(fsnotify_add_mark);
 
 int fsnotify_add_mark(struct fsnotify_mark *mark, struct fsnotify_group *group,
 		      struct inode *inode, struct vfsmount *mnt, int allow_dups)
@@ -345,7 +342,6 @@ void fsnotify_init_mark(struct fsnotify_mark *mark,
 	atomic_set(&mark->refcnt, 1);
 	mark->free_mark = free_mark;
 }
-EXPORT_SYMBOL(fsnotify_init_mark);
 
 static int fsnotify_mark_destroy(void *ignored)
 {
diff --git a/fs/open.c b/fs/open.c
index be563cd..8c74100 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -61,7 +61,6 @@ int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
 	mutex_unlock(&dentry->d_inode->i_mutex);
 	return ret;
 }
-EXPORT_SYMBOL(do_truncate);
 
 long vfs_truncate(struct path *path, loff_t length)
 {
diff --git a/fs/proc/nommu.c b/fs/proc/nommu.c
index c09e2cf..ccfd99b 100644
--- a/fs/proc/nommu.c
+++ b/fs/proc/nommu.c
@@ -46,10 +46,6 @@ static int nommu_region_show(struct seq_file *m, struct vm_region *region)
 
 	if (file) {
 		struct inode *inode = file_inode(region->vm_file);
-		if (region->vm_prfile) {
-			file = region->vm_prfile;
-			inode = file_inode(file);
-		}
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 	}
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 6cef36f..65fc60a 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -272,10 +272,6 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
-		if (vma->vm_prfile) {
-			file = vma->vm_prfile;
-			inode = file_inode(file);
-		}
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
@@ -1289,8 +1285,6 @@ static int show_numa_map(struct seq_file *m, void *v, int is_pid)
 
 	if (file) {
 		seq_printf(m, " file=");
-		if (vma->vm_prfile)
-			file = vma->vm_prfile;
 		seq_path(m, &file->f_path, "\n\t= ");
 	} else if (vma->vm_start <= mm->brk && vma->vm_end >= mm->start_brk) {
 		seq_printf(m, " heap");
diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c
index b987a88..56123a6 100644
--- a/fs/proc/task_nommu.c
+++ b/fs/proc/task_nommu.c
@@ -150,10 +150,6 @@ static int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,
 
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
-		if (vma->vm_prfile) {
-			file = vma->vm_prfile;
-			inode = file_inode(file);
-		}
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;
diff --git a/fs/splice.c b/fs/splice.c
index 8d6a045..d37431d 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -1093,8 +1093,8 @@ EXPORT_SYMBOL(generic_splice_sendpage);
 /*
  * Attempt to initiate a splice from pipe to file.
  */
-long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
-		    loff_t *ppos, size_t len, unsigned int flags)
+static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			   loff_t *ppos, size_t len, unsigned int flags)
 {
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *,
 				loff_t *, size_t, unsigned int);
@@ -1120,14 +1120,13 @@ long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
 	file_end_write(out);
 	return ret;
 }
-EXPORT_SYMBOL(do_splice_from);
 
 /*
  * Attempt to initiate a splice from a file to a pipe.
  */
-long do_splice_to(struct file *in, loff_t *ppos,
-		  struct pipe_inode_info *pipe, size_t len,
-		  unsigned int flags)
+static long do_splice_to(struct file *in, loff_t *ppos,
+			 struct pipe_inode_info *pipe, size_t len,
+			 unsigned int flags)
 {
 	ssize_t (*splice_read)(struct file *, loff_t *,
 			       struct pipe_inode_info *, size_t, unsigned int);
@@ -1147,7 +1146,6 @@ long do_splice_to(struct file *in, loff_t *ppos,
 
 	return splice_read(in, ppos, pipe, len, flags);
 }
-EXPORT_SYMBOL(do_splice_to);
 
 /**
  * splice_direct_to_actor - splices data directly between two non-pipes
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 0148214..65c2be2 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -2574,7 +2574,6 @@ extern int inode_change_ok(const struct inode *, struct iattr *);
 extern int inode_newsize_ok(const struct inode *, loff_t offset);
 extern void setattr_copy(struct inode *inode, const struct iattr *attr);
 
-extern int update_time(struct inode *, struct timespec *, int);
 extern int file_update_time(struct file *file);
 
 extern int generic_show_options(struct seq_file *m, struct dentry *root);
diff --git a/include/linux/intel_mid_dma.h b/include/linux/intel_mid_dma.h
index d7f2997..47edd7b 100644
--- a/include/linux/intel_mid_dma.h
+++ b/include/linux/intel_mid_dma.h
@@ -32,6 +32,9 @@
 #define SST_MAX_DMA_LEN		4095
 #define SST_MAX_DMA_LEN_MRFLD	131071 /* 2^17 - 1 */
 
+#define MRFL_INSTANCE_SPI3	3
+#define MRFL_INSTANCE_SPI5	5
+#define MRFL_INSTANCE_SPI6	6
 
 /*DMA mode configurations*/
 enum intel_mid_dma_mode {
diff --git a/include/linux/intel_mid_pm.h b/include/linux/intel_mid_pm.h
index 4dfaa81..a778159 100644
--- a/include/linux/intel_mid_pm.h
+++ b/include/linux/intel_mid_pm.h
@@ -32,6 +32,7 @@
 #define INTEL_ATOM_CLV 0x35
 #define INTEL_ATOM_MRFLD 0x4a
 #define INTEL_ATOM_BYT 0x37
+#define INTEL_ATOM_MOORFLD 0x5a
 
 static inline int platform_is(u8 model)
 {
diff --git a/include/linux/mfd/wm8994/pdata.h b/include/linux/mfd/wm8994/pdata.h
index 9e96ca7..68e7765 100644
--- a/include/linux/mfd/wm8994/pdata.h
+++ b/include/linux/mfd/wm8994/pdata.h
@@ -130,12 +130,6 @@ struct wm8958_micd_rate {
 	int rate;
 };
 
-struct wm8958_custom_config {
-	int format;
-	int rate;
-	int channels;
-};
-
 struct wm8994_pdata {
 	int gpio_base;
 
@@ -188,16 +182,6 @@ struct wm8994_pdata {
 	 */
 	int micdet_delay;
 
-	/* Delay between microphone detect completing and reporting on
-	 * insert (specified in ms)
-	 */
-	int mic_id_delay;
-
-	/* Keep MICBIAS2 high for micb_en_delay, during jack insertion
-	 * removal
-	 */
-	int micb_en_delay;
-
 	/* IRQ for microphone detection if brought out directly as a
 	 * signal.
 	 */
@@ -239,9 +223,6 @@ struct wm8994_pdata {
 	 * lines is mastered.
 	 */
 	int max_channels_clocked[WM8994_NUM_AIF];
-
-	/* custom config for overriding the hw params */
-	struct wm8958_custom_config *custom_cfg;
 };
 
 #endif
diff --git a/include/linux/mfd/wm8994/registers.h b/include/linux/mfd/wm8994/registers.h
index db8cef3..0535489 100644
--- a/include/linux/mfd/wm8994/registers.h
+++ b/include/linux/mfd/wm8994/registers.h
@@ -2668,10 +2668,6 @@
 /*
  * R772 (0x304) - AIF1ADC LRCLK
  */
-#define WM8958_AIF1_LRCLK_INV                   0x1000  /* AIF1_LRCLK_INV */
-#define WM8958_AIF1_LRCLK_INV_MASK              0x1000  /* AIF1_LRCLK_INV */
-#define WM8958_AIF1_LRCLK_INV_SHIFT                 12  /* AIF1_LRCLK_INV */
-#define WM8958_AIF1_LRCLK_INV_WIDTH                  1  /* AIF1_LRCLK_INV */
 #define WM8994_AIF1ADC_LRCLK_DIR                0x0800  /* AIF1ADC_LRCLK_DIR */
 #define WM8994_AIF1ADC_LRCLK_DIR_MASK           0x0800  /* AIF1ADC_LRCLK_DIR */
 #define WM8994_AIF1ADC_LRCLK_DIR_SHIFT              11  /* AIF1ADC_LRCLK_DIR */
@@ -2683,10 +2679,6 @@
 /*
  * R773 (0x305) - AIF1DAC LRCLK
  */
-#define WM8958_AIF1_LRCLK_INV                   0x1000  /* AIF1_LRCLK_INV */
-#define WM8958_AIF1_LRCLK_INV_MASK              0x1000  /* AIF1_LRCLK_INV */
-#define WM8958_AIF1_LRCLK_INV_SHIFT                 12  /* AIF1_LRCLK_INV */
-#define WM8958_AIF1_LRCLK_INV_WIDTH                  1  /* AIF1_LRCLK_INV */
 #define WM8994_AIF1DAC_LRCLK_DIR                0x0800  /* AIF1DAC_LRCLK_DIR */
 #define WM8994_AIF1DAC_LRCLK_DIR_MASK           0x0800  /* AIF1DAC_LRCLK_DIR */
 #define WM8994_AIF1DAC_LRCLK_DIR_SHIFT              11  /* AIF1DAC_LRCLK_DIR */
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index 0efe855..4a189ba 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -213,7 +213,6 @@ struct vm_region {
 	unsigned long	vm_top;		/* region allocated to here */
 	unsigned long	vm_pgoff;	/* the offset in vm_file corresponding to vm_start */
 	struct file	*vm_file;	/* the backing file or NULL */
-	struct file	*vm_prfile;	/* the virtual backing file or NULL */
 
 	int		vm_usage;	/* region usage count (access under nommu_region_sem) */
 	bool		vm_icache_flushed : 1; /* true if the icache has been flushed for
@@ -282,7 +281,6 @@ struct vm_area_struct {
 	unsigned long vm_pgoff;		/* Offset (within vm_file) in PAGE_SIZE
 					   units, *not* PAGE_CACHE_SIZE */
 	struct file * vm_file;		/* File we map to (can be NULL). */
-	struct file *vm_prfile;		/* shadow of vm_file */
 	void * vm_private_data;		/* was vm_pte (shared mem) */
 
 #ifndef CONFIG_MMU
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 4b0fe47..39e8279 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -84,7 +84,6 @@ struct mmc_ext_csd {
 	unsigned int		hpi_cmd;		/* cmd used as HPI */
 	bool			bkops;		/* background support bit */
 	bool			bkops_en;	/* background enable bit */
-	unsigned int		rpmb_size;		/* Units: half sector */
 	unsigned int            data_sector_size;       /* 512 bytes or 4KB */
 	unsigned int            data_tag_unit_size;     /* DATA TAG UNIT size */
 	unsigned int		boot_ro_lock;		/* ro lock support */
@@ -298,8 +297,6 @@ struct mmc_card {
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
 	unsigned int    nr_parts;
-
-	unsigned int		rpmb_max_req;
 };
 
 /*
@@ -528,7 +525,4 @@ extern void mmc_unregister_driver(struct mmc_driver *);
 extern void mmc_fixup_device(struct mmc_card *card,
 			     const struct mmc_fixup *table);
 
-extern int mmc_rpmb_req_handle(struct device *emmc,
-		struct mmc_ioc_rpmb_req *req);
-
 #endif /* LINUX_MMC_CARD_H */
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index a4ab8e1..3e3b95e 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -10,8 +10,6 @@
 
 #include <linux/interrupt.h>
 #include <linux/completion.h>
-#include <linux/device.h>
-#include <linux/mmc/ioctl.h>
 
 struct request;
 struct mmc_data;
@@ -138,34 +136,6 @@ struct mmc_request {
 	struct mmc_host		*host;
 };
 
-/*
- * RPMB frame structure for MMC core stack
- */
-struct mmc_core_rpmb_req {
-	struct mmc_ioc_rpmb_req *req;
-	__u8 *frame;
-	bool ready;
-};
-
-#define RPMB_PROGRAM_KEY       1       /* Program RPMB Authentication Key */
-#define RPMB_GET_WRITE_COUNTER 2       /* Read RPMB write counter */
-#define RPMB_WRITE_DATA		3	/* Write data to RPMB partition */
-#define RPMB_READ_DATA         4       /* Read data from RPMB partition */
-#define RPMB_RESULT_READ       5       /* Read result request */
-#define RPMB_REQ               1       /* RPMB request mark */
-#define RPMB_RESP              (1 << 1)/* RPMB response mark */
-#define RPMB_AVALIABLE_SECTORS 8       /* 4K page size */
-
-#define RPMB_TYPE_BEG          510
-#define RPMB_RES_BEG           508
-#define RPMB_BLKS_BEG          506
-#define RPMB_ADDR_BEG          504
-#define RPMB_WCOUNTER_BEG      500
-
-#define RPMB_NONCE_BEG         484
-#define RPMB_DATA_BEG          228
-#define RPMB_MAC_BEG           196
-
 struct mmc_card;
 struct mmc_async_req;
 
@@ -183,10 +153,6 @@ extern void mmc_start_bkops(struct mmc_card *card, bool from_exception);
 extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool);
 extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
 extern int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
-extern int mmc_rpmb_partition_ops(struct mmc_core_rpmb_req *,
-		struct mmc_card *);
-extern int mmc_rpmb_pre_frame(struct mmc_core_rpmb_req *, struct mmc_card *);
-extern void mmc_rpmb_post_frame(struct mmc_core_rpmb_req *);
 
 #define MMC_ERASE_ARG		0x00000000
 #define MMC_SECURE_ERASE_ARG	0x80000000
diff --git a/include/linux/nfs_fs_sb.h b/include/linux/nfs_fs_sb.h
index 64b267e..3b7fa2a 100644
--- a/include/linux/nfs_fs_sb.h
+++ b/include/linux/nfs_fs_sb.h
@@ -54,7 +54,6 @@ struct nfs_client {
 
 	u32			cl_minorversion;/* NFSv4 minorversion */
 	struct rpc_cred		*cl_machine_cred;
-	int			nfs_prog;
 
 #if IS_ENABLED(CONFIG_NFS_V4)
 	u64			cl_clientid;	/* constant */
@@ -76,9 +75,7 @@ struct nfs_client {
 	 * This is used to generate the mv0 callback address.
 	 */
 	char			cl_ipaddr[48];
-
 	u32			cl_cb_ident;	/* v4.0 callback identifier */
-
 	const struct nfs4_minor_version_ops *cl_mvops;
 
 	/* The sequence id to use for the next CREATE_SESSION */
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index f650702..104b62f 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -11,7 +11,7 @@
  * reasonable for NFS over UDP.
  */
 #define NFS_MAX_FILE_IO_SIZE	(1048576U)
-#define NFS_DEF_FILE_IO_SIZE	CONFIG_NFS_DEF_FILE_IO_SIZE
+#define NFS_DEF_FILE_IO_SIZE	(4096U)
 #define NFS_MIN_FILE_IO_SIZE	(1024U)
 
 struct nfs4_string {
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 6d11952..980325b 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2478,9 +2478,6 @@
 
 #define PCI_VENDOR_ID_ASMEDIA		0x1b21
 
-#define PCI_VENDOR_ID_CIRCUITCO		0x1cc8
-#define PCI_SUBSYSTEM_ID_CIRCUITCO_MINNOWBOARD	0x0001
-
 #define PCI_VENDOR_ID_TEKRAM		0x1de1
 #define PCI_DEVICE_ID_TEKRAM_DC290	0xdc29
 
@@ -2549,6 +2546,7 @@
 #define PCI_DEVICE_ID_INTEL_MFD_SDIO2	0x0822
 #define PCI_DEVICE_ID_INTEL_MFD_EMMC0	0x0823
 #define PCI_DEVICE_ID_INTEL_MFD_EMMC1	0x0824
+#define PCI_DEVICE_ID_INTEL_MFD_OTG	0x0829
 #define PCI_DEVICE_ID_INTEL_MRST_SD2	0x084F
 #define PCI_DEVICE_ID_INTEL_I960	0x0960
 #define PCI_DEVICE_ID_INTEL_CLV_SDIO0	0x08F9
@@ -2557,6 +2555,7 @@
 #define PCI_DEVICE_ID_INTEL_CLV_EMMC0	0x08E5
 #define PCI_DEVICE_ID_INTEL_CLV_EMMC1	0x08E6
 #define PCI_DEVICE_ID_INTEL_CLV_OTG	0xE006
+#define PCI_DEVICE_ID_INTEL_CLV_SPH	0x08F2
 #define PCI_DEVICE_ID_INTEL_MRFL_MMC	0x1190
 #define PCI_DEVICE_ID_INTEL_MRFL_DWC3_OTG	0x119E
 #define PCI_DEVICE_ID_INTEL_BYT_EMMC	0x0f14
@@ -2564,6 +2563,10 @@
 #define PCI_DEVICE_ID_INTEL_BYT_SD	0x0f16
 #define PCI_DEVICE_ID_INTEL_BYT_EMMC45	0x0f50
 #define PCI_DEVICE_ID_INTEL_BYT_OTG	0x0f37
+#define PCI_DEVICE_ID_INTEL_BYT_USH	0x0f35
+#define PCI_DEVICE_ID_INTEL_MOOR_EMMC	0x1490
+#define PCI_DEVICE_ID_INTEL_MOOR_SD	0x1491
+#define PCI_DEVICE_ID_INTEL_MOOR_SDIO	0x1492
 #define PCI_DEVICE_ID_INTEL_I960RM	0x0962
 #define PCI_DEVICE_ID_INTEL_CENTERTON_ILB	0x0c60
 #define PCI_DEVICE_ID_INTEL_8257X_SOL	0x1062
@@ -2875,7 +2878,15 @@
 #define PCI_DEVICE_ID_INTEL_IXP4XX	0x8500
 #define PCI_DEVICE_ID_INTEL_IXP2800	0x9004
 #define PCI_DEVICE_ID_INTEL_S21152BB	0xb152
+#define PCI_DEVICE_ID_INTEL_SST_CLV     0x08e7
 #define PCI_DEVICE_ID_INTEL_SST_MRFLD   0x119A
+#define PCI_DEVICE_ID_INTEL_SST_MOOR    0x1495
+#define PCI_DEVICE_ID_INTEL_AUDIO_DMAC0_MOOR	0x1496
+#define PCI_DEVICE_ID_INTEL_GP_DMAC2_MOOR	0x1497
+#define PCI_DEVICE_ID_INTEL_VIBRA_CLV   0x0905
+#define PCI_DEVICE_ID_INTEL_VIBRA_MRFLD 0x11a5
+#define PCI_DEVICE_ID_INTEL_VIBRA_MOOR 0x1498
+
 
 #define PCI_VENDOR_ID_SCALEMP		0x8686
 #define PCI_DEVICE_ID_SCALEMP_VSMP_CTL	0x1010
diff --git a/include/linux/splice.h b/include/linux/splice.h
index bfc6fb6..74575cb 100644
--- a/include/linux/splice.h
+++ b/include/linux/splice.h
@@ -92,10 +92,4 @@ extern void splice_shrink_spd(struct splice_pipe_desc *);
 extern void spd_release_page(struct splice_pipe_desc *, unsigned int);
 
 extern const struct pipe_buf_operations page_cache_pipe_buf_ops;
-
-extern long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
-			   loff_t *ppos, size_t len, unsigned int flags);
-extern long do_splice_to(struct file *in, loff_t *ppos,
-			 struct pipe_inode_info *pipe, size_t len,
-			 unsigned int flags);
 #endif
diff --git a/include/sound/compress_driver.h b/include/sound/compress_driver.h
index 9307359..9031a26 100644
--- a/include/sound/compress_driver.h
+++ b/include/sound/compress_driver.h
@@ -32,7 +32,6 @@
 #include <sound/pcm.h>
 
 struct snd_compr_ops;
-struct snd_pcm_substream;
 
 /**
  * struct snd_compr_runtime: runtime stream description
@@ -49,8 +48,6 @@ struct snd_pcm_substream;
  *	the ring buffer
  * @total_bytes_transferred: cumulative bytes transferred by offload DSP
  * @sleep: poll sleep
- * @wait: drain wait queue
- * @drain_wake: condition for drain wake
  */
 struct snd_compr_runtime {
 	snd_pcm_state_t state;
@@ -62,9 +59,6 @@ struct snd_compr_runtime {
 	u64 total_bytes_available;
 	u64 total_bytes_transferred;
 	wait_queue_head_t sleep;
-	wait_queue_head_t wait;
-	unsigned int drain_wake;
-	struct snd_pcm_substream *fe_substream;
 	void *private_data;
 };
 
@@ -163,7 +157,6 @@ int snd_compress_register(struct snd_compr *device);
 int snd_compress_deregister(struct snd_compr *device);
 int snd_compress_new(struct snd_card *card, int device,
 			int type, struct snd_compr *compr);
-int snd_compr_stop(struct snd_compr_stream *stream);
 
 /* dsp driver callback apis
  * For playback: driver should call snd_compress_fragment_elapsed() to let the
@@ -178,12 +171,4 @@ static inline void snd_compr_fragment_elapsed(struct snd_compr_stream *stream)
 	wake_up(&stream->runtime->sleep);
 }
 
-static inline void snd_compr_drain_notify(struct snd_compr_stream *stream)
-{
-	snd_BUG_ON(!stream);
-
-	stream->runtime->drain_wake = 1;
-	wake_up(&stream->runtime->wait);
-}
-
 #endif
diff --git a/include/sound/core.h b/include/sound/core.h
index 971a2ec..5bfe513 100644
--- a/include/sound/core.h
+++ b/include/sound/core.h
@@ -146,11 +146,6 @@ struct snd_card {
 	struct snd_mixer_oss *mixer_oss;
 	int mixer_oss_change_count;
 #endif
-
-#if IS_ENABLED(CONFIG_SND_EFFECTS_OFFLOAD)
-	struct snd_effect_ops *effect_ops;
-	struct mutex effect_lock;	/* effect lock */
-#endif
 };
 
 #ifdef CONFIG_PM
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 6f01136..b48792f 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -285,7 +285,6 @@ struct snd_pcm_runtime {
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
 	unsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
-	snd_pcm_sframes_t soc_delay;    /* extra delay; typically delay incurred in soc */
 	u64 hw_ptr_wrap;                /* offset for hw_ptr due to boundary wrap-around */
 
 	/* -- HW params -- */
diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index 41e9df9..ae9a227 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -231,8 +231,8 @@ struct snd_soc_dai {
 	struct snd_soc_dai_driver *driver;
 
 	/* DAI runtime info */
-	unsigned int capture_active;		/* cap streams is in use */
-	unsigned int playback_active;		/* pb streams is in use */
+	unsigned int capture_active:1;		/* stream is in use */
+	unsigned int playback_active:1;		/* stream is in use */
 	unsigned int symmetric_rates:1;
 	struct snd_pcm_runtime *runtime;
 	unsigned int active;
diff --git a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h
index f48d25c..385c632 100644
--- a/include/sound/soc-dapm.h
+++ b/include/sound/soc-dapm.h
@@ -422,8 +422,6 @@ void dapm_mark_io_dirty(struct snd_soc_dapm_context *dapm);
 int snd_soc_dapm_dai_get_connected_widgets(struct snd_soc_dai *dai, int stream,
 	struct snd_soc_dapm_widget_list **list);
 
-struct snd_soc_codec *snd_soc_dapm_kcontrol_codec(struct snd_kcontrol *kcontrol);
-
 /* dapm widget types */
 enum snd_soc_dapm_type {
 	snd_soc_dapm_input = 0,		/* input pin */
diff --git a/include/sound/soc-dpcm.h b/include/sound/soc-dpcm.h
index a2e15ca..04598f1 100644
--- a/include/sound/soc-dpcm.h
+++ b/include/sound/soc-dpcm.h
@@ -11,7 +11,6 @@
 #ifndef __LINUX_SND_SOC_DPCM_H
 #define __LINUX_SND_SOC_DPCM_H
 
-#include <linux/slab.h>
 #include <linux/list.h>
 #include <sound/pcm.h>
 
@@ -136,25 +135,4 @@ int soc_dpcm_be_digital_mute(struct snd_soc_pcm_runtime *fe, int mute);
 int soc_dpcm_debugfs_add(struct snd_soc_pcm_runtime *rtd);
 int soc_dpcm_runtime_update(struct snd_soc_dapm_widget *);
 
-int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
-	int stream, struct snd_soc_dapm_widget_list **list_);
-int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,
-	int stream, struct snd_soc_dapm_widget_list **list, int new);
-int dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream);
-int dpcm_be_dai_shutdown(struct snd_soc_pcm_runtime *fe, int stream);
-void dpcm_be_disconnect(struct snd_soc_pcm_runtime *fe, int stream);
-void dpcm_clear_pending_state(struct snd_soc_pcm_runtime *fe, int stream);
-int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream);
-int dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int tream);
-int dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream, int cmd);
-int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream);
-int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,
-	int event);
-
-static inline void dpcm_path_put(struct snd_soc_dapm_widget_list **list)
-{
-	kfree(*list);
-}
-
-
 #endif
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 9338da8..85c1522 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -26,7 +26,6 @@
 #include <sound/compress_driver.h>
 #include <sound/control.h>
 #include <sound/ac97_codec.h>
-#include <sound/effect_driver.h>
 
 /*
  * Convenience kcontrol builders
@@ -93,12 +92,6 @@
 		{.reg = xreg, .rreg = xreg, .shift = xshift, \
 		 .rshift = xshift, .min = xmin, .max = xmax, \
 		 .platform_max = xmax, .invert = xinvert} }
-#define SND_SOC_BYTES_EXT(xname, xcount, xhandler_get, xhandler_put) \
-{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
-	.info = snd_soc_info_bytes_ext, \
-	.get = xhandler_get, .put = xhandler_put, \
-	.private_value = (unsigned long)&(struct soc_bytes_ext) \
-		{.max = xcount} }
 #define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
 	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
@@ -427,21 +420,6 @@ struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 		const char *dai_link, int stream);
 struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 		const char *dai_link);
-#if IS_ENABLED(CONFIG_SND_EFFECTS_OFFLOAD)
-int snd_soc_register_effect(struct snd_soc_card *card,
-				struct snd_effect_ops *ops);
-int snd_soc_unregister_effect(struct snd_soc_card *card);
-#else
-static inline int snd_soc_register_effect(struct snd_soc_card *card,
-					struct snd_effect_ops *ops)
-{
-	return -ENODEV;
-}
-static inline int snd_soc_unregister_effect(struct snd_soc_card *card)
-{
-	return -ENODEV;
-}
-#endif
 
 /* Utility functions to get clock rates from various things */
 int snd_soc_calc_frame_size(int sample_size, int channels, int tdm_slots);
@@ -560,8 +538,6 @@ int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
-int snd_soc_info_bytes_ext(struct snd_kcontrol *kcontrol,
-	struct snd_ctl_elem_info *ucontrol);
 
 /**
  * struct snd_soc_reg_access - Describes whether a given register is
@@ -618,7 +594,6 @@ struct snd_soc_jack_zone {
  * @name:         gpio name
  * @report:       value to report when jack detected
  * @invert:       report presence in low state
- * @irq_flag:	  Interrupt flags for GPIO-Irq line
  * @debouce_time: debouce time in ms
  * @wake:	  enable as wake source
  * @jack_status_check: callback function which overrides the detection
@@ -633,7 +608,6 @@ struct snd_soc_jack_gpio {
 	int invert;
 	int debounce_time;
 	bool wake;
-	unsigned long irq_flags;
 
 	struct snd_soc_jack *jack;
 	struct delayed_work work;
@@ -958,10 +932,6 @@ struct snd_soc_dai_link {
 	/* machine stream operations */
 	const struct snd_soc_ops *ops;
 	const struct snd_soc_compr_ops *compr_ops;
-
-	/*no of substreams */
-	unsigned int playback_count;
-	unsigned int capture_count;
 };
 
 struct snd_soc_codec_conf {
@@ -1093,7 +1063,6 @@ struct snd_soc_pcm_runtime {
 
 	/* Dynamic PCM BE runtime data */
 	struct snd_soc_dpcm_runtime dpcm[2];
-	int fe_compr;
 
 	long pmdown_time;
 	unsigned char pop_wait:1;
@@ -1131,10 +1100,6 @@ struct soc_mreg_control {
 	unsigned int regbase, regcount, nbits, invert;
 };
 
-struct soc_bytes_ext {
-	int max;
-};
-
 /* enumerated kcontrol */
 struct soc_enum {
 	unsigned short reg;
diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild
index 349600c..bdc6e87 100644
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -56,7 +56,6 @@ header-y += atmppp.h
 header-y += atmsap.h
 header-y += atmsvc.h
 header-y += audit.h
-header-y += aufs_type.h
 header-y += auto_fs.h
 header-y += auto_fs4.h
 header-y += auxvec.h
diff --git a/include/uapi/linux/mmc/ioctl.h b/include/uapi/linux/mmc/ioctl.h
index 98ad956..1f5e689 100644
--- a/include/uapi/linux/mmc/ioctl.h
+++ b/include/uapi/linux/mmc/ioctl.h
@@ -47,19 +47,6 @@ struct mmc_ioc_cmd {
 
 #define MMC_IOC_CMD _IOWR(MMC_BLOCK_MAJOR, 0, struct mmc_ioc_cmd)
 
-struct mmc_ioc_rpmb_req {
-	__u16 type;                     /* RPMB request type */
-	__u16 *result;                  /* response or request result */
-	__u16 blk_cnt;                  /* Number of blocks(half sector 256B) */
-	__u16 addr;                     /* data address */
-	__u32 *wc;                      /* write counter */
-	__u8 *nonce;                    /* Ramdom number */
-	__u8 *data;                     /* Buffer of the user data */
-	__u8 *mac;                      /* Message Authentication Code */
-};
-
-#define MMC_IOC_RPMB_REQ _IOWR(MMC_BLOCK_MAJOR, 1, struct mmc_ioc_rpmb_req)
-
 /*
  * Since this ioctl is only meant to enhance (and not replace) normal access
  * to the mmc bus device, an upper data transfer limit of MMC_IOC_MAX_BYTES
diff --git a/include/uapi/linux/msdos_fs.h b/include/uapi/linux/msdos_fs.h
index 9ac8452..f055e58 100644
--- a/include/uapi/linux/msdos_fs.h
+++ b/include/uapi/linux/msdos_fs.h
@@ -45,7 +45,6 @@
 
 #define CASE_LOWER_BASE	8	/* base is lower case */
 #define CASE_LOWER_EXT	16	/* extension is lower case */
-#define FAT_NO_83NAME	32	/* no 8.3 short filename for this file */
 
 #define DELETED_FLAG	0xe5	/* marks file as deleted when in name[0] */
 #define IS_FREE(n)	(!*(n) || *(n) == DELETED_FLAG)
diff --git a/include/uapi/linux/nfs_mount.h b/include/uapi/linux/nfs_mount.h
index 9541d71..576bddd 100644
--- a/include/uapi/linux/nfs_mount.h
+++ b/include/uapi/linux/nfs_mount.h
@@ -20,7 +20,7 @@
  * mount-to-kernel version compatibility.  Some of these aren't used yet
  * but here they are anyway.
  */
-#define NFS_MOUNT_VERSION	7
+#define NFS_MOUNT_VERSION	6
 #define NFS_MAX_CONTEXT_LEN	256
 
 struct nfs_mount_data {
@@ -43,8 +43,6 @@ struct nfs_mount_data {
 	struct nfs3_fh	root;			/* 4 */
 	int		pseudoflavor;		/* 5 */
 	char		context[NFS_MAX_CONTEXT_LEN + 1];	/* 6 */
-	int		nfs_prog; /* 7 */
-	int		mount_prog; /* 7 */
 };
 
 /* bits in the flags field visible to user space */
diff --git a/include/uapi/sound/compress_offload.h b/include/uapi/sound/compress_offload.h
index 21eed48..d630163 100644
--- a/include/uapi/sound/compress_offload.h
+++ b/include/uapi/sound/compress_offload.h
@@ -30,7 +30,7 @@
 #include <sound/compress_params.h>
 
 
-#define SNDRV_COMPRESS_VERSION SNDRV_PROTOCOL_VERSION(0, 1, 2)
+#define SNDRV_COMPRESS_VERSION SNDRV_PROTOCOL_VERSION(0, 1, 1)
 /**
  * struct snd_compressed_buffer: compressed buffer
  * @fragment_size: size of buffer fragment in bytes
@@ -67,8 +67,8 @@ struct snd_compr_params {
 struct snd_compr_tstamp {
 	__u32 byte_offset;
 	__u32 copied_total;
-	__u32 pcm_frames;
-	__u32 pcm_io_frames;
+	snd_pcm_uframes_t pcm_frames;
+	snd_pcm_uframes_t pcm_io_frames;
 	__u32 sampling_rate;
 };
 
@@ -80,7 +80,7 @@ struct snd_compr_tstamp {
 struct snd_compr_avail {
 	__u64 avail;
 	struct snd_compr_tstamp tstamp;
-} __attribute__((packed));
+};
 
 enum snd_compr_direction {
 	SND_COMPRESS_PLAYBACK = 0,
diff --git a/init/Kconfig b/init/Kconfig
index 0b5d0c8..2d9b831 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1261,31 +1261,6 @@ menuconfig EXPERT
           environments which can tolerate a "non-standard" kernel.
           Only use this if you really know what you are doing.
 
-config UPTIME_LIMITED_KERNEL
-	bool "Create a kernel with uptime limitations"
-	default n
-	help
-	  Limit the amount of time a kernel can run. The associated UPTIME_LIMIT*
-	  kernel config options should be used to tune the behaviour.
-
-config UPTIME_LIMIT_DURATION
-	int "Kernel uptime limit in minutes"
-	depends on UPTIME_LIMITED_KERNEL
-	range 0 14400
-	default 0
-	help
-	  Define the uptime limitation on a kernel in minutes. Once
-	  the defined time expires the kernel will emit a warning, cease
-	  to be usable and eventually restart. The valid range is 0 (disable)
-	  to 14400 (10 days)
-
-config UPTIME_LIMIT_KERNEL_REBOOT
-	bool "Reboot a time limited kernel at expiration"
-	depends on UPTIME_LIMITED_KERNEL
-	default y
-	help
-	  Reboot an uptime limited kernel at expiration.
-
 config UID16
 	bool "Enable 16-bit UID system calls" if EXPERT
 	depends on HAVE_UID16
diff --git a/init/do_mounts.c b/init/do_mounts.c
index 4b4936d..a2b49f2 100644
--- a/init/do_mounts.c
+++ b/init/do_mounts.c
@@ -412,9 +412,7 @@ retry:
 		printk("DEBUG_BLOCK_EXT_DEVT is enabled, you need to specify "
 		       "explicit textual name for \"root=\" boot option.\n");
 #endif
-		printk(KERN_EMERG "VFS: Unable to mount root fs on %s\n", b);
-		printk(KERN_EMERG "User configuration error - no valid root filesystem found\n");
-		panic("Invalid configuration from end user prevents continuing");
+		panic("VFS: Unable to mount root fs on %s", b);
 	}
 
 	printk("List of all partitions:\n");
@@ -426,9 +424,7 @@ retry:
 #ifdef CONFIG_BLOCK
 	__bdevname(ROOT_DEV, b);
 #endif
-	printk(KERN_EMERG "VFS: Unable to mount root fs on %s\n", b);
-	printk(KERN_EMERG "User configuration error - no valid root filesystem found\n");
-	panic("Invalid configuration from end user prevents continuing");
+	panic("VFS: Unable to mount root fs on %s", b);
 out:
 	put_page(page);
 }
diff --git a/init/main.c b/init/main.c
index beddd35..8f1ab50 100644
--- a/init/main.c
+++ b/init/main.c
@@ -854,7 +854,6 @@ static int __ref kernel_init(void *unused)
 
 static noinline void __init kernel_init_freeable(void)
 {
-	struct stat console_stat;
 	/*
 	 * Wait until kthreadd is all set-up.
 	 */
@@ -884,12 +883,6 @@ static noinline void __init kernel_init_freeable(void)
 
 	do_basic_setup();
 
-	/* Use /dev/console to infer if the rootfs is setup properly */
-	if (sys_newlstat((char __user *) "/dev/console", (struct stat __user *) &console_stat)
-			|| !S_ISCHR(console_stat.st_mode)) {
-		panic("/dev/console is missing or not a character device!\nPlease ensure your rootfs is properly configured\n");
-	}
-
 	/* Open the /dev/console on the rootfs, this should never fail */
 	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
 		pr_err("Warning: unable to open an initial console.\n");
diff --git a/kernel/Makefile b/kernel/Makefile
index 5d7a07f..271fd31 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -31,7 +31,6 @@ obj-$(CONFIG_FREEZER) += freezer.o
 obj-$(CONFIG_PROFILING) += profile.o
 obj-$(CONFIG_STACKTRACE) += stacktrace.o
 obj-y += time/
-obj-$(CONFIG_UPTIME_LIMITED_KERNEL) += uptime_limit.o
 obj-$(CONFIG_DEBUG_MUTEXES) += mutex-debug.o
 obj-$(CONFIG_LOCKDEP) += lockdep.o
 ifeq ($(CONFIG_PROC_FS),y)
diff --git a/kernel/fork.c b/kernel/fork.c
index a7ccd52..80d92e9 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -418,8 +418,6 @@ static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)
 			struct address_space *mapping = file->f_mapping;
 
 			get_file(file);
-			if (tmp->vm_prfile)
-				get_file(tmp->vm_prfile);
 			if (tmp->vm_flags & VM_DENYWRITE)
 				atomic_dec(&inode->i_writecount);
 			mutex_lock(&mapping->i_mmap_mutex);
diff --git a/mm/memory.c b/mm/memory.c
index 265c29b..5a35443 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -3461,8 +3461,6 @@ static int __do_fault(struct mm_struct *mm, struct vm_area_struct *vma,
 		/* file_update_time outside page_lock */
 		if (vma->vm_file && !page_mkwrite)
 			file_update_time(vma->vm_file);
-		if (vma->vm_prfile && !page_mkwrite)
-			file_update_time(vma->vm_prfile);
 	} else {
 		unlock_page(vmf.page);
 		if (anon)
diff --git a/mm/mmap.c b/mm/mmap.c
index d7bae85..8d25fdc 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -251,8 +251,6 @@ static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file)
 		fput(vma->vm_file);
-	if (vma->vm_prfile)
-		fput(vma->vm_prfile);
 	mpol_put(vma_policy(vma));
 	kmem_cache_free(vm_area_cachep, vma);
 	return next;
@@ -863,8 +861,6 @@ again:			remove_next = 1 + (end > next->vm_end);
 		if (file) {
 			uprobe_munmap(next, next->vm_start, next->vm_end);
 			fput(file);
-			if (vma->vm_prfile)
-				fput(vma->vm_prfile);
 		}
 		if (next->anon_vma)
 			anon_vma_merge(vma, next);
@@ -2446,8 +2442,6 @@ static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma,
 
 	if (new->vm_file)
 		get_file(new->vm_file);
-	if (new->vm_prfile)
-		get_file(new->vm_prfile);
 
 	if (new->vm_ops && new->vm_ops->open)
 		new->vm_ops->open(new);
@@ -2467,8 +2461,6 @@ static int __split_vma(struct mm_struct * mm, struct vm_area_struct * vma,
 		new->vm_ops->close(new);
 	if (new->vm_file)
 		fput(new->vm_file);
-	if (new->vm_prfile)
-		fput(new->vm_prfile);
 	unlink_anon_vmas(new);
  out_free_mpol:
 	mpol_put(pol);
@@ -2868,8 +2860,6 @@ struct vm_area_struct *copy_vma(struct vm_area_struct **vmap,
 				goto out_free_mempol;
 			if (new_vma->vm_file)
 				get_file(new_vma->vm_file);
-			if (new_vma->vm_prfile)
-				get_file(new_vma->vm_prfile);
 			if (new_vma->vm_ops && new_vma->vm_ops->open)
 				new_vma->vm_ops->open(new_vma);
 			vma_link(mm, new_vma, prev, rb_link, rb_parent);
diff --git a/mm/nommu.c b/mm/nommu.c
index d30faea..298884d 100644
--- a/mm/nommu.c
+++ b/mm/nommu.c
@@ -651,8 +651,6 @@ static void __put_nommu_region(struct vm_region *region)
 
 		if (region->vm_file)
 			fput(region->vm_file);
-		if (region->vm_prfile)
-			fput(region->vm_prfile);
 
 		/* IO memory and memory shared directly out of the pagecache
 		 * from ramfs/tmpfs mustn't be released here */
@@ -811,8 +809,6 @@ static void delete_vma(struct mm_struct *mm, struct vm_area_struct *vma)
 		vma->vm_ops->close(vma);
 	if (vma->vm_file)
 		fput(vma->vm_file);
-	if (vma->vm_prfile)
-		fput(vma->vm_prfile);
 	put_nommu_region(vma->vm_region);
 	kmem_cache_free(vm_area_cachep, vma);
 }
@@ -1379,8 +1375,6 @@ unsigned long do_mmap_pgoff(struct file *file,
 				}
 			}
 			fput(region->vm_file);
-			if (region->vm_prfile)
-				fput(region->vm_prfile);
 			kmem_cache_free(vm_region_jar, region);
 			region = pregion;
 			result = start;
@@ -1457,13 +1451,9 @@ error_just_free:
 error:
 	if (region->vm_file)
 		fput(region->vm_file);
-	if (region->vm_prfile)
-		fput(region->vm_prfile);
 	kmem_cache_free(vm_region_jar, region);
 	if (vma->vm_file)
 		fput(vma->vm_file);
-	if (vma->vm_prfile)
-		fput(vma->vm_prfile);
 	kmem_cache_free(vm_area_cachep, vma);
 	kleave(" = %d", ret);
 	return ret;
diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index 1d6f790..68843a2 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -58,18 +58,6 @@ static void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);
 static void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,
 		     struct sk_buff_head *skbs, u8 event);
 
-static inline __u8 bdaddr_type(struct hci_conn *hcon, __u8 type)
-{
-	if (hcon->type == LE_LINK) {
-		if (type == ADDR_LE_DEV_PUBLIC)
-			return BDADDR_LE_PUBLIC;
-		else
-			return BDADDR_LE_RANDOM;
-	}
-
-	return BDADDR_BREDR;
-}
-
 /* ---- L2CAP channels ---- */
 
 static struct l2cap_chan *__l2cap_get_chan_by_dcid(struct l2cap_conn *conn,
@@ -1376,8 +1364,6 @@ static void l2cap_le_conn_ready(struct l2cap_conn *conn)
 
 	bacpy(&bt_sk(sk)->src, conn->src);
 	bacpy(&bt_sk(sk)->dst, conn->dst);
-	chan->src_type = bdaddr_type(conn->hcon, conn->hcon->src_type);
-	chan->dst_type = bdaddr_type(conn->hcon, conn->hcon->dst_type);
 
 	l2cap_chan_add(conn, chan);
 
@@ -1799,7 +1785,6 @@ int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,
 	/* Set destination address and psm */
 	lock_sock(sk);
 	bacpy(&bt_sk(sk)->dst, dst);
-	chan->dst_type = dst_type;
 	release_sock(sk);
 
 	chan->psm = psm;
@@ -1807,7 +1792,7 @@ int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,
 
 	auth_type = l2cap_get_auth_type(chan);
 
-	if (bdaddr_type_is_le(dst_type))
+	if (chan->dcid == L2CAP_CID_LE_DATA)
 		hcon = hci_connect(hdev, LE_LINK, dst, dst_type,
 				   chan->sec_level, auth_type);
 	else
@@ -1840,7 +1825,6 @@ int l2cap_chan_connect(struct l2cap_chan *chan, __le16 psm, u16 cid,
 
 	/* Update source addr of the socket */
 	bacpy(src, conn->src);
-	chan->src_type = bdaddr_type(hcon, hcon->src_type);
 
 	l2cap_chan_unlock(chan);
 	l2cap_chan_add(conn, chan);
@@ -3771,8 +3755,6 @@ static struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,
 
 	bacpy(&bt_sk(sk)->src, conn->src);
 	bacpy(&bt_sk(sk)->dst, conn->dst);
-	chan->src_type = bdaddr_type(conn->hcon, conn->hcon->src_type);
-	chan->dst_type = bdaddr_type(conn->hcon, conn->hcon->dst_type);
 	chan->psm  = psm;
 	chan->dcid = scid;
 	chan->local_amp_id = amp_id;
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index d0ff076..36fed40 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -103,8 +103,7 @@ static int l2cap_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
 	    __le16_to_cpu(la.l2_psm) == L2CAP_PSM_RFCOMM)
 		chan->sec_level = BT_SECURITY_SDP;
 
-	bacpy(&chan->src, &la.l2_bdaddr);
-	chan->src_type = la.l2_bdaddr_type;
+	bacpy(&bt_sk(sk)->src, &la.l2_bdaddr);
 
 	chan->state = BT_BOUND;
 	sk->sk_state = BT_BOUND;
@@ -268,12 +267,10 @@ static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr,
 		la->l2_psm = chan->psm;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);
 		la->l2_cid = cpu_to_le16(chan->dcid);
-		la->l2_bdaddr_type = chan->dst_type;
 	} else {
 		la->l2_psm = chan->sport;
 		bacpy(&la->l2_bdaddr, &bt_sk(sk)->src);
 		la->l2_cid = cpu_to_le16(chan->scid);
-		la->l2_bdaddr_type = chan->src_type;
 	}
 
 	return 0;
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 791c19f..247ec19 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -912,14 +912,7 @@ static int arp_process(struct sk_buff *skb)
 		   agents are active. Taking the first reply prevents
 		   arp trashing and chooses the fastest router.
 		 */
-		/*
-		 * If n->updated is after jiffies, then the clock has wrapped and
-		 * we are *well* past the locktime, so set the override flag
-		 */
-		if (time_after(n->updated, jiffies))
-			override = 1;
-		else
-			override = time_after(jiffies, n->updated + n->parms->locktime);
+		override = time_after(jiffies, n->updated + n->parms->locktime);
 
 		/* Broadcast replies and request packets
 		   do not assert neighbour reachability.
diff --git a/net/ipv4/inet_fragment.c b/net/ipv4/inet_fragment.c
index f7f8af9..7e06641 100644
--- a/net/ipv4/inet_fragment.c
+++ b/net/ipv4/inet_fragment.c
@@ -283,10 +283,9 @@ static struct inet_frag_queue *inet_frag_intern(struct netns_frags *nf,
 
 	atomic_inc(&qp->refcnt);
 	hlist_add_head(&qp->list, &hb->chain);
-	inet_frag_lru_add(nf, qp);
 	spin_unlock(&hb->chain_lock);
 	read_unlock(&f->lock);
-
+	inet_frag_lru_add(nf, qp);
 	return qp;
 }
 
diff --git a/net/netfilter/nf_conntrack_proto_dccp.c b/net/netfilter/nf_conntrack_proto_dccp.c
index 59359be..a99b6c3 100644
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@ -428,7 +428,7 @@ static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,
 	const char *msg;
 	u_int8_t state;
 
-	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
+	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);
 	BUG_ON(dh == NULL);
 
 	state = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];
@@ -486,7 +486,7 @@ static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,
 	u_int8_t type, old_state, new_state;
 	enum ct_dccp_roles role;
 
-	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
+	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);
 	BUG_ON(dh == NULL);
 	type = dh->dccph_type;
 
@@ -577,7 +577,7 @@ static int dccp_error(struct net *net, struct nf_conn *tmpl,
 	unsigned int cscov;
 	const char *msg;
 
-	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
+	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);
 	if (dh == NULL) {
 		msg = "nf_ct_dccp: short packet ";
 		goto out_invalid;
diff --git a/scripts/kconfig/menu.c b/scripts/kconfig/menu.c
index bea100b..fd3f018 100644
--- a/scripts/kconfig/menu.c
+++ b/scripts/kconfig/menu.c
@@ -525,7 +525,7 @@ static void get_prompt_str(struct gstr *r, struct property *prop,
 {
 	int i, j;
 	struct menu *submenu[8], *menu, *location = NULL;
-	struct jump_key *jump = NULL;
+	struct jump_key *jump;
 
 	str_printf(r, _("Prompt: %s\n"), _(prop->text));
 	menu = prop->menu->parent;
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index b4c1161..a4be8e1 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1705,7 +1705,7 @@ static void read_symbols(char *modname)
 	char *version;
 	char *license;
 	struct module *mod;
-	struct elf_info info = { .hdr = NULL };
+	struct elf_info info = { };
 	Elf_Sym *sym;
 
 	if (!parse_elf(&info, modname))
@@ -2118,7 +2118,7 @@ static int dump_sym(struct symbol *sym)
 
 static void write_dump(const char *fname)
 {
-	struct buffer buf = { NULL, 0, 0 };
+	struct buffer buf = { };
 	struct symbol *symbol;
 	int n;
 
@@ -2144,7 +2144,7 @@ struct ext_sym_list {
 int main(int argc, char **argv)
 {
 	struct module *mod;
-	struct buffer buf = { NULL, 0, 0 };
+	struct buffer buf = { };
 	char *kernel_read = NULL, *module_read = NULL;
 	char *dump_write = NULL, *files_source = NULL;
 	int opt;
diff --git a/security/commoncap.c b/security/commoncap.c
index d78b003..c44b6fe 100644
--- a/security/commoncap.c
+++ b/security/commoncap.c
@@ -988,11 +988,9 @@ int cap_mmap_addr(unsigned long addr)
 	}
 	return ret;
 }
-EXPORT_SYMBOL(cap_mmap_addr);
 
 int cap_mmap_file(struct file *file, unsigned long reqprot,
 		  unsigned long prot, unsigned long flags)
 {
 	return 0;
 }
-EXPORT_SYMBOL(cap_mmap_file);
diff --git a/security/device_cgroup.c b/security/device_cgroup.c
index 9760ecb6..dd0dc57 100644
--- a/security/device_cgroup.c
+++ b/security/device_cgroup.c
@@ -7,7 +7,6 @@
 #include <linux/device_cgroup.h>
 #include <linux/cgroup.h>
 #include <linux/ctype.h>
-#include <linux/export.h>
 #include <linux/list.h>
 #include <linux/uaccess.h>
 #include <linux/seq_file.h>
@@ -790,7 +789,6 @@ int __devcgroup_inode_permission(struct inode *inode, int mask)
 	return __devcgroup_check_permission(type, imajor(inode), iminor(inode),
 			access);
 }
-EXPORT_SYMBOL(__devcgroup_inode_permission);
 
 int devcgroup_inode_mknod(int mode, dev_t dev)
 {
diff --git a/sound/core/Kconfig b/sound/core/Kconfig
index 27a27bd..b413ed0 100644
--- a/sound/core/Kconfig
+++ b/sound/core/Kconfig
@@ -15,9 +15,6 @@ config SND_RAWMIDI
 config SND_COMPRESS_OFFLOAD
 	tristate
 
-config SND_EFFECTS_OFFLOAD
-	tristate
-
 # To be effective this also requires INPUT - users should say:
 #    select SND_JACK if INPUT=y || INPUT=SND
 # to avoid having to force INPUT on.
diff --git a/sound/core/Makefile b/sound/core/Makefile
index 9e37a2b..43d4117 100644
--- a/sound/core/Makefile
+++ b/sound/core/Makefile
@@ -23,7 +23,6 @@ snd-rtctimer-objs := rtctimer.o
 snd-hwdep-objs    := hwdep.o
 
 snd-compress-objs := compress_offload.o
-snd-effects-objs := effects_offload.o
 
 obj-$(CONFIG_SND) 		+= snd.o
 obj-$(CONFIG_SND_HWDEP)		+= snd-hwdep.o
@@ -37,4 +36,3 @@ obj-$(CONFIG_SND_OSSEMUL)	+= oss/
 obj-$(CONFIG_SND_SEQUENCER)	+= seq/
 
 obj-$(CONFIG_SND_COMPRESS_OFFLOAD)	+= snd-compress.o
-obj-$(CONFIG_SND_EFFECTS_OFFLOAD)	+= snd-effects.o
diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c
index 632dcd6..5863ba6 100644
--- a/sound/core/compress_offload.c
+++ b/sound/core/compress_offload.c
@@ -123,7 +123,6 @@ static int snd_compr_open(struct inode *inode, struct file *f)
 	}
 	runtime->state = SNDRV_PCM_STATE_OPEN;
 	init_waitqueue_head(&runtime->sleep);
-	init_waitqueue_head(&runtime->wait);
 	data->stream.runtime = runtime;
 	f->private_data = (void *)data;
 	mutex_lock(&compr->lock);
@@ -140,18 +139,6 @@ static int snd_compr_open(struct inode *inode, struct file *f)
 static int snd_compr_free(struct inode *inode, struct file *f)
 {
 	struct snd_compr_file *data = f->private_data;
-	struct snd_compr_runtime *runtime = data->stream.runtime;
-
-	switch (runtime->state) {
-	case SNDRV_PCM_STATE_RUNNING:
-	case SNDRV_PCM_STATE_DRAINING:
-	case SNDRV_PCM_STATE_PAUSED:
-		data->stream.ops->trigger(&data->stream, SNDRV_PCM_TRIGGER_STOP);
-		break;
-	default:
-		break;
-	}
-
 	data->stream.ops->free(&data->stream);
 	kfree(data->stream.runtime->buffer);
 	kfree(data->stream.runtime);
@@ -269,25 +256,16 @@ static ssize_t snd_compr_write(struct file *f, const char __user *buf,
 	struct snd_compr_file *data = f->private_data;
 	struct snd_compr_stream *stream;
 	size_t avail;
-	int retval = 0;
+	int retval;
 
 	if (snd_BUG_ON(!data))
 		return -EFAULT;
 
 	stream = &data->stream;
 	mutex_lock(&stream->device->lock);
-	 /*
-	 * if the stream is in paused state, return the
-	 * number of bytes consumed as 0
-	 */
-	if (stream->runtime->state == SNDRV_PCM_STATE_PAUSED) {
-		mutex_unlock(&stream->device->lock);
-		return retval;
-	}
-	/* write is allowed when stream is running or prepared or in setup */
+	/* write is allowed when stream is running or has been steup */
 	if (stream->runtime->state != SNDRV_PCM_STATE_SETUP &&
-			stream->runtime->state != SNDRV_PCM_STATE_RUNNING &&
-			stream->runtime->state != SNDRV_PCM_STATE_PREPARED) {
+			stream->runtime->state != SNDRV_PCM_STATE_RUNNING) {
 		mutex_unlock(&stream->device->lock);
 		return -EBADFD;
 	}
@@ -394,7 +372,8 @@ static unsigned int snd_compr_poll(struct file *f, poll_table *wait)
 		return -EFAULT;
 
 	mutex_lock(&stream->device->lock);
-	if (stream->runtime->state == SNDRV_PCM_STATE_OPEN) {
+	if (stream->runtime->state == SNDRV_PCM_STATE_PAUSED ||
+			stream->runtime->state == SNDRV_PCM_STATE_OPEN) {
 		retval = -EBADFD;
 		goto out;
 	}
@@ -418,7 +397,6 @@ static unsigned int snd_compr_poll(struct file *f, poll_table *wait)
 			retval = snd_compr_get_poll(stream);
 		break;
 	default:
-		pr_err("poll returns err!...\n");
 		if (stream->direction == SND_COMPRESS_PLAYBACK)
 			retval = POLLOUT | POLLWRNORM | POLLERR;
 		else
@@ -649,8 +627,7 @@ static int snd_compr_pause(struct snd_compr_stream *stream)
 {
 	int retval;
 
-	if ((stream->runtime->state != SNDRV_PCM_STATE_RUNNING) &&
-		(stream->runtime->state != SNDRV_PCM_STATE_DRAINING))
+	if (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)
 		return -EPERM;
 	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);
 	if (!retval)
@@ -665,10 +642,8 @@ static int snd_compr_resume(struct snd_compr_stream *stream)
 	if (stream->runtime->state != SNDRV_PCM_STATE_PAUSED)
 		return -EPERM;
 	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
-	if (!retval) {
+	if (!retval)
 		stream->runtime->state = SNDRV_PCM_STATE_RUNNING;
-		wake_up(&stream->runtime->sleep);
-	}
 	return retval;
 }
 
@@ -684,71 +659,35 @@ static int snd_compr_start(struct snd_compr_stream *stream)
 	return retval;
 }
 
-int snd_compr_stop(struct snd_compr_stream *stream)
+static int snd_compr_stop(struct snd_compr_stream *stream)
 {
-	int retval = 0;
+	int retval;
 
-	if (stream->runtime->state == SNDRV_PCM_STATE_SETUP)
+	if (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||
+			stream->runtime->state == SNDRV_PCM_STATE_SETUP)
 		return -EPERM;
-	if (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)
-		retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);
+	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);
 	if (!retval) {
 		stream->runtime->state = SNDRV_PCM_STATE_SETUP;
 		wake_up(&stream->runtime->sleep);
-		snd_compr_drain_notify(stream);
 		stream->runtime->total_bytes_available = 0;
 		stream->runtime->total_bytes_transferred = 0;
 	}
 	return retval;
 }
-EXPORT_SYMBOL(snd_compr_stop);
-
-static int snd_compress_wait_for_drain(struct snd_compr_stream *stream)
-{
-	/*
-	 * We are called with lock held. So drop the lock while we wait for
-	 * drain complete notfication from the driver
-	 *
-	 * It is expected that driver will notify the drain completion and then
-	 * stream will be moved to SETUP state, even if draining resulted in an
-	 * error. We can trigger next track after this.
-	 */
-	stream->runtime->state = SNDRV_PCM_STATE_DRAINING;
-	mutex_unlock(&stream->device->lock);
-
-	wait_event(stream->runtime->wait, stream->runtime->drain_wake);
-
-	wake_up(&stream->runtime->sleep);
-	mutex_lock(&stream->device->lock);
-
-	return 0;
-}
 
 static int snd_compr_drain(struct snd_compr_stream *stream)
 {
-	int retval = 0;
+	int retval;
 
-	if (stream->runtime->state == SNDRV_PCM_STATE_SETUP)
+	if (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||
+			stream->runtime->state == SNDRV_PCM_STATE_SETUP)
 		return -EPERM;
-
-	stream->runtime->drain_wake = 0;
-
-	/* this is hackish for our tree but for now lets carry it while we fix
-	 * usermode behaviour
-	 */
-	if (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)
-		retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);
-	else
-		return 0;
-
-	if (retval) {
-		pr_err("SND_COMPR_TRIGGER_DRAIN failed %d\n", retval);
+	retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);
+	if (!retval) {
+		stream->runtime->state = SNDRV_PCM_STATE_DRAINING;
 		wake_up(&stream->runtime->sleep);
-		return retval;
 	}
-
-	retval = snd_compress_wait_for_drain(stream);
-	stream->runtime->state = SNDRV_PCM_STATE_SETUP;
 	return retval;
 }
 
@@ -776,30 +715,17 @@ static int snd_compr_next_track(struct snd_compr_stream *stream)
 
 static int snd_compr_partial_drain(struct snd_compr_stream *stream)
 {
-	int retval = 0;
-
-	/* agaain hackish  changes */
-	if (stream->runtime->state == SNDRV_PCM_STATE_SETUP)
+	int retval;
+	if (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||
+			stream->runtime->state == SNDRV_PCM_STATE_SETUP)
 		return -EPERM;
 	/* stream can be drained only when next track has been signalled */
 	if (stream->next_track == false)
 		return -EPERM;
 
-	stream->runtime->drain_wake = 0;
-	if (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)
-		retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);
-	else
-		return 0;
-
-	if (retval) {
-		pr_err("Partial drain returned failure\n");
-		wake_up(&stream->runtime->sleep);
-		return retval;
-	}
+	retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);
 
 	stream->next_track = false;
-	retval = snd_compress_wait_for_drain(stream);
-	stream->runtime->state = SNDRV_PCM_STATE_SETUP;
 	return retval;
 }
 
@@ -878,9 +804,6 @@ static const struct file_operations snd_compr_file_ops = {
 		.write =	snd_compr_write,
 		.read =		snd_compr_read,
 		.unlocked_ioctl = snd_compr_ioctl,
-#ifdef CONFIG_COMPAT
-		.compat_ioctl =	snd_compr_ioctl,
-#endif
 		.mmap =		snd_compr_mmap,
 		.poll =		snd_compr_poll,
 };
@@ -895,7 +818,7 @@ static int snd_compress_dev_register(struct snd_device *device)
 		return -EBADFD;
 	compr = device->device_data;
 
-	snprintf(str, sizeof(str), "comprC%iD%i", compr->card->number, compr->device);
+	sprintf(str, "comprC%iD%i", compr->card->number, compr->device);
 	pr_debug("reg %s for device %s, direction %d\n", str, compr->name,
 			compr->direction);
 	/* register compressed device */
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 23f39d2..9e675c7 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -45,7 +45,7 @@ source "sound/soc/jz4740/Kconfig"
 source "sound/soc/nuc900/Kconfig"
 source "sound/soc/omap/Kconfig"
 source "sound/soc/kirkwood/Kconfig"
-source "sound/soc/intel/Kconfig"
+source "sound/soc/mid-x86/Kconfig"
 source "sound/soc/mxs/Kconfig"
 source "sound/soc/pxa/Kconfig"
 source "sound/soc/samsung/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 25201f53..197b6ae 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -20,7 +20,7 @@ obj-$(CONFIG_SND_SOC)	+= davinci/
 obj-$(CONFIG_SND_SOC)	+= dwc/
 obj-$(CONFIG_SND_SOC)	+= fsl/
 obj-$(CONFIG_SND_SOC)	+= jz4740/
-obj-$(CONFIG_SND_SOC)	+= intel/
+obj-$(CONFIG_SND_SOC)	+= mid-x86/
 obj-$(CONFIG_SND_SOC)	+= mxs/
 obj-$(CONFIG_SND_SOC)	+= nuc900/
 obj-$(CONFIG_SND_SOC)	+= omap/
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index 97b7b8f..29e95f9 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -16,7 +16,6 @@
 #include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/pm.h>
-#include <linux/gcd.h>
 #include <linux/i2c.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
@@ -94,9 +93,9 @@ static int wm8994_retune_mobile_base[] = {
 
 static const struct wm8958_micd_rate micdet_rates[] = {
 	{ 32768,       true,  1, 4 },
-	{ 32768,       false, 1, 0 },
+	{ 32768,       false, 1, 1 },
 	{ 44100 * 256, true,  7, 10 },
-	{ 44100 * 256, false, 7, 9 },
+	{ 44100 * 256, false, 7, 10 },
 };
 
 static const struct wm8958_micd_rate jackdet_rates[] = {
@@ -540,13 +539,13 @@ static const struct soc_enum adc_osr =
 static const struct snd_kcontrol_new wm8994_snd_controls[] = {
 SOC_DOUBLE_R_TLV("AIF1ADC1 Volume", WM8994_AIF1_ADC1_LEFT_VOLUME,
 		 WM8994_AIF1_ADC1_RIGHT_VOLUME,
-		 1, 120, 0, digital_tlv),
+		 1, 119, 0, digital_tlv),
 SOC_DOUBLE_R_TLV("AIF1ADC2 Volume", WM8994_AIF1_ADC2_LEFT_VOLUME,
 		 WM8994_AIF1_ADC2_RIGHT_VOLUME,
-		 1, 120, 0, digital_tlv),
+		 1, 119, 0, digital_tlv),
 SOC_DOUBLE_R_TLV("AIF2ADC Volume", WM8994_AIF2_ADC_LEFT_VOLUME,
 		 WM8994_AIF2_ADC_RIGHT_VOLUME,
-		 1, 120, 0, digital_tlv),
+		 1, 119, 0, digital_tlv),
 
 SOC_ENUM("AIF1ADCL Source", aif1adcl_src),
 SOC_ENUM("AIF1ADCR Source", aif1adcr_src),
@@ -608,12 +607,12 @@ SOC_ENUM("ADC OSR", adc_osr),
 SOC_ENUM("DAC OSR", dac_osr),
 
 SOC_DOUBLE_R_TLV("DAC1 Volume", WM8994_DAC1_LEFT_VOLUME,
-		 WM8994_DAC1_RIGHT_VOLUME, 1, 112, 0, digital_tlv),
+		 WM8994_DAC1_RIGHT_VOLUME, 1, 96, 0, digital_tlv),
 SOC_DOUBLE_R("DAC1 Switch", WM8994_DAC1_LEFT_VOLUME,
 	     WM8994_DAC1_RIGHT_VOLUME, 9, 1, 1),
 
 SOC_DOUBLE_R_TLV("DAC2 Volume", WM8994_DAC2_LEFT_VOLUME,
-		 WM8994_DAC2_RIGHT_VOLUME, 1, 112, 0, digital_tlv),
+		 WM8994_DAC2_RIGHT_VOLUME, 1, 96, 0, digital_tlv),
 SOC_DOUBLE_R("DAC2 Switch", WM8994_DAC2_LEFT_VOLUME,
 	     WM8994_DAC2_RIGHT_VOLUME, 9, 1, 1),
 
@@ -639,11 +638,6 @@ SOC_SINGLE_TLV("AIF2DAC 3D Stereo Volume", WM8994_AIF2_DAC_FILTERS_2,
 	       10, 15, 0, wm8994_3d_tlv),
 SOC_SINGLE("AIF2DAC 3D Stereo Switch", WM8994_AIF2_DAC_FILTERS_2,
 	   8, 1, 0),
-
-SOC_SINGLE_TLV("MIXINL MIXOUTL Volume", WM8994_INPUT_MIXER_3, 0, 7, 0,
-	       mixin_boost_tlv),
-SOC_SINGLE_TLV("MIXINR MIXOUTR Volume", WM8994_INPUT_MIXER_4, 0, 7, 0,
-	       mixin_boost_tlv),
 };
 
 static const struct snd_kcontrol_new wm8994_eq_controls[] = {
@@ -872,7 +866,7 @@ static void vmid_reference(struct snd_soc_codec *codec)
 					    WM8994_BIAS_SRC |
 					    WM8994_STARTUP_BIAS_ENA |
 					    WM8994_VMID_BUF_ENA |
-					    (0x3 << WM8994_VMID_RAMP_SHIFT));
+					    (0x2 << WM8994_VMID_RAMP_SHIFT));
 
 			/* Main bias enable, VMID=2x40k */
 			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
@@ -880,14 +874,7 @@ static void vmid_reference(struct snd_soc_codec *codec)
 					    WM8994_VMID_SEL_MASK,
 					    WM8994_BIAS_ENA | 0x2);
 
-			/* The delay of 300ms was recommended to support pop
-			 * free startup of the line output driver, as we don't use
-			 * that feature reducing the delay to 50ms as recommended in
-			 * the spec, Also changing VMID_RAMP to soft fast start
-			 * accordingly Also applies for VMID_FORCE and
-			 * vmid_dereference.
-			 */
-			msleep(50);
+			msleep(300);
 
 			snd_soc_update_bits(codec, WM8994_ANTIPOP_2,
 					    WM8994_VMID_RAMP_MASK |
@@ -906,14 +893,15 @@ static void vmid_reference(struct snd_soc_codec *codec)
 					    WM8994_BIAS_SRC |
 					    WM8994_STARTUP_BIAS_ENA |
 					    WM8994_VMID_BUF_ENA |
-					    (0x3 << WM8994_VMID_RAMP_SHIFT));
+					    (0x2 << WM8994_VMID_RAMP_SHIFT));
 
 			/* Main bias enable, VMID=2x40k */
 			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
 					    WM8994_BIAS_ENA |
 					    WM8994_VMID_SEL_MASK,
 					    WM8994_BIAS_ENA | 0x2);
-			msleep(50);
+
+			msleep(400);
 
 			snd_soc_update_bits(codec, WM8994_ANTIPOP_2,
 					    WM8994_VMID_RAMP_MASK |
@@ -958,7 +946,7 @@ static void vmid_dereference(struct snd_soc_codec *codec)
 		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
 				    WM8994_VMID_SEL_MASK, 0);
 
-		msleep(50);
+		msleep(400);
 
 		/* Active discharge */
 		snd_soc_update_bits(codec, WM8994_ANTIPOP_1,
@@ -981,7 +969,7 @@ static void vmid_dereference(struct snd_soc_codec *codec)
 				    WM8994_VMID_RAMP_MASK, 0);
 
 		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
-				    WM8994_BIAS_ENA | WM8994_VMID_SEL_MASK, 0);
+				    WM8994_VMID_SEL_MASK, 0);
 	}
 
 	pm_runtime_put(codec->dev);
@@ -1067,7 +1055,7 @@ static int aif1clk_ev(struct snd_soc_dapm_widget *w,
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		/* Don't enable timeslot 2 if not in use */
-		if ((wm8994->channels[0] <= 2) && (wm8994->slots <= 2))
+		if (wm8994->channels[0] <= 2)
 			mask &= ~(WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA);
 
 		val = snd_soc_read(codec, WM8994_AIF1_CONTROL_1);
@@ -1343,26 +1331,6 @@ static int dac_ev(struct snd_soc_dapm_widget *w,
 	struct snd_soc_codec *codec = w->codec;
 	unsigned int mask = 1 << w->shift;
 
-	/* Don't propagate FIFO errors unless the DAC is running */
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		/* Clear FIFO error status */
-		snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2,
-				    WM8994_FIFOS_ERR_EINT_MASK,
-				    1 << WM8994_FIFOS_ERR_EINT_SHIFT);
-		/* Unmask FIFO error interrupts */
-		snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2_MASK,
-				    WM8994_IM_FIFOS_ERR_EINT_MASK,
-				    0 << WM8994_IM_FIFOS_ERR_EINT_SHIFT);
-		break;
-	case SND_SOC_DAPM_PRE_PMD:
-		/* Mask FIFO error interrupts */
-		snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2_MASK,
-				    WM8994_IM_FIFOS_ERR_EINT_MASK,
-				    1 << WM8994_IM_FIFOS_ERR_EINT_SHIFT);
-		break;
-	}
-
 	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,
 			    mask, mask);
 	return 0;
@@ -1530,24 +1498,6 @@ static const char *aif1dac_text[] = {
 	"AIF1DACDAT", "AIF3DACDAT",
 };
 
-static const char *loopback_text[] = {
-	"None", "ADCDAT",
-};
-
-static const struct soc_enum aif1_loopback_enum =
-	SOC_ENUM_SINGLE(WM8994_AIF1_CONTROL_2, WM8994_AIF1_LOOPBACK_SHIFT, 2,
-			loopback_text);
-
-static const struct snd_kcontrol_new aif1_loopback =
-	SOC_DAPM_ENUM("AIF1 Loopback", aif1_loopback_enum);
-
-static const struct soc_enum aif2_loopback_enum =
-	SOC_ENUM_SINGLE(WM8994_AIF2_CONTROL_2, WM8994_AIF2_LOOPBACK_SHIFT, 2,
-			loopback_text);
-
-static const struct snd_kcontrol_new aif2_loopback =
-	SOC_DAPM_ENUM("AIF2 Loopback", aif2_loopback_enum);
-
 static const struct soc_enum aif1dac_enum =
 	SOC_ENUM_SINGLE(WM8994_POWER_MANAGEMENT_6, 0, 2, aif1dac_text);
 
@@ -1666,17 +1616,13 @@ SND_SOC_DAPM_MUX("Right Headphone Mux", SND_SOC_NOPM, 0, 0, &wm_hubs_hpr_mux),
 
 static const struct snd_soc_dapm_widget wm8994_dac_revd_widgets[] = {
 SND_SOC_DAPM_DAC_E("DAC2L", NULL, SND_SOC_NOPM, 3, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-	SND_SOC_DAPM_PRE_PMD),
+	dac_ev, SND_SOC_DAPM_PRE_PMU),
 SND_SOC_DAPM_DAC_E("DAC2R", NULL, SND_SOC_NOPM, 2, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-	SND_SOC_DAPM_PRE_PMD),
+	dac_ev, SND_SOC_DAPM_PRE_PMU),
 SND_SOC_DAPM_DAC_E("DAC1L", NULL, SND_SOC_NOPM, 1, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-	SND_SOC_DAPM_PRE_PMD),
+	dac_ev, SND_SOC_DAPM_PRE_PMU),
 SND_SOC_DAPM_DAC_E("DAC1R", NULL, SND_SOC_NOPM, 0, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
-	SND_SOC_DAPM_PRE_PMD),
+	dac_ev, SND_SOC_DAPM_PRE_PMU),
 };
 
 static const struct snd_soc_dapm_widget wm8994_dac_widgets[] = {
@@ -1687,15 +1633,15 @@ SND_SOC_DAPM_DAC("DAC1R", NULL, WM8994_POWER_MANAGEMENT_5, 0, 0),
 };
 
 static const struct snd_soc_dapm_widget wm8994_adc_revd_widgets[] = {
-SND_SOC_DAPM_VIRT_MUX_E("ADCL Mux", SND_SOC_NOPM, 1, 0, &adcl_mux,
+SND_SOC_DAPM_VIRT_MUX_E("ADCL Mux", WM8994_POWER_MANAGEMENT_4, 1, 0, &adcl_mux,
 			adc_mux_ev, SND_SOC_DAPM_PRE_PMU),
-SND_SOC_DAPM_VIRT_MUX_E("ADCR Mux", SND_SOC_NOPM, 0, 0, &adcr_mux,
+SND_SOC_DAPM_VIRT_MUX_E("ADCR Mux", WM8994_POWER_MANAGEMENT_4, 0, 0, &adcr_mux,
 			adc_mux_ev, SND_SOC_DAPM_PRE_PMU),
 };
 
 static const struct snd_soc_dapm_widget wm8994_adc_widgets[] = {
-SND_SOC_DAPM_VIRT_MUX("ADCL Mux", SND_SOC_NOPM, 1, 0, &adcl_mux),
-SND_SOC_DAPM_VIRT_MUX("ADCR Mux", SND_SOC_NOPM, 0, 0, &adcr_mux),
+SND_SOC_DAPM_VIRT_MUX("ADCL Mux", WM8994_POWER_MANAGEMENT_4, 1, 0, &adcl_mux),
+SND_SOC_DAPM_VIRT_MUX("ADCR Mux", WM8994_POWER_MANAGEMENT_4, 0, 0, &adcr_mux),
 };
 
 static const struct snd_soc_dapm_widget wm8994_dapm_widgets[] = {
@@ -1791,11 +1737,12 @@ SND_SOC_DAPM_ADC("DMIC2R", NULL, WM8994_POWER_MANAGEMENT_4, 4, 0),
 SND_SOC_DAPM_ADC("DMIC1L", NULL, WM8994_POWER_MANAGEMENT_4, 3, 0),
 SND_SOC_DAPM_ADC("DMIC1R", NULL, WM8994_POWER_MANAGEMENT_4, 2, 0),
 
-SND_SOC_DAPM_ADC("ADCL", NULL, WM8994_POWER_MANAGEMENT_4, 1, 0),
-SND_SOC_DAPM_ADC("ADCR", NULL, WM8994_POWER_MANAGEMENT_4, 0, 0),
-
-SND_SOC_DAPM_MUX("AIF1 Loopback", SND_SOC_NOPM, 0, 0, &aif1_loopback),
-SND_SOC_DAPM_MUX("AIF2 Loopback", SND_SOC_NOPM, 0, 0, &aif2_loopback),
+/* Power is done with the muxes since the ADC power also controls the
+ * downsampling chain, the chip will automatically manage the analogue
+ * specific portions.
+ */
+SND_SOC_DAPM_ADC("ADCL", NULL, SND_SOC_NOPM, 1, 0),
+SND_SOC_DAPM_ADC("ADCR", NULL, SND_SOC_NOPM, 0, 0),
 
 SND_SOC_DAPM_POST("Debug log", post_ev),
 };
@@ -1928,9 +1875,9 @@ static const struct snd_soc_dapm_route intercon[] = {
 	{ "AIF1DAC2L", NULL, "AIF1DAC Mux" },
 	{ "AIF1DAC2R", NULL, "AIF1DAC Mux" },
 
-	{ "AIF1DAC Mux", "AIF1DACDAT", "AIF1 Loopback" },
+	{ "AIF1DAC Mux", "AIF1DACDAT", "AIF1DACDAT" },
 	{ "AIF1DAC Mux", "AIF3DACDAT", "AIF3DACDAT" },
-	{ "AIF2DAC Mux", "AIF2DACDAT", "AIF2 Loopback" },
+	{ "AIF2DAC Mux", "AIF2DACDAT", "AIF2DACDAT" },
 	{ "AIF2DAC Mux", "AIF3DACDAT", "AIF3DACDAT" },
 	{ "AIF2ADC Mux", "AIF2ADCDAT", "AIF2ADCL" },
 	{ "AIF2ADC Mux", "AIF2ADCDAT", "AIF2ADCR" },
@@ -1981,12 +1928,6 @@ static const struct snd_soc_dapm_route intercon[] = {
 	{ "AIF3ADCDAT", "AIF2DACDAT", "AIF2DACL" },
 	{ "AIF3ADCDAT", "AIF2DACDAT", "AIF2DACR" },
 
-	/* Loopback */
-	{ "AIF1 Loopback", "ADCDAT", "AIF1ADCDAT" },
-	{ "AIF1 Loopback", "None", "AIF1DACDAT" },
-	{ "AIF2 Loopback", "ADCDAT", "AIF2ADCDAT" },
-	{ "AIF2 Loopback", "None", "AIF2DACDAT" },
-
 	/* Sidetone */
 	{ "Left Sidetone", "ADC/DMIC1", "ADCL Mux" },
 	{ "Left Sidetone", "DMIC2", "DMIC2L" },
@@ -2069,16 +2010,15 @@ struct fll_div {
 	u16 outdiv;
 	u16 n;
 	u16 k;
-	u16 lambda;
 	u16 clk_ref_div;
 	u16 fll_fratio;
 };
 
-static int wm8994_get_fll_config(struct wm8994 *control, struct fll_div *fll,
+static int wm8994_get_fll_config(struct fll_div *fll,
 				 int freq_in, int freq_out)
 {
 	u64 Kpart;
-	unsigned int K, Ndiv, Nmod, gcd_fll;
+	unsigned int K, Ndiv, Nmod;
 
 	pr_debug("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);
 
@@ -2127,32 +2067,20 @@ static int wm8994_get_fll_config(struct wm8994 *control, struct fll_div *fll,
 	Nmod = freq_out % freq_in;
 	pr_debug("Nmod=%d\n", Nmod);
 
-	switch (control->type) {
-	case WM8994:
-		/* Calculate fractional part - scale up so we can round. */
-		Kpart = FIXED_FLL_SIZE * (long long)Nmod;
-
-		do_div(Kpart, freq_in);
-
-		K = Kpart & 0xFFFFFFFF;
+	/* Calculate fractional part - scale up so we can round. */
+	Kpart = FIXED_FLL_SIZE * (long long)Nmod;
 
-		if ((K % 10) >= 5)
-			K += 5;
+	do_div(Kpart, freq_in);
 
-		/* Move down to proper range now rounding is done */
-		fll->k = K / 10;
-		fll->lambda = 0;
+	K = Kpart & 0xFFFFFFFF;
 
-		pr_debug("N=%x K=%x\n", fll->n, fll->k);
-		break;
+	if ((K % 10) >= 5)
+		K += 5;
 
-	default:
-		gcd_fll = gcd(freq_out, freq_in);
+	/* Move down to proper range now rounding is done */
+	fll->k = K / 10;
 
-		fll->k = (freq_out - (freq_in * fll->n)) / gcd_fll;
-		fll->lambda = freq_in / gcd_fll;
-		
-	}
+	pr_debug("N=%x K=%x\n", fll->n, fll->k);
 
 	return 0;
 }
@@ -2216,9 +2144,9 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 	 * analysis bugs spewing warnings.
 	 */
 	if (freq_out)
-		ret = wm8994_get_fll_config(control, &fll, freq_in, freq_out);
+		ret = wm8994_get_fll_config(&fll, freq_in, freq_out);
 	else
-		ret = wm8994_get_fll_config(control, &fll, wm8994->fll[id].in,
+		ret = wm8994_get_fll_config(&fll, wm8994->fll[id].in,
 					    wm8994->fll[id].out);
 	if (ret < 0)
 		return ret;
@@ -2263,17 +2191,6 @@ static int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,
 			    WM8994_FLL1_N_MASK,
 			    fll.n << WM8994_FLL1_N_SHIFT);
 
-	if (fll.lambda) {
-		snd_soc_update_bits(codec, WM8958_FLL1_EFS_1 + reg_offset,
-				    WM8958_FLL1_LAMBDA_MASK,
-				    fll.lambda);
-		snd_soc_update_bits(codec, WM8958_FLL1_EFS_2 + reg_offset,
-				    WM8958_FLL1_EFS_ENA, WM8958_FLL1_EFS_ENA);
-	} else {
-		snd_soc_update_bits(codec, WM8958_FLL1_EFS_2 + reg_offset,
-				    WM8958_FLL1_EFS_ENA, 0);
-	}
-
 	snd_soc_update_bits(codec, WM8994_FLL1_CONTROL_5 + reg_offset,
 			    WM8994_FLL1_FRC_NCO | WM8958_FLL1_BYP |
 			    WM8994_FLL1_REFCLK_DIV_MASK |
@@ -2354,8 +2271,7 @@ out:
 	 * If SYSCLK will be less than 50kHz adjust AIFnCLK dividers
 	 * for detection.
 	 */
-	if (max(wm8994->aifclk[0], wm8994->aifclk[1]) < 50000 &&
-		!wm8994->aifdiv[0]) {
+	if (max(wm8994->aifclk[0], wm8994->aifclk[1]) < 50000) {
 		dev_dbg(codec->dev, "Configuring AIFs for 128fs\n");
 
 		wm8994->aifdiv[0] = snd_soc_read(codec, WM8994_AIF1_RATE)
@@ -2639,24 +2555,17 @@ static int wm8994_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	struct wm8994 *control = wm8994->wm8994;
 	int ms_reg;
 	int aif1_reg;
-	int dac_reg;
-	int adc_reg;
 	int ms = 0;
 	int aif1 = 0;
-	int lrclk = 0;
 
 	switch (dai->id) {
 	case 1:
 		ms_reg = WM8994_AIF1_MASTER_SLAVE;
 		aif1_reg = WM8994_AIF1_CONTROL_1;
-		dac_reg = WM8994_AIF1DAC_LRCLK;
-		adc_reg = WM8994_AIF1ADC_LRCLK;
 		break;
 	case 2:
 		ms_reg = WM8994_AIF2_MASTER_SLAVE;
 		aif1_reg = WM8994_AIF2_CONTROL_1;
-		dac_reg = WM8994_AIF1DAC_LRCLK;
-		adc_reg = WM8994_AIF1ADC_LRCLK;
 		break;
 	default:
 		return -EINVAL;
@@ -2675,7 +2584,6 @@ static int wm8994_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_DSP_B:
 		aif1 |= WM8994_AIF1_LRCLK_INV;
-		lrclk |= WM8958_AIF1_LRCLK_INV;
 	case SND_SOC_DAIFMT_DSP_A:
 		aif1 |= 0x18;
 		break;
@@ -2714,14 +2622,12 @@ static int wm8994_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 			break;
 		case SND_SOC_DAIFMT_IB_IF:
 			aif1 |= WM8994_AIF1_BCLK_INV | WM8994_AIF1_LRCLK_INV;
-			lrclk |= WM8958_AIF1_LRCLK_INV;
 			break;
 		case SND_SOC_DAIFMT_IB_NF:
 			aif1 |= WM8994_AIF1_BCLK_INV;
 			break;
 		case SND_SOC_DAIFMT_NB_IF:
 			aif1 |= WM8994_AIF1_LRCLK_INV;
-			lrclk |= WM8958_AIF1_LRCLK_INV;
 			break;
 		default:
 			return -EINVAL;
@@ -2752,10 +2658,6 @@ static int wm8994_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 			    aif1);
 	snd_soc_update_bits(codec, ms_reg, WM8994_AIF1_MSTR,
 			    ms);
-	snd_soc_update_bits(codec, dac_reg,
-			    WM8958_AIF1_LRCLK_INV, lrclk);
-	snd_soc_update_bits(codec, adc_reg,
-			    WM8958_AIF1_LRCLK_INV, lrclk);
 
 	return 0;
 }
@@ -2804,40 +2706,9 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 	int lrclk = 0;
 	int rate_val = 0;
 	int id = dai->id - 1;
-	struct snd_pcm_hw_params hw_params;
 
 	int i, cur_val, best_val, bclk_rate, best;
 
-	if (params)
-		memcpy(&hw_params, params, sizeof(*params));
-	else
-		return -EINVAL;
-
-	/* If custom params are there, override to custom params */
-	if (pdata->custom_cfg) {
-
-		dev_dbg(codec->dev, "%s: Overriding to custom params....\n",
-							__func__);
-
-		snd_mask_none(hw_param_mask(&hw_params,
-					SNDRV_PCM_HW_PARAM_FORMAT));
-		snd_mask_set(hw_param_mask(&hw_params,
-					SNDRV_PCM_HW_PARAM_FORMAT),
-					pdata->custom_cfg->format);
-
-		hw_param_interval(&hw_params, SNDRV_PCM_HW_PARAM_RATE)->min =
-						pdata->custom_cfg->rate;
-		hw_param_interval(&hw_params, SNDRV_PCM_HW_PARAM_RATE)->max =
-						pdata->custom_cfg->rate;
-
-		hw_param_interval(&hw_params,
-					SNDRV_PCM_HW_PARAM_CHANNELS)->min =
-						pdata->custom_cfg->channels;
-		hw_param_interval(&hw_params,
-					SNDRV_PCM_HW_PARAM_CHANNELS)->max =
-						pdata->custom_cfg->channels;
-	}
-
 	switch (dai->id) {
 	case 1:
 		aif1_reg = WM8994_AIF1_CONTROL_1;
@@ -2869,9 +2740,8 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	bclk_rate = params_rate(&hw_params);
-
-	switch (params_format(&hw_params)) {
+	bclk_rate = params_rate(params);
+	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
 		bclk_rate *= 16;
 		break;
@@ -2891,7 +2761,7 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	wm8994->channels[id] = params_channels(&hw_params);
+	wm8994->channels[id] = params_channels(params);
 	if (pdata->max_channels_clocked[id] &&
 	    wm8994->channels[id] > pdata->max_channels_clocked[id]) {
 		dev_dbg(dai->dev, "Constraining channels to %d from %d\n",
@@ -2911,7 +2781,7 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 
 	/* Try to find an appropriate sample rate; look for an exact match. */
 	for (i = 0; i < ARRAY_SIZE(srs); i++)
-		if (srs[i].rate == params_rate(&hw_params))
+		if (srs[i].rate == params_rate(params))
 			break;
 	if (i == ARRAY_SIZE(srs))
 		return -EINVAL;
@@ -2932,10 +2802,10 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 
 	/* AIFCLK/fs ratio; look for a close match in either direction */
 	best = 0;
-	best_val = abs((fs_ratios[0] * params_rate(&hw_params))
+	best_val = abs((fs_ratios[0] * params_rate(params))
 		       - wm8994->aifclk[id]);
 	for (i = 1; i < ARRAY_SIZE(fs_ratios); i++) {
-		cur_val = abs((fs_ratios[i] * params_rate(&hw_params))
+		cur_val = abs((fs_ratios[i] * params_rate(params))
 			      - wm8994->aifclk[id]);
 		if (cur_val >= best_val)
 			continue;
@@ -2963,7 +2833,7 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		bclk_divs[best], bclk_rate);
 	bclk |= best << WM8994_AIF1_BCLK_DIV_SHIFT;
 
-	lrclk = bclk_rate / params_rate(&hw_params);
+	lrclk = bclk_rate / params_rate(params);
 	if (!lrclk) {
 		dev_err(dai->dev, "Unable to generate LRCLK from %dHz BCLK\n",
 			bclk_rate);
@@ -2983,12 +2853,12 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		switch (dai->id) {
 		case 1:
-			wm8994->dac_rates[0] = params_rate(&hw_params);
+			wm8994->dac_rates[0] = params_rate(params);
 			wm8994_set_retune_mobile(codec, 0);
 			wm8994_set_retune_mobile(codec, 1);
 			break;
 		case 2:
-			wm8994->dac_rates[1] = params_rate(&hw_params);
+			wm8994->dac_rates[1] = params_rate(params);
 			wm8994_set_retune_mobile(codec, 2);
 			break;
 		}
@@ -3041,13 +2911,6 @@ static int wm8994_aif3_hw_params(struct snd_pcm_substream *substream,
 	return snd_soc_update_bits(codec, aif1_reg, WM8994_AIF1_WL_MASK, aif1);
 }
 
-#if IS_ENABLED(CONFIG_SND_MRFLD_MACHINE) || \
-	IS_ENABLED(CONFIG_SND_MOOR_MACHINE)
-static int wm8994_aif_mute(struct snd_soc_dai *codec_dai, int mute)
-{
-	return 0;
-}
-#else
 static int wm8994_aif_mute(struct snd_soc_dai *codec_dai, int mute)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
@@ -3074,7 +2937,6 @@ static int wm8994_aif_mute(struct snd_soc_dai *codec_dai, int mute)
 
 	return 0;
 }
-#endif
 
 static int wm8994_set_tristate(struct snd_soc_dai *codec_dai, int tristate)
 {
@@ -3102,25 +2964,6 @@ static int wm8994_set_tristate(struct snd_soc_dai *codec_dai, int tristate)
 	return snd_soc_update_bits(codec, reg, mask, val);
 }
 
-static int wm8994_set_tdm_slots(struct snd_soc_dai *dai,
-	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
-{
-	struct snd_soc_codec *codec = dai->codec;
-	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-	struct wm8994 *control = wm8994->wm8994;
-
-	switch (control->type) {
-	case WM8958:
-		wm8994->slots = slots;
-		break;
-	default:
-		pr_err("we dont support tdm for non 8958!");
-		return -EINVAL;
-		break;
-	}
-	return 0;
-}
-
 static int wm8994_aif2_probe(struct snd_soc_dai *dai)
 {
 	struct snd_soc_codec *codec = dai->codec;
@@ -3148,7 +2991,6 @@ static const struct snd_soc_dai_ops wm8994_aif1_dai_ops = {
 	.digital_mute	= wm8994_aif_mute,
 	.set_pll	= wm8994_set_fll,
 	.set_tristate	= wm8994_set_tristate,
-	.set_tdm_slot	= wm8994_set_tdm_slots,
 };
 
 static const struct snd_soc_dai_ops wm8994_aif2_dai_ops = {
@@ -3254,7 +3096,24 @@ static int wm8994_codec_suspend(struct snd_soc_codec *codec)
 static int wm8994_codec_resume(struct snd_soc_codec *codec)
 {
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
+	struct wm8994 *control = wm8994->wm8994;
 	int i, ret;
+	unsigned int val, mask;
+
+	if (control->revision < 4) {
+		/* force a HW read */
+		ret = regmap_read(control->regmap,
+				  WM8994_POWER_MANAGEMENT_5, &val);
+
+		/* modify the cache only */
+		codec->cache_only = 1;
+		mask =  WM8994_DAC1R_ENA | WM8994_DAC1L_ENA |
+			WM8994_DAC2R_ENA | WM8994_DAC2L_ENA;
+		val &= mask;
+		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,
+				    mask, val);
+		codec->cache_only = 0;
+	}
 
 	for (i = 0; i < ARRAY_SIZE(wm8994->fll); i++) {
 		if (!wm8994->fll_suspend[i].out)
@@ -3636,32 +3495,6 @@ static void wm8958_button_det(struct snd_soc_codec *codec, u16 status)
 			    wm8994->btn_mask);
 }
 
-static void wm8958_open_circuit_work(struct work_struct *work)
-{
-	struct wm8994_priv *wm8994 = container_of(work,
-						  struct wm8994_priv,
-						  open_circuit_work.work);
-	struct device *dev = wm8994->wm8994->dev;
-
-	wm1811_micd_stop(wm8994->hubs.codec);
-
-	mutex_lock(&wm8994->accdet_lock);
-
-	dev_dbg(dev, "Reporting open circuit\n");
-
-	wm8994->jack_mic = false;
-	wm8994->mic_detecting = true;
-	wm8994->headphone_detected = false;
-
-	wm8958_micd_set_rate(wm8994->hubs.codec);
-
-	snd_soc_jack_report(wm8994->micdet[0].jack, 0,
-			    wm8994->btn_mask |
-			    SND_JACK_HEADSET);
-
-	mutex_unlock(&wm8994->accdet_lock);
-}
-
 static void wm8958_mic_id(void *data, u16 status)
 {
 	struct snd_soc_codec *codec = data;
@@ -3671,9 +3504,16 @@ static void wm8958_mic_id(void *data, u16 status)
 	if (!(status & WM8958_MICD_STS)) {
 		/* If nothing present then clear our statuses */
 		dev_dbg(codec->dev, "Detected open circuit\n");
+		wm8994->jack_mic = false;
+		wm8994->mic_detecting = true;
+
+		wm1811_micd_stop(codec);
 
-		schedule_delayed_work(&wm8994->open_circuit_work,
-				      msecs_to_jiffies(2500));
+		wm8958_micd_set_rate(codec);
+
+		snd_soc_jack_report(wm8994->micdet[0].jack, 0,
+				    wm8994->btn_mask |
+				    SND_JACK_HEADSET);
 		return;
 	}
 
@@ -3728,8 +3568,10 @@ static void wm1811_mic_work(struct work_struct *work)
 
 	dev_dbg(codec->dev, "Starting mic detection\n");
 
-	/* If there's a callback it'll be called out of the lock */
-	if (!wm8994->micd_cb) {
+	/* Use a user-supplied callback if we have one */
+	if (wm8994->micd_cb) {
+		wm8994->micd_cb(wm8994->micd_cb_data);
+	} else {
 		/*
 		 * Start off measument of microphone impedence to find out
 		 * what's actually there.
@@ -3743,10 +3585,6 @@ static void wm1811_mic_work(struct work_struct *work)
 
 	mutex_unlock(&wm8994->accdet_lock);
 
-	/* Custom callbacks may reasonably wish to take the same locks */
-	if (wm8994->micd_cb)
-		wm8994->micd_cb(wm8994->micd_cb_data);
-
 	pm_runtime_put(codec->dev);
 }
 
@@ -3758,12 +3596,8 @@ static irqreturn_t wm1811_jackdet_irq(int irq, void *data)
 	int reg, delay;
 	bool present;
 
-	cancel_delayed_work_sync(&wm8994->mic_work);
-
 	pm_runtime_get_sync(codec->dev);
 
-	cancel_delayed_work_sync(&wm8994->mic_complete_work);
-
 	mutex_lock(&wm8994->accdet_lock);
 
 	reg = snd_soc_read(codec, WM1811_JACKDET_CTRL);
@@ -3796,6 +3630,8 @@ static irqreturn_t wm1811_jackdet_irq(int irq, void *data)
 	} else {
 		dev_dbg(codec->dev, "Jack not detected\n");
 
+		cancel_delayed_work_sync(&wm8994->mic_work);
+
 		snd_soc_update_bits(codec, WM8958_MICBIAS2,
 				    WM8958_MICB2_DISCH, WM8958_MICB2_DISCH);
 
@@ -3884,7 +3720,6 @@ int wm8958_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 		} else {
 			wm8994->mic_detecting = true;
 			wm8994->jack_mic = false;
-			wm8994->headphone_detected = false;
 		}
 
 		if (id_cb) {
@@ -3945,70 +3780,11 @@ int wm8958_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 }
 EXPORT_SYMBOL_GPL(wm8958_mic_detect);
 
-int wm8958_micd_set_custom_rate(struct snd_soc_codec *codec,
-		wm8958_micd_set_custom_rate_cb micd_custom_rate_cb,
-		void *micd_custom_rate_cb_data)
-{
-	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
-
-	if (micd_custom_rate_cb) {
-		wm8994->micd_custom_rate_cb = micd_custom_rate_cb;
-		wm8994->micd_custom_rate_cb_data = micd_custom_rate_cb_data;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(wm8958_micd_set_custom_rate);
-
-static void wm8958_mic_work(struct work_struct *work)
-{
-	struct wm8994_priv *wm8994 = container_of(work,
-						  struct wm8994_priv,
-						  mic_complete_work.work);
-	struct snd_soc_codec *codec = wm8994->hubs.codec;
-
-	dev_crit(codec->dev, "MIC WORK %x\n", wm8994->mic_status);
-
-	pm_runtime_get_sync(codec->dev);
-
-	mutex_lock(&wm8994->accdet_lock);
-
-	wm8994->mic_id_cb(wm8994->mic_id_cb_data, wm8994->mic_status);
-
-	mutex_unlock(&wm8994->accdet_lock);
-
-	pm_runtime_put(codec->dev);
-
-	dev_crit(codec->dev, "MIC WORK %x DONE\n", wm8994->mic_status);
-}
-
-static void wm8958_micd_set_custom_rate_work(struct work_struct *work)
-{
-	struct wm8994_priv *wm8994 = container_of(work,
-						  struct wm8994_priv,
-						  micd_set_custom_rate_work.work);
-	struct snd_soc_codec *codec = wm8994->hubs.codec;
-
-	dev_dbg(codec->dev, "%s: Set custom rates\n", __func__);
-
-	pm_runtime_get_sync(codec->dev);
-
-	mutex_lock(&wm8994->accdet_lock);
-
-	wm8994->micd_custom_rate_cb(wm8994->micd_custom_rate_cb_data);
-
-	mutex_unlock(&wm8994->accdet_lock);
-
-	pm_runtime_put(codec->dev);
-
-}
-
 static irqreturn_t wm8958_mic_irq(int irq, void *data)
 {
 	struct wm8994_priv *wm8994 = data;
 	struct snd_soc_codec *codec = wm8994->hubs.codec;
-	struct wm8994 *control = wm8994->wm8994;
-	int reg, count, ret, id_delay;
+	int reg, count, ret;
 
 	/*
 	 * Jack detection may have detected a removal simulataneously
@@ -4018,9 +3794,6 @@ static irqreturn_t wm8958_mic_irq(int irq, void *data)
 	if (!(snd_soc_read(codec, WM8958_MIC_DETECT_1) & WM8958_MICD_ENA))
 		return IRQ_HANDLED;
 
-	cancel_delayed_work_sync(&wm8994->mic_complete_work);
-	cancel_delayed_work_sync(&wm8994->open_circuit_work);
-
 	pm_runtime_get_sync(codec->dev);
 
 	/* We may occasionally read a detection without an impedence
@@ -4069,30 +3842,14 @@ static irqreturn_t wm8958_mic_irq(int irq, void *data)
 		snd_soc_jack_report(wm8994->micdet[0].jack, 0,
 				    SND_JACK_MECHANICAL | SND_JACK_HEADSET |
 				    wm8994->btn_mask);
-		wm8994->jack_mic = false;
-		wm8994->headphone_detected = false;
 		wm8994->mic_detecting = true;
 		goto out;
 	}
 
-	wm8994->mic_status = reg;
-	id_delay = wm8994->wm8994->pdata.mic_id_delay;
-
-	if (wm8994->mic_detecting) {
-		if (control->type == WM8958) {
-			/* Set mic-bias high during detection phase (micb_en_delay) */
-			/* 0 == Continuous */
-			dev_dbg(codec->dev, "Set MICBIAS High, for micb_en_delay time\n");
-			snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
-				    WM8958_MICD_BIAS_STARTTIME_MASK |
-				    WM8958_MICD_RATE_MASK, 0);
-		}
-
-		schedule_delayed_work(&wm8994->mic_complete_work,
-				      msecs_to_jiffies(id_delay));
-	} else {
+	if (wm8994->mic_detecting)
+		wm8994->mic_id_cb(wm8994->mic_id_cb_data, reg);
+	else
 		wm8958_button_det(codec, reg);
-	}
 
 out:
 	pm_runtime_put(codec->dev);
@@ -4131,7 +3888,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	struct wm8994 *control = dev_get_drvdata(codec->dev->parent);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct snd_soc_dapm_context *dapm = &codec->dapm;
-	unsigned int dcs_done_irq;
 	unsigned int reg;
 	int ret, i;
 
@@ -4143,8 +3899,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	mutex_init(&wm8994->accdet_lock);
 	INIT_DELAYED_WORK(&wm8994->jackdet_bootstrap,
 			  wm1811_jackdet_bootstrap);
-	INIT_DELAYED_WORK(&wm8994->open_circuit_work,
-			  wm8958_open_circuit_work);
 
 	switch (control->type) {
 	case WM8994:
@@ -4153,16 +3907,10 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	case WM1811:
 		INIT_DELAYED_WORK(&wm8994->mic_work, wm1811_mic_work);
 		break;
-	case WM8958:
-		INIT_DELAYED_WORK(&wm8994->micd_set_custom_rate_work,
-					wm8958_micd_set_custom_rate_work);
-		break;
 	default:
 		break;
 	}
 
-	INIT_DELAYED_WORK(&wm8994->mic_complete_work, wm8958_mic_work);
-
 	for (i = 0; i < ARRAY_SIZE(wm8994->fll_locked); i++)
 		init_completion(&wm8994->fll_locked[i]);
 
@@ -4235,9 +3983,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	wm8994_request_irq(wm8994->wm8994, WM8994_IRQ_TEMP_SHUT,
 			   wm8994_temp_shut, "Thermal shutdown", codec);
 
-	dcs_done_irq = regmap_irq_get_virq(wm8994->wm8994->irq_data,
-					   WM8994_IRQ_DCS_DONE);
-	irq_set_status_flags(dcs_done_irq, IRQ_NOAUTOEN);
 	ret = wm8994_request_irq(wm8994->wm8994, WM8994_IRQ_DCS_DONE,
 				 wm_hubs_dcs_done, "DC servo done",
 				 &wm8994->hubs);
@@ -4344,6 +4089,7 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	}
 	if ((reg & WM8994_GPN_FN_MASK) != WM8994_GP_FN_PIN_SPECIFIC) {
 		wm8994->lrclk_shared[0] = 1;
+		wm8994_dai[0].symmetric_rates = 1;
 	} else {
 		wm8994->lrclk_shared[0] = 0;
 	}
@@ -4473,7 +4219,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	}
 
 	wm_hubs_add_analogue_routes(codec, 0, 0);
-	enable_irq(dcs_done_irq);
 	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
 
 	switch (control->type) {
@@ -4516,11 +4261,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 		break;
 	}
 
-	/* Make sure FIFO errors are masked */
-	snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2_MASK,
-			    WM8994_IM_FIFOS_ERR_EINT_MASK,
-			    1 << WM8994_IM_FIFOS_ERR_EINT_SHIFT);
-
 	return 0;
 
 err_irq:
@@ -4625,11 +4365,6 @@ static int wm8994_remove(struct platform_device *pdev)
 static int wm8994_suspend(struct device *dev)
 {
 	struct wm8994_priv *wm8994 = dev_get_drvdata(dev);
-	struct wm8994 *control = wm8994->wm8994;
-	struct snd_soc_codec *codec = wm8994->hubs.codec;
-	unsigned int reg;
-	int ret;
-
 
 	/* Drop down to power saving mode when system is suspended */
 	if (wm8994->jackdet && !wm8994->active_refcount)
@@ -4637,62 +4372,18 @@ static int wm8994_suspend(struct device *dev)
 				   WM1811_JACKDET_MODE_MASK,
 				   wm8994->jackdet_mode);
 
-	/* Disable the MIC Detection when suspended */
-	if ((control->type == WM8958) && wm8994->mic_id_cb) {
-
-		reg = snd_soc_read(codec, WM8958_MIC_DETECT_3);
-
-		dev_dbg(codec->dev, "%s: WM8958_MIC_DETECT_3 0x%x\n", __func__, reg);
-		dev_dbg(codec->dev, "mic_detect %d jack_mic %d headphone %d\n",
-					wm8994->mic_detecting, wm8994->jack_mic,
-					wm8994->headphone_detected);
-
-		if (!(wm8994->jack_mic) && !(wm8994->headphone_detected)) {
-
-			dev_dbg(codec->dev, "Jack not connected..Mask interrupt\n");
-			snd_soc_write(codec, WM8994_INTERRUPT_CONTROL, 0x01);
-
-			ret = regcache_sync_region(wm8994->wm8994->regmap,
-					WM8994_INTERRUPT_CONTROL,
-					WM8994_INTERRUPT_CONTROL);
-			if (ret != 0)
-				dev_err(dev, "Failed to sync register: %d\n", ret);
-			synchronize_irq(control->irq);
-
-			dev_dbg(codec->dev, "Disable MIC Detection!!!\n");
-			snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
-						WM8958_MICD_ENA, 0);
-
-			snd_soc_dapm_disable_pin(&codec->dapm, "CLK_SYS");
-			snd_soc_dapm_sync(&codec->dapm);
-		}
-	}
-
 	return 0;
 }
 
 static int wm8994_resume(struct device *dev)
 {
 	struct wm8994_priv *wm8994 = dev_get_drvdata(dev);
-	struct wm8994 *control = wm8994->wm8994;
-	struct snd_soc_codec *codec = wm8994->hubs.codec;
 
 	if (wm8994->jackdet && wm8994->jackdet_mode)
 		regmap_update_bits(wm8994->wm8994->regmap, WM8994_ANTIPOP_2,
 				   WM1811_JACKDET_MODE_MASK,
 				   WM1811_JACKDET_MODE_AUDIO);
 
-	/* Enable the MIC Detection when resumed */
-	if ((control->type == WM8958) && wm8994->mic_id_cb) {
-		dev_dbg(codec->dev, "Enable MIC Detection!!!\n");
-		snd_soc_dapm_force_enable_pin(&codec->dapm, "CLK_SYS");
-		snd_soc_dapm_sync(&codec->dapm);
-
-		snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
-					WM8958_MICD_ENA, WM8958_MICD_ENA);
-		snd_soc_write(codec, WM8994_INTERRUPT_CONTROL, 0x00);
-	}
-
 	return 0;
 }
 #endif
diff --git a/sound/soc/codecs/wm8994.h b/sound/soc/codecs/wm8994.h
index 0a834df..55ddf4d 100644
--- a/sound/soc/codecs/wm8994.h
+++ b/sound/soc/codecs/wm8994.h
@@ -41,7 +41,6 @@ enum wm8994_vmid_mode {
 
 typedef void (*wm1811_micdet_cb)(void *data);
 typedef void (*wm1811_mic_id_cb)(void *data, u16 status);
-typedef void (*wm8958_micd_set_custom_rate_cb)(struct snd_soc_codec *codec);
 
 int wm8994_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 		      int micbias);
@@ -56,10 +55,6 @@ int wm8958_aif_ev(struct snd_soc_dapm_widget *w,
 
 void wm8958_dsp2_init(struct snd_soc_codec *codec);
 
-int wm8958_micd_set_custom_rate(struct snd_soc_codec *codec,
-			wm8958_micd_set_custom_rate_cb micd_custom_rate_cb,
-			void *micd_custom_rate_cb_data);
-
 struct wm8994_micdet {
 	struct snd_soc_jack *jack;
 	bool detecting;
@@ -91,7 +86,6 @@ struct wm8994_priv {
 	bool fll_locked_irq;
 	bool fll_byp;
 	bool clk_has_run;
-	int slots;
 
 	int vmid_refcount;
 	int active_refcount;
@@ -140,14 +134,8 @@ struct wm8994_priv {
 	struct mutex accdet_lock;
 	struct wm8994_micdet micdet[2];
 	struct delayed_work mic_work;
-	struct delayed_work open_circuit_work;
-	struct delayed_work mic_complete_work;
-	struct delayed_work micd_set_custom_rate_work;
-
-	u16 mic_status;
 	bool mic_detecting;
 	bool jack_mic;
-	bool headphone_detected;
 	int btn_mask;
 	bool jackdet;
 	int jackdet_mode;
@@ -158,8 +146,6 @@ struct wm8994_priv {
 	void *micd_cb_data;
 	wm1811_mic_id_cb mic_id_cb;
 	void *mic_id_cb_data;
-	wm8958_micd_set_custom_rate_cb micd_custom_rate_cb;
-	void *micd_custom_rate_cb_data;
 
 	unsigned int aif1clk_enable:1;
 	unsigned int aif2clk_enable:1;
diff --git a/sound/soc/codecs/wm_hubs.c b/sound/soc/codecs/wm_hubs.c
index 2874ec9..f5d81b9 100644
--- a/sound/soc/codecs/wm_hubs.c
+++ b/sound/soc/codecs/wm_hubs.c
@@ -530,7 +530,6 @@ static int hp_supply_event(struct snd_soc_dapm_widget *w,
 				hubs->hp_startup_mode);
 			break;
 		}
-		break;
 
 	case SND_SOC_DAPM_PRE_PMD:
 		snd_soc_update_bits(codec, WM8993_CHARGE_PUMP_1,
@@ -1223,6 +1222,11 @@ int wm_hubs_handle_analogue_pdata(struct snd_soc_codec *codec,
 				    WM8993_LINEOUT2_MODE,
 				    WM8993_LINEOUT2_MODE);
 
+	if (!lineout1_diff && !lineout2_diff)
+		snd_soc_update_bits(codec, WM8993_ANTIPOP1,
+				    WM8993_LINEOUT_VMID_BUF_ENA,
+				    WM8993_LINEOUT_VMID_BUF_ENA);
+
 	if (lineout1fb)
 		snd_soc_update_bits(codec, WM8993_ADDITIONAL_CONTROL,
 				    WM8993_LINEOUT1_FB, WM8993_LINEOUT1_FB);
@@ -1248,13 +1252,6 @@ void wm_hubs_vmid_ena(struct snd_soc_codec *codec)
 	struct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);
 	int val = 0;
 
-	if ((hubs->lineout1_se && hubs->lineout2_se) &&
-			(hubs->lineout1n_ena  || hubs->lineout1p_ena ||
-			hubs->lineout2n_ena || hubs->lineout2p_ena))
-		snd_soc_update_bits(codec, WM8993_ANTIPOP1,
-			WM8993_LINEOUT_VMID_BUF_ENA,
-			WM8993_LINEOUT_VMID_BUF_ENA);
-
 	if (hubs->lineout1_se)
 		val |= WM8993_LINEOUT1N_ENA | WM8993_LINEOUT1P_ENA;
 
@@ -1284,13 +1281,6 @@ void wm_hubs_set_bias_level(struct snd_soc_codec *codec,
 		val = 0;
 		mask = 0;
 
-		if ((hubs->lineout1_se && hubs->lineout2_se) &&
-				(hubs->lineout1n_ena  || hubs->lineout1p_ena ||
-				hubs->lineout2n_ena || hubs->lineout2p_ena))
-			snd_soc_update_bits(codec, WM8993_ANTIPOP1,
-				WM8993_LINEOUT_VMID_BUF_ENA,
-				WM8993_LINEOUT_VMID_BUF_ENA);
-
 		if (hubs->lineout1_se)
 			mask |= WM8993_LINEOUT1N_ENA | WM8993_LINEOUT1P_ENA;
 
diff --git a/sound/soc/mid-x86/Kconfig b/sound/soc/mid-x86/Kconfig
new file mode 100644
index 0000000..61c10bf
--- /dev/null
+++ b/sound/soc/mid-x86/Kconfig
@@ -0,0 +1,13 @@
+config SND_MFLD_MACHINE
+	tristate "SOC Machine Audio driver for Intel Medfield MID platform"
+	depends on INTEL_SCU_IPC
+	select SND_SOC_SN95031
+	select SND_SST_PLATFORM
+	help
+          This adds support for ASoC machine driver for Intel(R) MID Medfield platform
+          used as alsa device in audio substem in Intel(R) MID devices
+          Say Y if you have such a device
+          If unsure select "N".
+
+config SND_SST_PLATFORM
+	tristate
diff --git a/sound/soc/mid-x86/Makefile b/sound/soc/mid-x86/Makefile
new file mode 100644
index 0000000..6398833
--- /dev/null
+++ b/sound/soc/mid-x86/Makefile
@@ -0,0 +1,5 @@
+snd-soc-sst-platform-objs := sst_platform.o
+snd-soc-mfld-machine-objs := mfld_machine.o
+
+obj-$(CONFIG_SND_SST_PLATFORM) += snd-soc-sst-platform.o
+obj-$(CONFIG_SND_MFLD_MACHINE) += snd-soc-mfld-machine.o
diff --git a/sound/soc/mid-x86/mfld_machine.c b/sound/soc/mid-x86/mfld_machine.c
new file mode 100644
index 0000000..4139116
--- /dev/null
+++ b/sound/soc/mid-x86/mfld_machine.c
@@ -0,0 +1,447 @@
+/*
+ *  mfld_machine.c - ASoc Machine driver for Intel Medfield MID platform
+ *
+ *  Copyright (C) 2010 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include "../codecs/sn95031.h"
+
+#define MID_MONO 1
+#define MID_STEREO 2
+#define MID_MAX_CAP 5
+#define MFLD_JACK_INSERT 0x04
+
+enum soc_mic_bias_zones {
+	MFLD_MV_START = 0,
+	/* mic bias volutage range for Headphones*/
+	MFLD_MV_HP = 400,
+	/* mic bias volutage range for American Headset*/
+	MFLD_MV_AM_HS = 650,
+	/* mic bias volutage range for Headset*/
+	MFLD_MV_HS = 2000,
+	MFLD_MV_UNDEFINED,
+};
+
+static unsigned int	hs_switch;
+static unsigned int	lo_dac;
+
+struct mfld_mc_private {
+	void __iomem *int_base;
+	u8 interrupt_status;
+};
+
+struct snd_soc_jack mfld_jack;
+
+/*Headset jack detection DAPM pins */
+static struct snd_soc_jack_pin mfld_jack_pins[] = {
+	{
+		.pin = "Headphones",
+		.mask = SND_JACK_HEADPHONE,
+	},
+	{
+		.pin = "AMIC1",
+		.mask = SND_JACK_MICROPHONE,
+	},
+};
+
+/* jack detection voltage zones */
+static struct snd_soc_jack_zone mfld_zones[] = {
+	{MFLD_MV_START, MFLD_MV_AM_HS, SND_JACK_HEADPHONE},
+	{MFLD_MV_AM_HS, MFLD_MV_HS, SND_JACK_HEADSET},
+};
+
+/* sound card controls */
+static const char *headset_switch_text[] = {"Earpiece", "Headset"};
+
+static const char *lo_text[] = {"Vibra", "Headset", "IHF", "None"};
+
+static const struct soc_enum headset_enum =
+	SOC_ENUM_SINGLE_EXT(2, headset_switch_text);
+
+static const struct soc_enum lo_enum =
+	SOC_ENUM_SINGLE_EXT(4, lo_text);
+
+static int headset_get_switch(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = hs_switch;
+	return 0;
+}
+
+static int headset_set_switch(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (ucontrol->value.integer.value[0] == hs_switch)
+		return 0;
+
+	if (ucontrol->value.integer.value[0]) {
+		pr_debug("hs_set HS path\n");
+		snd_soc_dapm_enable_pin(&codec->dapm, "Headphones");
+		snd_soc_dapm_disable_pin(&codec->dapm, "EPOUT");
+	} else {
+		pr_debug("hs_set EP path\n");
+		snd_soc_dapm_disable_pin(&codec->dapm, "Headphones");
+		snd_soc_dapm_enable_pin(&codec->dapm, "EPOUT");
+	}
+	snd_soc_dapm_sync(&codec->dapm);
+	hs_switch = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static void lo_enable_out_pins(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_enable_pin(&codec->dapm, "IHFOUTL");
+	snd_soc_dapm_enable_pin(&codec->dapm, "IHFOUTR");
+	snd_soc_dapm_enable_pin(&codec->dapm, "LINEOUTL");
+	snd_soc_dapm_enable_pin(&codec->dapm, "LINEOUTR");
+	snd_soc_dapm_enable_pin(&codec->dapm, "VIB1OUT");
+	snd_soc_dapm_enable_pin(&codec->dapm, "VIB2OUT");
+	if (hs_switch) {
+		snd_soc_dapm_enable_pin(&codec->dapm, "Headphones");
+		snd_soc_dapm_disable_pin(&codec->dapm, "EPOUT");
+	} else {
+		snd_soc_dapm_disable_pin(&codec->dapm, "Headphones");
+		snd_soc_dapm_enable_pin(&codec->dapm, "EPOUT");
+	}
+}
+
+static int lo_get_switch(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = lo_dac;
+	return 0;
+}
+
+static int lo_set_switch(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (ucontrol->value.integer.value[0] == lo_dac)
+		return 0;
+
+	/* we dont want to work with last state of lineout so just enable all
+	 * pins and then disable pins not required
+	 */
+	lo_enable_out_pins(codec);
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		pr_debug("set vibra path\n");
+		snd_soc_dapm_disable_pin(&codec->dapm, "VIB1OUT");
+		snd_soc_dapm_disable_pin(&codec->dapm, "VIB2OUT");
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0);
+		break;
+
+	case 1:
+		pr_debug("set hs  path\n");
+		snd_soc_dapm_disable_pin(&codec->dapm, "Headphones");
+		snd_soc_dapm_disable_pin(&codec->dapm, "EPOUT");
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x22);
+		break;
+
+	case 2:
+		pr_debug("set spkr path\n");
+		snd_soc_dapm_disable_pin(&codec->dapm, "IHFOUTL");
+		snd_soc_dapm_disable_pin(&codec->dapm, "IHFOUTR");
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x44);
+		break;
+
+	case 3:
+		pr_debug("set null path\n");
+		snd_soc_dapm_disable_pin(&codec->dapm, "LINEOUTL");
+		snd_soc_dapm_disable_pin(&codec->dapm, "LINEOUTR");
+		snd_soc_update_bits(codec, SN95031_LOCTL, 0x66, 0x66);
+		break;
+	}
+	snd_soc_dapm_sync(&codec->dapm);
+	lo_dac = ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static const struct snd_kcontrol_new mfld_snd_controls[] = {
+	SOC_ENUM_EXT("Playback Switch", headset_enum,
+			headset_get_switch, headset_set_switch),
+	SOC_ENUM_EXT("Lineout Mux", lo_enum,
+			lo_get_switch, lo_set_switch),
+};
+
+static const struct snd_soc_dapm_widget mfld_widgets[] = {
+	SND_SOC_DAPM_HP("Headphones", NULL),
+	SND_SOC_DAPM_MIC("Mic", NULL),
+};
+
+static const struct snd_soc_dapm_route mfld_map[] = {
+	{"Headphones", NULL, "HPOUTR"},
+	{"Headphones", NULL, "HPOUTL"},
+	{"Mic", NULL, "AMIC1"},
+};
+
+static void mfld_jack_check(unsigned int intr_status)
+{
+	struct mfld_jack_data jack_data;
+
+	jack_data.mfld_jack = &mfld_jack;
+	jack_data.intr_id = intr_status;
+
+	sn95031_jack_detection(&jack_data);
+	/* TODO: add american headset detection post gpiolib support */
+}
+
+static int mfld_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_codec *codec = runtime->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	int ret_val;
+
+	/* Add jack sense widgets */
+	snd_soc_dapm_new_controls(dapm, mfld_widgets, ARRAY_SIZE(mfld_widgets));
+
+	/* Set up the map */
+	snd_soc_dapm_add_routes(dapm, mfld_map, ARRAY_SIZE(mfld_map));
+
+	/* always connected */
+	snd_soc_dapm_enable_pin(dapm, "Headphones");
+	snd_soc_dapm_enable_pin(dapm, "Mic");
+
+	ret_val = snd_soc_add_codec_controls(codec, mfld_snd_controls,
+				ARRAY_SIZE(mfld_snd_controls));
+	if (ret_val) {
+		pr_err("soc_add_controls failed %d", ret_val);
+		return ret_val;
+	}
+	/* default is earpiece pin, userspace sets it explcitly */
+	snd_soc_dapm_disable_pin(dapm, "Headphones");
+	/* default is lineout NC, userspace sets it explcitly */
+	snd_soc_dapm_disable_pin(dapm, "LINEOUTL");
+	snd_soc_dapm_disable_pin(dapm, "LINEOUTR");
+	lo_dac = 3;
+	hs_switch = 0;
+	/* we dont use linein in this so set to NC */
+	snd_soc_dapm_disable_pin(dapm, "LINEINL");
+	snd_soc_dapm_disable_pin(dapm, "LINEINR");
+
+	/* Headset and button jack detection */
+	ret_val = snd_soc_jack_new(codec, "Intel(R) MID Audio Jack",
+			SND_JACK_HEADSET | SND_JACK_BTN_0 |
+			SND_JACK_BTN_1, &mfld_jack);
+	if (ret_val) {
+		pr_err("jack creation failed\n");
+		return ret_val;
+	}
+
+	ret_val = snd_soc_jack_add_pins(&mfld_jack,
+			ARRAY_SIZE(mfld_jack_pins), mfld_jack_pins);
+	if (ret_val) {
+		pr_err("adding jack pins failed\n");
+		return ret_val;
+	}
+	ret_val = snd_soc_jack_add_zones(&mfld_jack,
+			ARRAY_SIZE(mfld_zones), mfld_zones);
+	if (ret_val) {
+		pr_err("adding jack zones failed\n");
+		return ret_val;
+	}
+
+	/* we want to check if anything is inserted at boot,
+	 * so send a fake event to codec and it will read adc
+	 * to find if anything is there or not */
+	mfld_jack_check(MFLD_JACK_INSERT);
+	return ret_val;
+}
+
+static struct snd_soc_dai_link mfld_msic_dailink[] = {
+	{
+		.name = "Medfield Headset",
+		.stream_name = "Headset",
+		.cpu_dai_name = "Headset-cpu-dai",
+		.codec_dai_name = "SN95031 Headset",
+		.codec_name = "sn95031",
+		.platform_name = "sst-platform",
+		.init = mfld_init,
+	},
+	{
+		.name = "Medfield Speaker",
+		.stream_name = "Speaker",
+		.cpu_dai_name = "Speaker-cpu-dai",
+		.codec_dai_name = "SN95031 Speaker",
+		.codec_name = "sn95031",
+		.platform_name = "sst-platform",
+		.init = NULL,
+	},
+	{
+		.name = "Medfield Vibra",
+		.stream_name = "Vibra1",
+		.cpu_dai_name = "Vibra1-cpu-dai",
+		.codec_dai_name = "SN95031 Vibra1",
+		.codec_name = "sn95031",
+		.platform_name = "sst-platform",
+		.init = NULL,
+	},
+	{
+		.name = "Medfield Haptics",
+		.stream_name = "Vibra2",
+		.cpu_dai_name = "Vibra2-cpu-dai",
+		.codec_dai_name = "SN95031 Vibra2",
+		.codec_name = "sn95031",
+		.platform_name = "sst-platform",
+		.init = NULL,
+	},
+	{
+		.name = "Medfield Compress",
+		.stream_name = "Speaker",
+		.cpu_dai_name = "Compress-cpu-dai",
+		.codec_dai_name = "SN95031 Speaker",
+		.codec_name = "sn95031",
+		.platform_name = "sst-platform",
+		.init = NULL,
+	},
+};
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_mfld = {
+	.name = "medfield_audio",
+	.owner = THIS_MODULE,
+	.dai_link = mfld_msic_dailink,
+	.num_links = ARRAY_SIZE(mfld_msic_dailink),
+};
+
+static irqreturn_t snd_mfld_jack_intr_handler(int irq, void *dev)
+{
+	struct mfld_mc_private *mc_private = (struct mfld_mc_private *) dev;
+
+	memcpy_fromio(&mc_private->interrupt_status,
+			((void *)(mc_private->int_base)),
+			sizeof(u8));
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t snd_mfld_jack_detection(int irq, void *data)
+{
+	struct mfld_mc_private *mc_drv_ctx = (struct mfld_mc_private *) data;
+
+	if (mfld_jack.codec == NULL)
+		return IRQ_HANDLED;
+	mfld_jack_check(mc_drv_ctx->interrupt_status);
+
+	return IRQ_HANDLED;
+}
+
+static int snd_mfld_mc_probe(struct platform_device *pdev)
+{
+	int ret_val = 0, irq;
+	struct mfld_mc_private *mc_drv_ctx;
+	struct resource *irq_mem;
+
+	pr_debug("snd_mfld_mc_probe called\n");
+
+	/* retrive the irq number */
+	irq = platform_get_irq(pdev, 0);
+
+	/* audio interrupt base of SRAM location where
+	 * interrupts are stored by System FW */
+	mc_drv_ctx = kzalloc(sizeof(*mc_drv_ctx), GFP_ATOMIC);
+	if (!mc_drv_ctx) {
+		pr_err("allocation failed\n");
+		return -ENOMEM;
+	}
+
+	irq_mem = platform_get_resource_byname(
+				pdev, IORESOURCE_MEM, "IRQ_BASE");
+	if (!irq_mem) {
+		pr_err("no mem resource given\n");
+		ret_val = -ENODEV;
+		goto unalloc;
+	}
+	mc_drv_ctx->int_base = ioremap_nocache(irq_mem->start,
+					resource_size(irq_mem));
+	if (!mc_drv_ctx->int_base) {
+		pr_err("Mapping of cache failed\n");
+		ret_val = -ENOMEM;
+		goto unalloc;
+	}
+	/* register for interrupt */
+	ret_val = request_threaded_irq(irq, snd_mfld_jack_intr_handler,
+			snd_mfld_jack_detection,
+			IRQF_SHARED, pdev->dev.driver->name, mc_drv_ctx);
+	if (ret_val) {
+		pr_err("cannot register IRQ\n");
+		goto unalloc;
+	}
+	/* register the soc card */
+	snd_soc_card_mfld.dev = &pdev->dev;
+	ret_val = snd_soc_register_card(&snd_soc_card_mfld);
+	if (ret_val) {
+		pr_debug("snd_soc_register_card failed %d\n", ret_val);
+		goto freeirq;
+	}
+	platform_set_drvdata(pdev, mc_drv_ctx);
+	pr_debug("successfully exited probe\n");
+	return ret_val;
+
+freeirq:
+	free_irq(irq, mc_drv_ctx);
+unalloc:
+	kfree(mc_drv_ctx);
+	return ret_val;
+}
+
+static int snd_mfld_mc_remove(struct platform_device *pdev)
+{
+	struct mfld_mc_private *mc_drv_ctx = platform_get_drvdata(pdev);
+
+	pr_debug("snd_mfld_mc_remove called\n");
+	free_irq(platform_get_irq(pdev, 0), mc_drv_ctx);
+	snd_soc_unregister_card(&snd_soc_card_mfld);
+	kfree(mc_drv_ctx);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct platform_driver snd_mfld_mc_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "msic_audio",
+	},
+	.probe = snd_mfld_mc_probe,
+	.remove = snd_mfld_mc_remove,
+};
+
+module_platform_driver(snd_mfld_mc_driver);
+
+MODULE_DESCRIPTION("ASoC Intel(R) MID Machine driver");
+MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
+MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:msic-audio");
diff --git a/sound/soc/mid-x86/sst_dsp.h b/sound/soc/mid-x86/sst_dsp.h
new file mode 100644
index 0000000..0fce1de
--- /dev/null
+++ b/sound/soc/mid-x86/sst_dsp.h
@@ -0,0 +1,134 @@
+#ifndef __SST_DSP_H__
+#define __SST_DSP_H__
+/*
+ *  sst_dsp.h - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-12 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@linux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+enum sst_codec_types {
+	/*  AUDIO/MUSIC	CODEC Type Definitions */
+	SST_CODEC_TYPE_UNKNOWN = 0,
+	SST_CODEC_TYPE_PCM,	/* Pass through Audio codec */
+	SST_CODEC_TYPE_MP3,
+	SST_CODEC_TYPE_MP24,
+	SST_CODEC_TYPE_AAC,
+	SST_CODEC_TYPE_AACP,
+	SST_CODEC_TYPE_eAACP,
+};
+
+enum stream_type {
+	SST_STREAM_TYPE_NONE = 0,
+	SST_STREAM_TYPE_MUSIC = 1,
+};
+
+struct snd_pcm_params {
+	u16 codec;	/* codec type */
+	u8 num_chan;	/* 1=Mono, 2=Stereo */
+	u8 pcm_wd_sz;	/* 16/24 - bit*/
+	u32 reserved;	/* Bitrate in bits per second */
+	u32 sfreq;	/* Sampling rate in Hz */
+	u8 use_offload_path;
+	u8 reserved2;
+	u16 reserved3;
+	u8 channel_map[8];
+} __packed;
+
+/* MP3 Music Parameters Message */
+struct snd_mp3_params {
+	u16 codec;
+	u8  num_chan;	/* 1=Mono, 2=Stereo	*/
+	u8  pcm_wd_sz; /* 16/24 - bit*/
+	u8  crc_check; /* crc_check - disable (0) or enable (1) */
+	u8  reserved1; /* unused*/
+	u16 reserved2;	/* Unused */
+} __packed;
+
+#define AAC_BIT_STREAM_ADTS		0
+#define AAC_BIT_STREAM_ADIF		1
+#define AAC_BIT_STREAM_RAW		2
+
+/* AAC Music Parameters Message */
+struct snd_aac_params {
+	u16 codec;
+	u8 num_chan; /* 1=Mono, 2=Stereo*/
+	u8 pcm_wd_sz; /* 16/24 - bit*/
+	u8 bdownsample; /*SBR downsampling 0 - disable 1 -enabled AAC+ only */
+	u8 bs_format; /* input bit stream format adts=0, adif=1, raw=2 */
+	u16  reser2;
+	u32 externalsr; /*sampling rate of basic AAC raw bit stream*/
+	u8 sbr_signalling;/*disable/enable/set automode the SBR tool.AAC+*/
+	u8 reser1;
+	u16  reser3;
+} __packed;
+
+/* WMA Music Parameters Message */
+struct snd_wma_params {
+	u16 codec;
+	u8  num_chan;	/* 1=Mono, 2=Stereo */
+	u8  pcm_wd_sz;	/* 16/24 - bit*/
+	u32 brate;	/* Use the hard coded value. */
+	u32 sfreq;	/* Sampling freq eg. 8000, 441000, 48000 */
+	u32 channel_mask;  /* Channel Mask */
+	u16 format_tag;	/* Format Tag */
+	u16 block_align;	/* packet size */
+	u16 wma_encode_opt;/* Encoder option */
+	u8 op_align;	/* op align 0- 16 bit, 1- MSB, 2 LSB */
+	u8 reserved;	/* reserved */
+} __packed;
+
+/* Codec params struture */
+union  snd_sst_codec_params {
+	struct snd_pcm_params pcm_params;
+	struct snd_mp3_params mp3_params;
+	struct snd_aac_params aac_params;
+	struct snd_wma_params wma_params;
+} __packed;
+
+/* Address and size info of a frame buffer */
+struct sst_address_info {
+	u32 addr; /* Address at IA */
+	u32 size; /* Size of the buffer */
+};
+
+struct snd_sst_alloc_params_ext {
+	struct sst_address_info  ring_buf_info[8];
+	u8 sg_count;
+	u8 reserved;
+	u16 reserved2;
+	u32 frag_size;	/*Number of samples after which period elapsed
+				  message is sent valid only if path  = 0*/
+} __packed;
+
+struct snd_sst_stream_params {
+	union snd_sst_codec_params uc;
+} __packed;
+
+struct snd_sst_params {
+	u32 stream_id;
+	u8 codec;
+	u8 ops;
+	u8 stream_type;
+	u8 device_type;
+	struct snd_sst_stream_params sparams;
+	struct snd_sst_alloc_params_ext aparams;
+};
+
+#endif /* __SST_DSP_H__ */
diff --git a/sound/soc/mid-x86/sst_platform.c b/sound/soc/mid-x86/sst_platform.c
new file mode 100644
index 0000000..392fc0b
--- /dev/null
+++ b/sound/soc/mid-x86/sst_platform.c
@@ -0,0 +1,733 @@
+/*
+ *  sst_platform.c - Intel MID Platform driver
+ *
+ *  Copyright (C) 2010-2013 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/compress_driver.h>
+#include "sst_platform.h"
+
+static struct sst_device *sst;
+static DEFINE_MUTEX(sst_lock);
+
+int sst_register_dsp(struct sst_device *dev)
+{
+	BUG_ON(!dev);
+	if (!try_module_get(dev->dev->driver->owner))
+		return -ENODEV;
+	mutex_lock(&sst_lock);
+	if (sst) {
+		pr_err("we already have a device %s\n", sst->name);
+		module_put(dev->dev->driver->owner);
+		mutex_unlock(&sst_lock);
+		return -EEXIST;
+	}
+	pr_debug("registering device %s\n", dev->name);
+	sst = dev;
+	mutex_unlock(&sst_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_register_dsp);
+
+int sst_unregister_dsp(struct sst_device *dev)
+{
+	BUG_ON(!dev);
+	if (dev != sst)
+		return -EINVAL;
+
+	mutex_lock(&sst_lock);
+
+	if (!sst) {
+		mutex_unlock(&sst_lock);
+		return -EIO;
+	}
+
+	module_put(sst->dev->driver->owner);
+	pr_debug("unreg %s\n", sst->name);
+	sst = NULL;
+	mutex_unlock(&sst_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_unregister_dsp);
+
+static struct snd_pcm_hardware sst_platform_pcm_hw = {
+	.info =	(SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_DOUBLE |
+			SNDRV_PCM_INFO_PAUSE |
+			SNDRV_PCM_INFO_RESUME |
+			SNDRV_PCM_INFO_MMAP|
+			SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			SNDRV_PCM_INFO_SYNC_START),
+	.formats = (SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_U16 |
+			SNDRV_PCM_FMTBIT_S24 | SNDRV_PCM_FMTBIT_U24 |
+			SNDRV_PCM_FMTBIT_S32 | SNDRV_PCM_FMTBIT_U32),
+	.rates = (SNDRV_PCM_RATE_8000|
+			SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000),
+	.rate_min = SST_MIN_RATE,
+	.rate_max = SST_MAX_RATE,
+	.channels_min =	SST_MIN_CHANNEL,
+	.channels_max =	SST_MAX_CHANNEL,
+	.buffer_bytes_max = SST_MAX_BUFFER,
+	.period_bytes_min = SST_MIN_PERIOD_BYTES,
+	.period_bytes_max = SST_MAX_PERIOD_BYTES,
+	.periods_min = SST_MIN_PERIODS,
+	.periods_max = SST_MAX_PERIODS,
+	.fifo_size = SST_FIFO_SIZE,
+};
+
+/* MFLD - MSIC */
+static struct snd_soc_dai_driver sst_platform_dai[] = {
+{
+	.name = "Headset-cpu-dai",
+	.id = 0,
+	.playback = {
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 5,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = "Speaker-cpu-dai",
+	.id = 1,
+	.playback = {
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = "Vibra1-cpu-dai",
+	.id = 2,
+	.playback = {
+		.channels_min = SST_MONO,
+		.channels_max = SST_MONO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = "Vibra2-cpu-dai",
+	.id = 3,
+	.playback = {
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = "Compress-cpu-dai",
+	.compress_dai = 1,
+	.playback = {
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+};
+
+static const struct snd_soc_component_driver sst_component = {
+	.name		= "sst",
+};
+
+/* helper functions */
+static inline void sst_set_stream_status(struct sst_runtime_stream *stream,
+					int state)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&stream->status_lock, flags);
+	stream->stream_status = state;
+	spin_unlock_irqrestore(&stream->status_lock, flags);
+}
+
+static inline int sst_get_stream_status(struct sst_runtime_stream *stream)
+{
+	int state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&stream->status_lock, flags);
+	state = stream->stream_status;
+	spin_unlock_irqrestore(&stream->status_lock, flags);
+	return state;
+}
+
+static void sst_fill_pcm_params(struct snd_pcm_substream *substream,
+				struct sst_pcm_params *param)
+{
+
+	param->codec = SST_CODEC_TYPE_PCM;
+	param->num_chan = (u8) substream->runtime->channels;
+	param->pcm_wd_sz = substream->runtime->sample_bits;
+	param->reserved = 0;
+	param->sfreq = substream->runtime->rate;
+	param->ring_buffer_size = snd_pcm_lib_buffer_bytes(substream);
+	param->period_count = substream->runtime->period_size;
+	param->ring_buffer_addr = virt_to_phys(substream->dma_buffer.area);
+	pr_debug("period_cnt = %d\n", param->period_count);
+	pr_debug("sfreq= %d, wd_sz = %d\n", param->sfreq, param->pcm_wd_sz);
+}
+
+static int sst_platform_alloc_stream(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	struct sst_pcm_params param = {0};
+	struct sst_stream_params str_params = {0};
+	int ret_val;
+
+	/* set codec params and inform SST driver the same */
+	sst_fill_pcm_params(substream, &param);
+	substream->runtime->dma_area = substream->dma_buffer.area;
+	str_params.sparams = param;
+	str_params.codec =  param.codec;
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		str_params.ops = STREAM_OPS_PLAYBACK;
+		str_params.device_type = substream->pcm->device + 1;
+		pr_debug("Playbck stream,Device %d\n",
+					substream->pcm->device);
+	} else {
+		str_params.ops = STREAM_OPS_CAPTURE;
+		str_params.device_type = SND_SST_DEVICE_CAPTURE;
+		pr_debug("Capture stream,Device %d\n",
+					substream->pcm->device);
+	}
+	ret_val = stream->ops->open(&str_params);
+	pr_debug("SST_SND_PLAY/CAPTURE ret_val = %x\n", ret_val);
+	if (ret_val < 0)
+		return ret_val;
+
+	stream->stream_info.str_id = ret_val;
+	pr_debug("str id :  %d\n", stream->stream_info.str_id);
+	return ret_val;
+}
+
+static void sst_period_elapsed(void *mad_substream)
+{
+	struct snd_pcm_substream *substream = mad_substream;
+	struct sst_runtime_stream *stream;
+	int status;
+
+	if (!substream || !substream->runtime)
+		return;
+	stream = substream->runtime->private_data;
+	if (!stream)
+		return;
+	status = sst_get_stream_status(stream);
+	if (status != SST_PLATFORM_RUNNING)
+		return;
+	snd_pcm_period_elapsed(substream);
+}
+
+static int sst_platform_init_stream(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	int ret_val;
+
+	pr_debug("setting buffer ptr param\n");
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	stream->stream_info.period_elapsed = sst_period_elapsed;
+	stream->stream_info.mad_substream = substream;
+	stream->stream_info.buffer_ptr = 0;
+	stream->stream_info.sfreq = substream->runtime->rate;
+	ret_val = stream->ops->device_control(
+			SST_SND_STREAM_INIT, &stream->stream_info);
+	if (ret_val)
+		pr_err("control_set ret error %d\n", ret_val);
+	return ret_val;
+
+}
+/* end -- helper functions */
+
+static int sst_platform_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sst_runtime_stream *stream;
+	int ret_val;
+
+	pr_debug("sst_platform_open called\n");
+
+	snd_soc_set_runtime_hwparams(substream, &sst_platform_pcm_hw);
+	ret_val = snd_pcm_hw_constraint_integer(runtime,
+						SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret_val < 0)
+		return ret_val;
+
+	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
+	if (!stream)
+		return -ENOMEM;
+	spin_lock_init(&stream->status_lock);
+
+	/* get the sst ops */
+	mutex_lock(&sst_lock);
+	if (!sst) {
+		pr_err("no device available to run\n");
+		mutex_unlock(&sst_lock);
+		kfree(stream);
+		return -ENODEV;
+	}
+	if (!try_module_get(sst->dev->driver->owner)) {
+		mutex_unlock(&sst_lock);
+		kfree(stream);
+		return -ENODEV;
+	}
+	stream->ops = sst->ops;
+	mutex_unlock(&sst_lock);
+
+	stream->stream_info.str_id = 0;
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	stream->stream_info.mad_substream = substream;
+	/* allocate memory for SST API set */
+	runtime->private_data = stream;
+
+	return 0;
+}
+
+static int sst_platform_close(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val = 0, str_id;
+
+	pr_debug("sst_platform_close called\n");
+	stream = substream->runtime->private_data;
+	str_id = stream->stream_info.str_id;
+	if (str_id)
+		ret_val = stream->ops->close(str_id);
+	module_put(sst->dev->driver->owner);
+	kfree(stream);
+	return ret_val;
+}
+
+static int sst_platform_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val = 0, str_id;
+
+	pr_debug("sst_platform_pcm_prepare called\n");
+	stream = substream->runtime->private_data;
+	str_id = stream->stream_info.str_id;
+	if (stream->stream_info.str_id) {
+		ret_val = stream->ops->device_control(
+				SST_SND_DROP, &str_id);
+		return ret_val;
+	}
+
+	ret_val = sst_platform_alloc_stream(substream);
+	if (ret_val < 0)
+		return ret_val;
+	snprintf(substream->pcm->id, sizeof(substream->pcm->id),
+			"%d", stream->stream_info.str_id);
+
+	ret_val = sst_platform_init_stream(substream);
+	if (ret_val)
+		return ret_val;
+	substream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;
+	return ret_val;
+}
+
+static int sst_platform_pcm_trigger(struct snd_pcm_substream *substream,
+					int cmd)
+{
+	int ret_val = 0, str_id;
+	struct sst_runtime_stream *stream;
+	int str_cmd, status;
+
+	pr_debug("sst_platform_pcm_trigger called\n");
+	stream = substream->runtime->private_data;
+	str_id = stream->stream_info.str_id;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		pr_debug("sst: Trigger Start\n");
+		str_cmd = SST_SND_START;
+		status = SST_PLATFORM_RUNNING;
+		stream->stream_info.mad_substream = substream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		pr_debug("sst: in stop\n");
+		str_cmd = SST_SND_DROP;
+		status = SST_PLATFORM_DROPPED;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		pr_debug("sst: in pause\n");
+		str_cmd = SST_SND_PAUSE;
+		status = SST_PLATFORM_PAUSED;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		pr_debug("sst: in pause release\n");
+		str_cmd = SST_SND_RESUME;
+		status = SST_PLATFORM_RUNNING;
+		break;
+	default:
+		return -EINVAL;
+	}
+	ret_val = stream->ops->device_control(str_cmd, &str_id);
+	if (!ret_val)
+		sst_set_stream_status(stream, status);
+
+	return ret_val;
+}
+
+
+static snd_pcm_uframes_t sst_platform_pcm_pointer
+			(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val, status;
+	struct pcm_stream_info *str_info;
+
+	stream = substream->runtime->private_data;
+	status = sst_get_stream_status(stream);
+	if (status == SST_PLATFORM_INIT)
+		return 0;
+	str_info = &stream->stream_info;
+	ret_val = stream->ops->device_control(
+				SST_SND_BUFFER_POINTER, str_info);
+	if (ret_val) {
+		pr_err("sst: error code = %d\n", ret_val);
+		return ret_val;
+	}
+	return stream->stream_info.buffer_ptr;
+}
+
+static int sst_platform_pcm_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params)
+{
+	snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+	memset(substream->runtime->dma_area, 0, params_buffer_bytes(params));
+
+	return 0;
+}
+
+static int sst_platform_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static struct snd_pcm_ops sst_platform_ops = {
+	.open = sst_platform_open,
+	.close = sst_platform_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.prepare = sst_platform_pcm_prepare,
+	.trigger = sst_platform_pcm_trigger,
+	.pointer = sst_platform_pcm_pointer,
+	.hw_params = sst_platform_pcm_hw_params,
+	.hw_free = sst_platform_pcm_hw_free,
+};
+
+static void sst_pcm_free(struct snd_pcm *pcm)
+{
+	pr_debug("sst_pcm_free called\n");
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int sst_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_pcm *pcm = rtd->pcm;
+	int retval = 0;
+
+	pr_debug("sst_pcm_new called\n");
+	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||
+			pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
+		retval =  snd_pcm_lib_preallocate_pages_for_all(pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			snd_dma_continuous_data(GFP_KERNEL),
+			SST_MIN_BUFFER, SST_MAX_BUFFER);
+		if (retval) {
+			pr_err("dma buffer allocationf fail\n");
+			return retval;
+		}
+	}
+	return retval;
+}
+
+/* compress stream operations */
+static void sst_compr_fragment_elapsed(void *arg)
+{
+	struct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;
+
+	pr_debug("fragment elapsed by driver\n");
+	if (cstream)
+		snd_compr_fragment_elapsed(cstream);
+}
+
+static int sst_platform_compr_open(struct snd_compr_stream *cstream)
+{
+
+	int ret_val = 0;
+	struct snd_compr_runtime *runtime = cstream->runtime;
+	struct sst_runtime_stream *stream;
+
+	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
+	if (!stream)
+		return -ENOMEM;
+
+	spin_lock_init(&stream->status_lock);
+
+	/* get the sst ops */
+	if (!sst || !try_module_get(sst->dev->driver->owner)) {
+		pr_err("no device available to run\n");
+		ret_val = -ENODEV;
+		goto out_ops;
+	}
+	stream->compr_ops = sst->compr_ops;
+
+	stream->id = 0;
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	runtime->private_data = stream;
+	return 0;
+out_ops:
+	kfree(stream);
+	return ret_val;
+}
+
+static int sst_platform_compr_free(struct snd_compr_stream *cstream)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val = 0, str_id;
+
+	stream = cstream->runtime->private_data;
+	/*need to check*/
+	str_id = stream->id;
+	if (str_id)
+		ret_val = stream->compr_ops->close(str_id);
+	module_put(sst->dev->driver->owner);
+	kfree(stream);
+	pr_debug("%s: %d\n", __func__, ret_val);
+	return 0;
+}
+
+static int sst_platform_compr_set_params(struct snd_compr_stream *cstream,
+					struct snd_compr_params *params)
+{
+	struct sst_runtime_stream *stream;
+	int retval;
+	struct snd_sst_params str_params;
+	struct sst_compress_cb cb;
+
+	stream = cstream->runtime->private_data;
+	/* construct fw structure for this*/
+	memset(&str_params, 0, sizeof(str_params));
+
+	str_params.ops = STREAM_OPS_PLAYBACK;
+	str_params.stream_type = SST_STREAM_TYPE_MUSIC;
+	str_params.device_type = SND_SST_DEVICE_COMPRESS;
+
+	switch (params->codec.id) {
+	case SND_AUDIOCODEC_MP3: {
+		str_params.codec = SST_CODEC_TYPE_MP3;
+		str_params.sparams.uc.mp3_params.codec = SST_CODEC_TYPE_MP3;
+		str_params.sparams.uc.mp3_params.num_chan = params->codec.ch_in;
+		str_params.sparams.uc.mp3_params.pcm_wd_sz = 16;
+		break;
+	}
+
+	case SND_AUDIOCODEC_AAC: {
+		str_params.codec = SST_CODEC_TYPE_AAC;
+		str_params.sparams.uc.aac_params.codec = SST_CODEC_TYPE_AAC;
+		str_params.sparams.uc.aac_params.num_chan = params->codec.ch_in;
+		str_params.sparams.uc.aac_params.pcm_wd_sz = 16;
+		if (params->codec.format == SND_AUDIOSTREAMFORMAT_MP4ADTS)
+			str_params.sparams.uc.aac_params.bs_format =
+							AAC_BIT_STREAM_ADTS;
+		else if (params->codec.format == SND_AUDIOSTREAMFORMAT_RAW)
+			str_params.sparams.uc.aac_params.bs_format =
+							AAC_BIT_STREAM_RAW;
+		else {
+			pr_err("Undefined format%d\n", params->codec.format);
+			return -EINVAL;
+		}
+		str_params.sparams.uc.aac_params.externalsr =
+						params->codec.sample_rate;
+		break;
+	}
+
+	default:
+		pr_err("codec not supported, id =%d\n", params->codec.id);
+		return -EINVAL;
+	}
+
+	str_params.aparams.ring_buf_info[0].addr  =
+					virt_to_phys(cstream->runtime->buffer);
+	str_params.aparams.ring_buf_info[0].size =
+					cstream->runtime->buffer_size;
+	str_params.aparams.sg_count = 1;
+	str_params.aparams.frag_size = cstream->runtime->fragment_size;
+
+	cb.param = cstream;
+	cb.compr_cb = sst_compr_fragment_elapsed;
+
+	retval = stream->compr_ops->open(&str_params, &cb);
+	if (retval < 0) {
+		pr_err("stream allocation failed %d\n", retval);
+		return retval;
+	}
+
+	stream->id = retval;
+	return 0;
+}
+
+static int sst_platform_compr_trigger(struct snd_compr_stream *cstream, int cmd)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->control(cmd, stream->id);
+}
+
+static int sst_platform_compr_pointer(struct snd_compr_stream *cstream,
+					struct snd_compr_tstamp *tstamp)
+{
+	struct sst_runtime_stream *stream;
+
+	stream  = cstream->runtime->private_data;
+	stream->compr_ops->tstamp(stream->id, tstamp);
+	tstamp->byte_offset = tstamp->copied_total %
+				 (u32)cstream->runtime->buffer_size;
+	pr_debug("calc bytes offset/copied bytes as %d\n", tstamp->byte_offset);
+	return 0;
+}
+
+static int sst_platform_compr_ack(struct snd_compr_stream *cstream,
+					size_t bytes)
+{
+	struct sst_runtime_stream *stream;
+
+	stream  = cstream->runtime->private_data;
+	stream->compr_ops->ack(stream->id, (unsigned long)bytes);
+	stream->bytes_written += bytes;
+
+	return 0;
+}
+
+static int sst_platform_compr_get_caps(struct snd_compr_stream *cstream,
+					struct snd_compr_caps *caps)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->get_caps(caps);
+}
+
+static int sst_platform_compr_get_codec_caps(struct snd_compr_stream *cstream,
+					struct snd_compr_codec_caps *codec)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->get_codec_caps(codec);
+}
+
+static int sst_platform_compr_set_metadata(struct snd_compr_stream *cstream,
+					struct snd_compr_metadata *metadata)
+{
+	struct sst_runtime_stream *stream  =
+		 cstream->runtime->private_data;
+
+	return stream->compr_ops->set_metadata(stream->id, metadata);
+}
+
+static struct snd_compr_ops sst_platform_compr_ops = {
+
+	.open = sst_platform_compr_open,
+	.free = sst_platform_compr_free,
+	.set_params = sst_platform_compr_set_params,
+	.set_metadata = sst_platform_compr_set_metadata,
+	.trigger = sst_platform_compr_trigger,
+	.pointer = sst_platform_compr_pointer,
+	.ack = sst_platform_compr_ack,
+	.get_caps = sst_platform_compr_get_caps,
+	.get_codec_caps = sst_platform_compr_get_codec_caps,
+};
+
+static struct snd_soc_platform_driver sst_soc_platform_drv = {
+	.ops		= &sst_platform_ops,
+	.compr_ops	= &sst_platform_compr_ops,
+	.pcm_new	= sst_pcm_new,
+	.pcm_free	= sst_pcm_free,
+};
+
+static int sst_platform_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	pr_debug("sst_platform_probe called\n");
+	sst = NULL;
+	ret = snd_soc_register_platform(&pdev->dev, &sst_soc_platform_drv);
+	if (ret) {
+		pr_err("registering soc platform failed\n");
+		return ret;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &sst_component,
+				sst_platform_dai, ARRAY_SIZE(sst_platform_dai));
+	if (ret) {
+		pr_err("registering cpu dais failed\n");
+		snd_soc_unregister_platform(&pdev->dev);
+	}
+	return ret;
+}
+
+static int sst_platform_remove(struct platform_device *pdev)
+{
+
+	snd_soc_unregister_component(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+	pr_debug("sst_platform_remove success\n");
+	return 0;
+}
+
+static struct platform_driver sst_platform_driver = {
+	.driver		= {
+		.name		= "sst-platform",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= sst_platform_probe,
+	.remove		= sst_platform_remove,
+};
+
+module_platform_driver(sst_platform_driver);
+
+MODULE_DESCRIPTION("ASoC Intel(R) MID Platform driver");
+MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
+MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:sst-platform");
diff --git a/sound/soc/mid-x86/sst_platform.h b/sound/soc/mid-x86/sst_platform.h
new file mode 100644
index 0000000..cacc906
--- /dev/null
+++ b/sound/soc/mid-x86/sst_platform.h
@@ -0,0 +1,157 @@
+/*
+ *  sst_platform.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2010 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+
+#ifndef __SST_PLATFORMDRV_H__
+#define __SST_PLATFORMDRV_H__
+
+#include "sst_dsp.h"
+
+#define SST_MONO		1
+#define SST_STEREO		2
+#define SST_MAX_CAP		5
+
+#define SST_MIN_RATE		8000
+#define SST_MAX_RATE		48000
+#define SST_MIN_CHANNEL		1
+#define SST_MAX_CHANNEL		5
+#define SST_MAX_BUFFER		(800*1024)
+#define SST_MIN_BUFFER		(800*1024)
+#define SST_MIN_PERIOD_BYTES	32
+#define SST_MAX_PERIOD_BYTES	SST_MAX_BUFFER
+#define SST_MIN_PERIODS		2
+#define SST_MAX_PERIODS		(1024*2)
+#define SST_FIFO_SIZE		0
+
+struct pcm_stream_info {
+	int str_id;
+	void *mad_substream;
+	void (*period_elapsed) (void *mad_substream);
+	unsigned long long buffer_ptr;
+	int sfreq;
+};
+
+enum sst_drv_status {
+	SST_PLATFORM_INIT = 1,
+	SST_PLATFORM_STARTED,
+	SST_PLATFORM_RUNNING,
+	SST_PLATFORM_PAUSED,
+	SST_PLATFORM_DROPPED,
+};
+
+enum sst_controls {
+	SST_SND_ALLOC =			0x00,
+	SST_SND_PAUSE =			0x01,
+	SST_SND_RESUME =		0x02,
+	SST_SND_DROP =			0x03,
+	SST_SND_FREE =			0x04,
+	SST_SND_BUFFER_POINTER =	0x05,
+	SST_SND_STREAM_INIT =		0x06,
+	SST_SND_START	 =		0x07,
+	SST_MAX_CONTROLS =		0x07,
+};
+
+enum sst_stream_ops {
+	STREAM_OPS_PLAYBACK = 0,
+	STREAM_OPS_CAPTURE,
+};
+
+enum sst_audio_device_type {
+	SND_SST_DEVICE_HEADSET = 1,
+	SND_SST_DEVICE_IHF,
+	SND_SST_DEVICE_VIBRA,
+	SND_SST_DEVICE_HAPTIC,
+	SND_SST_DEVICE_CAPTURE,
+	SND_SST_DEVICE_COMPRESS,
+};
+
+/* PCM Parameters */
+struct sst_pcm_params {
+	u16 codec;	/* codec type */
+	u8 num_chan;	/* 1=Mono, 2=Stereo */
+	u8 pcm_wd_sz;	/* 16/24 - bit*/
+	u32 reserved;	/* Bitrate in bits per second */
+	u32 sfreq;	/* Sampling rate in Hz */
+	u32 ring_buffer_size;
+	u32 period_count;	/* period elapsed in samples*/
+	u32 ring_buffer_addr;
+};
+
+struct sst_stream_params {
+	u32 result;
+	u32 stream_id;
+	u8 codec;
+	u8 ops;
+	u8 stream_type;
+	u8 device_type;
+	struct sst_pcm_params sparams;
+};
+
+struct sst_compress_cb {
+	void *param;
+	void (*compr_cb)(void *param);
+};
+
+struct compress_sst_ops {
+	const char *name;
+	int (*open) (struct snd_sst_params *str_params,
+			struct sst_compress_cb *cb);
+	int (*control) (unsigned int cmd, unsigned int str_id);
+	int (*tstamp) (unsigned int str_id, struct snd_compr_tstamp *tstamp);
+	int (*ack) (unsigned int str_id, unsigned long bytes);
+	int (*close) (unsigned int str_id);
+	int (*get_caps) (struct snd_compr_caps *caps);
+	int (*get_codec_caps) (struct snd_compr_codec_caps *codec);
+	int (*set_metadata) (unsigned int str_id,
+			struct snd_compr_metadata *mdata);
+
+};
+
+struct sst_ops {
+	int (*open) (struct sst_stream_params *str_param);
+	int (*device_control) (int cmd, void *arg);
+	int (*close) (unsigned int str_id);
+};
+
+struct sst_runtime_stream {
+	int     stream_status;
+	unsigned int id;
+	size_t bytes_written;
+	struct pcm_stream_info stream_info;
+	struct sst_ops *ops;
+	struct compress_sst_ops *compr_ops;
+	spinlock_t	status_lock;
+};
+
+struct sst_device {
+	char *name;
+	struct device *dev;
+	struct sst_ops *ops;
+	struct compress_sst_ops *compr_ops;
+};
+
+int sst_register_dsp(struct sst_device *sst);
+int sst_unregister_dsp(struct sst_device *sst);
+#endif
diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c
index 7201146..06a8000 100644
--- a/sound/soc/soc-compress.c
+++ b/sound/soc/soc-compress.c
@@ -24,7 +24,6 @@
 #include <sound/compress_driver.h>
 #include <sound/soc.h>
 #include <sound/initval.h>
-#include <sound/soc-dpcm.h>
 
 static int soc_compr_open(struct snd_compr_stream *cstream)
 {
@@ -76,98 +75,6 @@ out:
 	return ret;
 }
 
-static int soc_compr_open_fe(struct snd_compr_stream *cstream)
-{
-	struct snd_soc_pcm_runtime *fe = cstream->private_data;
-	struct snd_pcm_substream *fe_substream = fe->pcm->streams[0].substream;
-	struct snd_soc_platform *platform = fe->platform;
-	struct snd_soc_dai *cpu_dai = fe->cpu_dai;
-	struct snd_soc_dai *codec_dai = fe->codec_dai;
-	struct snd_soc_dpcm *dpcm;
-	struct snd_soc_dapm_widget_list *list;
-	int stream;
-	int ret = 0;
-
-	if (cstream->direction == SND_COMPRESS_PLAYBACK)
-		stream = SNDRV_PCM_STREAM_PLAYBACK;
-	else
-		stream = SNDRV_PCM_STREAM_CAPTURE;
-
-	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
-
-	if (platform->driver->compr_ops && platform->driver->compr_ops->open) {
-		ret = platform->driver->compr_ops->open(cstream);
-		if (ret < 0) {
-			pr_err("compress asoc: can't open platform %s\n", platform->name);
-			goto out;
-		}
-	}
-
-	if (fe->dai_link->compr_ops && fe->dai_link->compr_ops->startup) {
-		ret = fe->dai_link->compr_ops->startup(cstream);
-		if (ret < 0) {
-			pr_err("compress asoc: %s startup failed\n", fe->dai_link->name);
-			goto machine_err;
-		}
-	}
-
-	fe->dpcm[stream].runtime = fe_substream->runtime;
-
-	if (dpcm_path_get(fe, stream, &list) <= 0) {
-		dev_dbg(fe->dev, "ASoC: %s no valid %s route\n",
-			fe->dai_link->name, stream ? "capture" : "playback");
-	}
-
-	/* calculate valid and active FE <-> BE dpcms */
-	dpcm_process_paths(fe, stream, &list, 1);
-
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
-
-	ret = dpcm_be_dai_startup(fe, stream);
-	if (ret < 0) {
-		/* clean up all links */
-		list_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)
-			dpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;
-
-		dpcm_be_disconnect(fe, stream);
-		fe->dpcm[stream].runtime = NULL;
-		goto fe_err;
-	}
-
-	dpcm_clear_pending_state(fe, stream);
-	dpcm_path_put(&list);
-
-	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
-
-	if (cstream->direction == SND_COMPRESS_PLAYBACK) {
-		cpu_dai->playback_active++;
-		codec_dai->playback_active++;
-	} else {
-		cpu_dai->capture_active++;
-		codec_dai->capture_active++;
-	}
-
-	cpu_dai->active++;
-	codec_dai->active++;
-	fe->codec->active++;
-
-	mutex_unlock(&fe->card->mutex);
-
-	return 0;
-
-fe_err:
-	if (fe->dai_link->compr_ops && fe->dai_link->compr_ops->shutdown)
-		fe->dai_link->compr_ops->shutdown(cstream);
-machine_err:
-	if (platform->driver->compr_ops && platform->driver->compr_ops->free)
-		platform->driver->compr_ops->free(cstream);
-out:
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
-	mutex_unlock(&fe->card->mutex);
-	return ret;
-}
-
 /*
  * Power down the audio subsystem pmdown_time msecs after close is called.
  * This is to ensure there are no pops or clicks in between any music tracks
@@ -181,17 +88,18 @@ static void close_delayed_work(struct work_struct *work)
 
 	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
 
-	dev_dbg (rtd->dev, "ASoC: pop wq checking: %s status: %s waiting: %s\n",
-			codec_dai->driver->playback.stream_name,
-			codec_dai->playback_active ? "active" : "inactive",
-			rtd->pop_wait ? "yes" : "no");
+	dev_dbg(rtd->dev, "ASoC: pop wq checking: %s status: %s waiting: %s\n",
+		 codec_dai->driver->playback.stream_name,
+		 codec_dai->playback_active ? "active" : "inactive",
+		 rtd->pop_wait ? "yes" : "no");
 
 	/* are we waiting on this codec DAI stream */
-	if (rtd->pop_wait == 1 && !codec_dai->active) {
+	if (rtd->pop_wait == 1) {
 		rtd->pop_wait = 0;
 		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
 					  SND_SOC_DAPM_STREAM_STOP);
 	}
+
 	mutex_unlock(&rtd->pcm_mutex);
 }
 
@@ -212,8 +120,8 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 		cpu_dai->capture_active--;
 		codec_dai->capture_active--;
 	}
-	if (!codec_dai->playback_active)
-		snd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);
+
+	snd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);
 
 	cpu_dai->active--;
 	codec_dai->active--;
@@ -225,6 +133,7 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 	if (!codec_dai->active)
 		codec_dai->rate = 0;
 
+
 	if (rtd->dai_link->compr_ops && rtd->dai_link->compr_ops->shutdown)
 		rtd->dai_link->compr_ops->shutdown(cstream);
 
@@ -232,8 +141,7 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 		platform->driver->compr_ops->free(cstream);
 	cpu_dai->runtime = NULL;
 
-	if (cstream->direction == SND_COMPRESS_PLAYBACK
-				&& !codec_dai->playback_active) {
+	if (cstream->direction == SND_COMPRESS_PLAYBACK) {
 		if (!rtd->pmdown_time || codec->ignore_pmdown_time ||
 		    rtd->dai_link->ignore_pmdown_time) {
 			snd_soc_dapm_stream_event(rtd,
@@ -244,8 +152,7 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 			schedule_delayed_work(&rtd->delayed_work,
 				msecs_to_jiffies(rtd->pmdown_time));
 		}
-	} else if (cstream->direction == SND_COMPRESS_CAPTURE
-					&& !codec_dai->capture_active) {
+	} else {
 		/* capture streams can be powered down now */
 		snd_soc_dapm_stream_event(rtd,
 			SNDRV_PCM_STREAM_CAPTURE,
@@ -256,97 +163,15 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 	return 0;
 }
 
-static int soc_compr_free_fe(struct snd_compr_stream *cstream)
-{
-	struct snd_soc_pcm_runtime *fe = cstream->private_data;
-	struct snd_soc_platform *platform = fe->platform;
-	struct snd_soc_dai *cpu_dai = fe->cpu_dai;
-	struct snd_soc_dai *codec_dai = fe->codec_dai;
-	struct snd_soc_dpcm *dpcm;
-	int stream, ret;
-
-	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
-
-	if (cstream->direction == SND_COMPRESS_PLAYBACK) {
-		stream = SNDRV_PCM_STREAM_PLAYBACK;
-		cpu_dai->playback_active--;
-		codec_dai->playback_active--;
-	} else {
-		stream = SNDRV_PCM_STREAM_CAPTURE;
-		cpu_dai->capture_active--;
-		codec_dai->capture_active--;
-	}
-
-	cpu_dai->active--;
-	codec_dai->active--;
-	fe->codec->active--;
-
-	snd_soc_dai_digital_mute(cpu_dai, 1, stream);
-
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
-
-	ret = dpcm_be_dai_hw_free(fe, stream);
-	if (ret < 0)
-		dev_err(fe->dev, "compressed hw_free failed %d\n", ret);
-
-	ret = dpcm_be_dai_shutdown(fe, stream);
-
-	/* mark FE's links ready to prune */
-	list_for_each_entry(dpcm, &fe->dpcm[stream].be_clients, list_be)
-		dpcm->state = SND_SOC_DPCM_LINK_STATE_FREE;
-
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
-	else
-		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_STOP);
-
-	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_CLOSE;
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
-
-	dpcm_be_disconnect(fe, stream);
-
-	fe->dpcm[stream].runtime = NULL;
-
-	if (fe->dai_link->compr_ops && fe->dai_link->compr_ops->shutdown)
-		fe->dai_link->compr_ops->shutdown(cstream);
-
-	if (platform->driver->compr_ops && platform->driver->compr_ops->free)
-		platform->driver->compr_ops->free(cstream);
-
-	mutex_unlock(&fe->card->mutex);
-	return 0;
-}
-
 static int soc_compr_trigger(struct snd_compr_stream *cstream, int cmd)
 {
 
 	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
 	struct snd_soc_platform *platform = rtd->platform;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret = 0;
 
-	if (platform->driver->compr_ops && platform->driver->compr_ops->trigger) {
-		ret = platform->driver->compr_ops->trigger(cstream, cmd);
-		if (ret < 0)
-			goto out;
-	}
-
-out:
-	return ret;
-}
-
-static int soc_compr_trigger_fe(struct snd_compr_stream *cstream, int cmd)
-{
-	struct snd_soc_pcm_runtime *fe = cstream->private_data;
-	struct snd_soc_platform *platform = fe->platform;
-	int ret = 0, stream;
-
-	if (cstream->direction == SND_COMPRESS_PLAYBACK)
-		stream = SNDRV_PCM_STREAM_PLAYBACK;
-	else
-		stream = SNDRV_PCM_STREAM_CAPTURE;
-
-
-	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
+	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
 
 	if (platform->driver->compr_ops && platform->driver->compr_ops->trigger) {
 		ret = platform->driver->compr_ops->trigger(cstream, cmd);
@@ -354,28 +179,17 @@ static int soc_compr_trigger_fe(struct snd_compr_stream *cstream, int cmd)
 			goto out;
 	}
 
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
-
-	ret = dpcm_be_dai_trigger(fe, stream, cmd);
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		fe->dpcm[stream].state = SND_SOC_DPCM_STATE_START;
+		snd_soc_dai_digital_mute(codec_dai, 0, cstream->direction);
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-		fe->dpcm[stream].state = SND_SOC_DPCM_STATE_STOP;
-		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		fe->dpcm[stream].state = SND_SOC_DPCM_STATE_PAUSED;
+		snd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);
 		break;
 	}
 
 out:
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
-	mutex_unlock(&fe->card->mutex);
+	mutex_unlock(&rtd->pcm_mutex);
 	return ret;
 }
 
@@ -406,88 +220,23 @@ static int soc_compr_set_params(struct snd_compr_stream *cstream,
 			goto err;
 	}
 
-	/* cancel any delayed stream shutdown that is pending */
-	if (cstream->direction == SND_COMPRESS_PLAYBACK
-				 && rtd->pop_wait) {
-		rtd->pop_wait = 0;
-		cancel_delayed_work(&rtd->delayed_work);
-	}
-
-	snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
-					SND_SOC_DAPM_STREAM_START);
-
-	snd_soc_dai_digital_mute(rtd->codec_dai, 0, cstream->direction);
-err:
-	mutex_unlock(&rtd->pcm_mutex);
-	return ret;
-}
-
-static int soc_compr_set_params_fe(struct snd_compr_stream *cstream,
-					struct snd_compr_params *params)
-{
-	struct snd_soc_pcm_runtime *fe = cstream->private_data;
-	struct snd_pcm_substream *fe_substream = fe->pcm->streams[0].substream;
-	struct snd_soc_platform *platform = fe->platform;
-	struct snd_soc_dai *cpu_dai = fe->cpu_dai;
-	struct snd_soc_dai *codec_dai =  fe->codec_dai;
-
-	struct snd_pcm_hw_params *hw_params;
-	int ret = 0, stream;
-
 	if (cstream->direction == SND_COMPRESS_PLAYBACK)
-		stream = SNDRV_PCM_STREAM_PLAYBACK;
+		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
+					SND_SOC_DAPM_STREAM_START);
 	else
-		stream = SNDRV_PCM_STREAM_CAPTURE;
-
-	hw_params = kzalloc(sizeof(*hw_params), GFP_KERNEL);
-	if (hw_params == NULL)
-		return -ENOMEM;
-
-	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
-
-	/* first we call set_params for the platform driver
-	 * this should configure the soc side
-	 * if the machine has compressed ops then we call that as well
-	 * expectation is that platform and machine will configure everything
-	 * for this compress path, like configuring pcm port for codec
-	 */
-	if (platform->driver->compr_ops && platform->driver->compr_ops->set_params) {
-		ret = platform->driver->compr_ops->set_params(cstream, params);
-		if (ret < 0)
-			goto out;
-	}
-
-	if (fe->dai_link->compr_ops && fe->dai_link->compr_ops->set_params) {
-		ret = fe->dai_link->compr_ops->set_params(cstream);
-		if (ret < 0)
-			goto out;
-	}
-
-	memcpy(&fe->dpcm[fe_substream->stream].hw_params, params,
-			sizeof(struct snd_pcm_hw_params));
-
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
-
-	ret = dpcm_be_dai_hw_params(fe, stream);
-	if (ret < 0)
-		goto out;
-
-	ret = dpcm_be_dai_prepare(fe, stream);
-	if (ret < 0)
-		goto out;
+		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,
+					SND_SOC_DAPM_STREAM_START);
 
-	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
-		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
-	else
-		dpcm_dapm_stream_event(fe, stream, SND_SOC_DAPM_STREAM_START);
+	/* cancel any delayed stream shutdown that is pending */
+	rtd->pop_wait = 0;
+	mutex_unlock(&rtd->pcm_mutex);
 
-	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
+	cancel_delayed_work_sync(&rtd->delayed_work);
 
-	snd_soc_dai_digital_mute(cpu_dai, 0, stream);
+	return ret;
 
-out:
-	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
-	mutex_unlock(&fe->card->mutex);
+err:
+	mutex_unlock(&rtd->pcm_mutex);
 	return ret;
 }
 
@@ -610,7 +359,6 @@ static int sst_compr_get_metadata(struct snd_compr_stream *cstream,
 
 	return ret;
 }
-
 /* ASoC Compress operations */
 static struct snd_compr_ops soc_compr_ops = {
 	.open		= soc_compr_open,
@@ -626,21 +374,6 @@ static struct snd_compr_ops soc_compr_ops = {
 	.get_codec_caps = soc_compr_get_codec_caps
 };
 
-/* ASoC Dynamic Compress operations */
-static struct snd_compr_ops soc_compr_dyn_ops = {
-	.open		= soc_compr_open_fe,
-	.free		= soc_compr_free_fe,
-	.set_params	= soc_compr_set_params_fe,
-	.get_params	= soc_compr_get_params,
-	.set_metadata   = sst_compr_set_metadata,
-	.get_metadata	= sst_compr_get_metadata,
-	.trigger	= soc_compr_trigger_fe,
-	.pointer	= soc_compr_pointer,
-	.ack		= soc_compr_ack,
-	.get_caps	= soc_compr_get_caps,
-	.get_codec_caps = soc_compr_get_codec_caps
-};
-
 /* create a new compress */
 int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)
 {
@@ -649,7 +382,6 @@ int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_compr *compr;
-	struct snd_pcm *be_pcm;
 	char new_name[64];
 	int ret = 0, direction = 0;
 
@@ -677,26 +409,7 @@ int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)
 		ret = -ENOMEM;
 		goto compr_err;
 	}
-
-	if (rtd->dai_link->dynamic) {
-		snprintf(new_name, sizeof(new_name), "(%s)",
-			rtd->dai_link->stream_name);
-
-		ret = snd_pcm_new_internal(rtd->card->snd_card, new_name, num,
-				1, 0, &be_pcm);
-		if (ret < 0) {
-			dev_err(rtd->card->dev, "ASoC: can't create compressed for %s\n",
-				rtd->dai_link->name);
-			goto compr_err;
-		}
-
-		rtd->pcm = be_pcm;
-		rtd->fe_compr = 1;
-		be_pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream->private_data = rtd;
-		/*be_pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream->private_data = rtd;*/
-		memcpy(compr->ops, &soc_compr_dyn_ops, sizeof(soc_compr_dyn_ops));
-	} else
-		memcpy(compr->ops, &soc_compr_ops, sizeof(soc_compr_ops));
+	memcpy(compr->ops, &soc_compr_ops, sizeof(soc_compr_ops));
 
 	/* Add copy callback for not memory mapped DSPs */
 	if (platform->driver->compr_ops && platform->driver->compr_ops->copy)
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 717e6e9..d56bbea 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -530,15 +530,6 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 }
 #endif
 
-static void codec2codec_close_delayed_work(struct work_struct *work)
-{
-	/* Currently nothing to do for c2c links
-	 * Since c2c links are internal nodes in the DAPM graph and
-	 * don't interface with the outside world or application layer
-	 * we don't have to do any special handling on close.
-	 */
-}
-
 #ifdef CONFIG_PM_SLEEP
 /* powers down audio subsystem for suspend */
 int snd_soc_suspend(struct device *dev)
@@ -1172,11 +1163,6 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		if (dai->dev != platform->dev)
 			continue;
 
-		/* dummy platform doesn't have and DAIs, don't add dummy-codec
-		 * widgets here (since dev is the same)
-		 */
-		if (!strcmp(dai->name, "snd-soc-dummy-dai"))
-			continue;
 		snd_soc_dapm_new_dai_widgets(&platform->dapm, dai);
 	}
 
@@ -1238,6 +1224,9 @@ static int soc_post_component_init(struct snd_soc_card *card,
 	}
 	rtd->card = card;
 
+	/* Make sure all DAPM widgets are instantiated */
+	snd_soc_dapm_new_widgets(&codec->dapm);
+
 	/* machine controls, routes and widgets are not prefixed */
 	temp = codec->name_prefix;
 	codec->name_prefix = NULL;
@@ -1373,6 +1362,7 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 				return -ENODEV;
 
 			list_add(&cpu_dai->dapm.list, &card->dapm_list);
+			snd_soc_dapm_new_dai_widgets(&cpu_dai->dapm, cpu_dai);
 		}
 
 		if (cpu_dai->driver->probe) {
@@ -1439,9 +1429,6 @@ static int soc_probe_link_dais(struct snd_soc_card *card, int num, int order)
 				return ret;
 			}
 		} else {
-			INIT_DELAYED_WORK(&rtd->delayed_work,
-						codec2codec_close_delayed_work);
-
 			/* link the DAI widgets */
 			play_w = codec_dai->playback_widget;
 			capture_w = cpu_dai->capture_widget;
@@ -1730,6 +1717,8 @@ static int snd_soc_instantiate_card(struct snd_soc_card *card)
 		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
 					card->num_dapm_routes);
 
+	snd_soc_dapm_new_widgets(&card->dapm);
+
 	for (i = 0; i < card->num_links; i++) {
 		dai_link = &card->dai_link[i];
 		dai_fmt = dai_link->dai_fmt;
@@ -3185,19 +3174,6 @@ out:
 }
 EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
 
-int snd_soc_info_bytes_ext(struct snd_kcontrol *kcontrol,
-			struct snd_ctl_elem_info *ucontrol)
-{
-	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
-
-	ucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-	ucontrol->count = params->max;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(snd_soc_info_bytes_ext);
-
 /**
  * snd_soc_info_xr_sx - signed multi register info callback
  * @kcontrol: mreg control
diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
index 86891a3..3606383 100644
--- a/sound/soc/soc-dapm.c
+++ b/sound/soc/soc-dapm.c
@@ -172,17 +172,6 @@ static inline struct snd_soc_dapm_widget *dapm_cnew_widget(
 	return kmemdup(_widget, sizeof(*_widget), GFP_KERNEL);
 }
 
-/**
- * snd_soc_dapm_kcontrol_codec() - Returns the codec associated to a kcontrol
- * @kcontrol: The kcontrol
- */
-struct snd_soc_codec *snd_soc_dapm_kcontrol_codec(struct snd_kcontrol *kcontrol)
-{
-	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
-	return wlist->widgets[0]->codec;
-}
-EXPORT_SYMBOL_GPL(snd_soc_dapm_kcontrol_codec);
-
 /* get snd_card from DAPM context */
 static inline struct snd_card *dapm_get_snd_card(
 	struct snd_soc_dapm_context *dapm)
@@ -3451,7 +3440,7 @@ int snd_soc_dapm_link_dai_widgets(struct snd_soc_card *card)
 				break;
 			}
 
-			if (!w->sname || !strstr(w->sname, dai_w->name))
+			if (!w->sname)
 				continue;
 
 			if (dai->driver->playback.stream_name &&
diff --git a/sound/soc/soc-jack.c b/sound/soc/soc-jack.c
index 9fd4ed8..0bb5ccc 100644
--- a/sound/soc/soc-jack.c
+++ b/sound/soc/soc-jack.c
@@ -65,7 +65,6 @@ void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)
 	struct snd_soc_codec *codec;
 	struct snd_soc_dapm_context *dapm;
 	struct snd_soc_jack_pin *pin;
-	unsigned int sync = 0;
 	int enable;
 
 	trace_snd_soc_jack_report(jack, mask, status);
@@ -93,16 +92,12 @@ void snd_soc_jack_report(struct snd_soc_jack *jack, int status, int mask)
 			snd_soc_dapm_enable_pin(dapm, pin->pin);
 		else
 			snd_soc_dapm_disable_pin(dapm, pin->pin);
-
-		/* we need to sync for this case only */
-		sync = 1;
 	}
 
 	/* Report before the DAPM sync to help users updating micbias status */
 	blocking_notifier_call_chain(&jack->notifier, jack->status, jack);
 
-	if (sync)
-		snd_soc_dapm_sync(dapm);
+	snd_soc_dapm_sync(dapm);
 
 	snd_jack_report(jack->jack, jack->status);
 
@@ -323,13 +318,10 @@ int snd_soc_jack_add_gpios(struct snd_soc_jack *jack, int count,
 		INIT_DELAYED_WORK(&gpios[i].work, gpio_work);
 		gpios[i].jack = jack;
 
-		if (!gpios[i].irq_flags)
-			gpios[i].irq_flags =
-				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
-
 		ret = request_any_context_irq(gpio_to_irq(gpios[i].gpio),
 					      gpio_handler,
-					      gpios[i].irq_flags,
+					      IRQF_TRIGGER_RISING |
+					      IRQF_TRIGGER_FALLING,
 					      gpios[i].name,
 					      &gpios[i]);
 		if (ret < 0)
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index fc27d27..ccb6be4 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -34,7 +34,7 @@
 #define DPCM_MAX_BE_USERS	8
 
 /* DPCM stream event, send event to FE and all active BEs. */
-int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,
+static int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,
 	int event)
 {
 	struct snd_soc_dpcm *dpcm;
@@ -337,7 +337,7 @@ static void close_delayed_work(struct work_struct *work)
 		 rtd->pop_wait ? "yes" : "no");
 
 	/* are we waiting on this codec DAI stream */
-	if (rtd->pop_wait == 1 && !codec_dai->active) {
+	if (rtd->pop_wait == 1) {
 		rtd->pop_wait = 0;
 		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
 					  SND_SOC_DAPM_STREAM_STOP);
@@ -383,10 +383,7 @@ static int soc_pcm_close(struct snd_pcm_substream *substream)
 	/* Muting the DAC suppresses artifacts caused during digital
 	 * shutdown, for example from stopping clocks.
 	 */
-	if (!codec_dai->playback_active)
-		snd_soc_dai_digital_mute(codec_dai, 1, substream->stream);
-
-	snd_soc_dai_digital_mute(cpu_dai, 1, substream->stream);
+	snd_soc_dai_digital_mute(codec_dai, 1, substream->stream);
 
 	if (cpu_dai->driver->ops->shutdown)
 		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
@@ -401,8 +398,7 @@ static int soc_pcm_close(struct snd_pcm_substream *substream)
 		platform->driver->ops->close(substream);
 	cpu_dai->runtime = NULL;
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK
-			&& !codec_dai->playback_active) {
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		if (!rtd->pmdown_time || codec->ignore_pmdown_time ||
 		    rtd->dai_link->ignore_pmdown_time) {
 			/* powered down playback stream now */
@@ -415,14 +411,14 @@ static int soc_pcm_close(struct snd_pcm_substream *substream)
 			schedule_delayed_work(&rtd->delayed_work,
 				msecs_to_jiffies(rtd->pmdown_time));
 		}
-	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE
-			&& !codec_dai->capture_active) {
+	} else {
 		/* capture streams can be powered down now */
 		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,
 					  SND_SOC_DAPM_STREAM_STOP);
 	}
 
 	mutex_unlock(&rtd->pcm_mutex);
+
 	pm_runtime_put(platform->dev);
 	pm_runtime_put(codec_dai->dev);
 	pm_runtime_put(cpu_dai->dev);
@@ -492,7 +488,6 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 			SND_SOC_DAPM_STREAM_START);
 
 	snd_soc_dai_digital_mute(codec_dai, 0, substream->stream);
-	snd_soc_dai_digital_mute(cpu_dai, 0, substream->stream);
 
 out:
 	mutex_unlock(&rtd->pcm_mutex);
@@ -762,7 +757,7 @@ static void dpcm_be_reparent(struct snd_soc_pcm_runtime *fe,
 }
 
 /* disconnect a BE and FE */
-void dpcm_be_disconnect(struct snd_soc_pcm_runtime *fe, int stream)
+static void dpcm_be_disconnect(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm, *d;
 
@@ -858,7 +853,7 @@ static int widget_in_list(struct snd_soc_dapm_widget_list *list,
 	return 0;
 }
 
-int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
+static int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
 	int stream, struct snd_soc_dapm_widget_list **list_)
 {
 	struct snd_soc_dai *cpu_dai = fe->cpu_dai;
@@ -880,6 +875,11 @@ int dpcm_path_get(struct snd_soc_pcm_runtime *fe,
 	return paths;
 }
 
+static inline void dpcm_path_put(struct snd_soc_dapm_widget_list **list)
+{
+	kfree(*list);
+}
+
 static int dpcm_prune_paths(struct snd_soc_pcm_runtime *fe, int stream,
 	struct snd_soc_dapm_widget_list **list_)
 {
@@ -949,7 +949,7 @@ static int dpcm_add_paths(struct snd_soc_pcm_runtime *fe, int stream,
 			continue;
 
 		/* don't connect if FE is not running */
-		if (!fe->dpcm[stream].runtime && !fe->fe_compr)
+		if (!fe->dpcm[stream].runtime)
 			continue;
 
 		/* newly connected FE and BE */
@@ -974,7 +974,7 @@ static int dpcm_add_paths(struct snd_soc_pcm_runtime *fe, int stream,
  * Find the corresponding BE DAIs that source or sink audio to this
  * FE substream.
  */
-int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,
+static int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,
 	int stream, struct snd_soc_dapm_widget_list **list, int new)
 {
 	if (new)
@@ -983,7 +983,7 @@ int dpcm_process_paths(struct snd_soc_pcm_runtime *fe,
 		return dpcm_prune_paths(fe, stream, list);
 }
 
-void dpcm_clear_pending_state(struct snd_soc_pcm_runtime *fe, int stream)
+static void dpcm_clear_pending_state(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
 
@@ -1021,7 +1021,7 @@ static void dpcm_be_dai_startup_unwind(struct snd_soc_pcm_runtime *fe,
 	}
 }
 
-int dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream)
+static int dpcm_be_dai_startup(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
 	int err, count = 0;
@@ -1149,6 +1149,7 @@ static int dpcm_fe_dai_startup(struct snd_pcm_substream *fe_substream)
 	}
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;
+
 	dpcm_set_fe_runtime(fe_substream);
 	snd_pcm_limit_hw_rates(runtime);
 
@@ -1162,7 +1163,7 @@ be_err:
 	return ret;
 }
 
-int dpcm_be_dai_shutdown(struct snd_soc_pcm_runtime *fe, int stream)
+static int dpcm_be_dai_shutdown(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
 
@@ -1223,7 +1224,7 @@ static int dpcm_fe_dai_shutdown(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)
+static int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
 
@@ -1288,7 +1289,7 @@ static int dpcm_fe_dai_hw_free(struct snd_pcm_substream *substream)
 	return 0;
 }
 
-int dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int stream)
+static int dpcm_be_dai_hw_params(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
 	int ret;
@@ -1394,7 +1395,7 @@ static int dpcm_fe_dai_hw_params(struct snd_pcm_substream *substream,
 	if (ret < 0) {
 		dev_err(fe->dev,"ASoC: hw_params FE failed %d\n", ret);
 		dpcm_be_dai_hw_free(fe, stream);
-	} else
+	 } else
 		fe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;
 
 out:
@@ -1418,7 +1419,7 @@ static int dpcm_do_trigger(struct snd_soc_dpcm *dpcm,
 	return ret;
 }
 
-int dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream,
+static int dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream,
 			       int cmd)
 {
 	struct snd_soc_dpcm *dpcm;
@@ -1510,6 +1511,7 @@ int dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream,
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(dpcm_be_dai_trigger);
 
 static int dpcm_fe_dai_trigger(struct snd_pcm_substream *substream, int cmd)
 {
@@ -1585,7 +1587,7 @@ out:
 	return ret;
 }
 
-int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)
+static int dpcm_be_dai_prepare(struct snd_soc_pcm_runtime *fe, int stream)
 {
 	struct snd_soc_dpcm *dpcm;
 	int ret = 0;
@@ -2009,36 +2011,17 @@ int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)
 	int ret = 0, playback = 0, capture = 0;
 
 	if (rtd->dai_link->dynamic || rtd->dai_link->no_pcm) {
-		if (cpu_dai->driver->playback.channels_min) {
-			if (rtd->dai_link->playback_count)
-				playback = rtd->dai_link->playback_count;
-			else
-				playback = 1;
-		}
-
-		if (cpu_dai->driver->capture.channels_min) {
-			if (rtd->dai_link->capture_count)
-				capture = rtd->dai_link->capture_count;
-			else
-				capture = 1;
-		}
+		if (cpu_dai->driver->playback.channels_min)
+			playback = 1;
+		if (cpu_dai->driver->capture.channels_min)
+			capture = 1;
 	} else {
 		if (codec_dai->driver->playback.channels_min &&
-		    cpu_dai->driver->playback.channels_min) {
-			if (rtd->dai_link->playback_count)
-				playback = rtd->dai_link->playback_count;
-			else
-				playback = 1;
-		}
-
+		    cpu_dai->driver->playback.channels_min)
+			playback = 1;
 		if (codec_dai->driver->capture.channels_min &&
-		    cpu_dai->driver->capture.channels_min) {
-			if (rtd->dai_link->capture_count)
-				capture = rtd->dai_link->capture_count;
-			else
-				capture = 1;
-		}
-
+		    cpu_dai->driver->capture.channels_min)
+			capture = 1;
 	}
 
 	/* create the PCM */
diff --git a/sound/soc/soc-utils.c b/sound/soc/soc-utils.c
index 8ecf448..4b3be6c 100644
--- a/sound/soc/soc-utils.c
+++ b/sound/soc/soc-utils.c
@@ -75,11 +75,7 @@ static const struct snd_pcm_hardware dummy_dma_hardware = {
 
 static int dummy_dma_open(struct snd_pcm_substream *substream)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-
-	/* BE's dont need dummy params */
-	if (!rtd->dai_link->no_pcm)
-		snd_soc_set_runtime_hwparams(substream, &dummy_dma_hardware);
+	snd_soc_set_runtime_hwparams(substream, &dummy_dma_hardware);
 
 	return 0;
 }
@@ -93,28 +89,7 @@ static struct snd_soc_platform_driver dummy_platform = {
 	.ops = &dummy_dma_ops,
 };
 
-static struct snd_soc_dapm_widget dapm_widgets[] = {
-	SND_SOC_DAPM_INPUT("Dummy Input"),
-	SND_SOC_DAPM_OUTPUT("Dummy Output"),
-};
-
-static struct snd_soc_dapm_route intercon[] = {
-	{ "Dummy Output", NULL, "Dummy Playback"},
-	{ "Dummy Capture", NULL, "Dummy Input"},
-};
-
-static int dummy_codec_probe(struct snd_soc_codec *codec)
-{
-	struct snd_soc_dapm_context *dapm = &codec->dapm;
-	snd_soc_dapm_new_controls(dapm, dapm_widgets,
-			ARRAY_SIZE(dapm_widgets));
-	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
-	return 0;
-}
-
-static struct snd_soc_codec_driver dummy_codec = {
-	.probe = dummy_codec_probe,
-};
+static struct snd_soc_codec_driver dummy_codec;
 
 #define STUB_RATES	SNDRV_PCM_RATE_8000_192000
 #define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S8 | \
@@ -126,18 +101,17 @@ static struct snd_soc_codec_driver dummy_codec = {
 			SNDRV_PCM_FMTBIT_S32_LE | \
 			SNDRV_PCM_FMTBIT_U32_LE | \
 			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)
-
 static struct snd_soc_dai_driver dummy_dai = {
 	.name = "snd-soc-dummy-dai",
 	.playback = {
-		.stream_name	= "Dummy Playback",
+		.stream_name	= "Playback",
 		.channels_min	= 1,
 		.channels_max	= 384,
 		.rates		= STUB_RATES,
 		.formats	= STUB_FORMATS,
 	},
 	.capture = {
-		.stream_name	= "Dummy Capture",
+		.stream_name	= "Capture",
 		.channels_min	= 1,
 		.channels_max	= 384,
 		.rates = STUB_RATES,
diff --git a/tools/perf/Makefile b/tools/perf/Makefile
index ecdd885..b0f164b 100644
--- a/tools/perf/Makefile
+++ b/tools/perf/Makefile
@@ -691,10 +691,9 @@ ifndef NO_SLANG
 	ifneq ($(call try-cc,$(SOURCE_SLANG),$(FLAGS_SLANG),libslang),y)
 		msg := $(warning slang not found, disables TUI support. Please install slang-devel or libslang-dev);
 	else
-		# Some releases like Fedora has /usr/include/slang/slang.h other than /usr/include/slang.h
-		SLANG_INC ?= -idirafter =/usr/include/slang
+		# Fedora has /usr/include/slang/slang.h, but ubuntu /usr/include/slang.h
+		BASIC_CFLAGS += -I/usr/include/slang
 		BASIC_CFLAGS += -DSLANG_SUPPORT
-		BASIC_CFLAGS += $(SLANG_INC)
 		EXTLIBS += -lslang
 		LIB_OBJS += $(OUTPUT)ui/browser.o
 		LIB_OBJS += $(OUTPUT)ui/browsers/annotate.o
@@ -743,7 +742,6 @@ else
 	FLAGS_PERL_EMBED=$(PERL_EMBED_CCOPTS) $(PERL_EMBED_LDOPTS)
 
 	ifneq ($(call try-cc,$(SOURCE_PERL_EMBED),$(FLAGS_PERL_EMBED),perl),y)
-		msg := $(warning libperl not found, disables Perl scripting support. Please install libperl-dev or perl-devel);
 		BASIC_CFLAGS += -DNO_LIBPERL
 	else
                ALL_LDFLAGS += $(PERL_EMBED_LDFLAGS)
@@ -782,10 +780,10 @@ else
 
       PYTHON_CONFIG_SQ := $(call shell-sq,$(PYTHON_CONFIG))
 
-      PYTHON_EMBED_LDOPTS := $(shell pkg-config --libs python 2>/dev/null)
+      PYTHON_EMBED_LDOPTS := $(shell $(PYTHON_CONFIG_SQ) --ldflags 2>/dev/null)
       PYTHON_EMBED_LDFLAGS := $(call strip-libs,$(PYTHON_EMBED_LDOPTS))
       PYTHON_EMBED_LIBADD := $(call grep-libs,$(PYTHON_EMBED_LDOPTS))
-      PYTHON_EMBED_CCOPTS := $(shell pkg-config --cflags python 2>/dev/null)
+      PYTHON_EMBED_CCOPTS := $(shell $(PYTHON_CONFIG_SQ) --cflags 2>/dev/null)
       FLAGS_PYTHON_EMBED := $(PYTHON_EMBED_CCOPTS) $(PYTHON_EMBED_LDOPTS)
 
       ifneq ($(call try-cc,$(SOURCE_PYTHON_EMBED),$(FLAGS_PYTHON_EMBED),python),y)
@@ -1196,7 +1194,7 @@ install-bin: all
 install: install-bin try-install-man
 
 install-python_ext:
-	$(PYTHON_WORD) util/setup.py --quiet install --prefix='$(DESTDIR_SQ)/usr'
+	$(PYTHON_WORD) util/setup.py --quiet install --root='/$(DESTDIR_SQ)'
 
 # 'make install-doc' should call 'make -C Documentation install'
 $(INSTALL_DOC_TARGETS):
diff --git a/tools/perf/bench/numa.c b/tools/perf/bench/numa.c
index f5c0834..30d1c32 100644
--- a/tools/perf/bench/numa.c
+++ b/tools/perf/bench/numa.c
@@ -21,7 +21,6 @@
 #include <string.h>
 #include <unistd.h>
 #include <pthread.h>
-#include <inttypes.h>
 #include <sys/mman.h>
 #include <sys/time.h>
 #include <sys/wait.h>
@@ -1111,7 +1110,7 @@ static void *worker_thread(void *__tdata)
 		/* Check whether our max runtime timed out: */
 		if (g->p.nr_secs) {
 			timersub(&stop, &start0, &diff);
-			if (diff.tv_sec >= (long int)g->p.nr_secs) {
+			if (diff.tv_sec >= g->p.nr_secs) {
 				g->stop_work = true;
 				break;
 			}
@@ -1158,7 +1157,7 @@ static void *worker_thread(void *__tdata)
 			runtime_ns_max += diff.tv_usec * 1000;
 
 			if (details >= 0) {
-				printf(" #%2d / %2d: %14.2lf nsecs/op [val: %016"PRIu64"x]\n",
+				printf(" #%2d / %2d: %14.2lf nsecs/op [val: %016lx]\n",
 					process_nr, thread_nr, runtime_ns_max / bytes_done, val);
 			}
 			fflush(stdout);
diff --git a/tools/perf/builtin-sched.c b/tools/perf/builtin-sched.c
index 2eddd71..2da2a6c 100644
--- a/tools/perf/builtin-sched.c
+++ b/tools/perf/builtin-sched.c
@@ -1663,29 +1663,28 @@ static int __cmd_record(int argc, const char **argv)
 	return cmd_record(i, rec_argv, NULL);
 }
 
-static const char default_sort_order[] = "avg, max, switch, runtime";
-static struct perf_sched sched = {
-	.tool = {
-		.sample		 = perf_sched__process_tracepoint_sample,
-		.comm		 = perf_event__process_comm,
-		.lost		 = perf_event__process_lost,
-		.fork		 = perf_event__process_fork,
-		.ordered_samples = true,
-	},
-	.cmp_pid	      = LIST_HEAD_INIT(sched.cmp_pid),
-	.sort_list	      = LIST_HEAD_INIT(sched.sort_list),
-	.start_work_mutex     = PTHREAD_MUTEX_INITIALIZER,
-	.work_done_wait_mutex = PTHREAD_MUTEX_INITIALIZER,
-	.curr_pid	      = { [0 ... MAX_CPUS - 1] = -1 },
-	.sort_order	      = default_sort_order,
-	.replay_repeat	      = 10,
-	.profile_cpu	      = -1,
-	.next_shortname1      = 'A',
-	.next_shortname2      = '0',
-};
-
 int cmd_sched(int argc, const char **argv, const char *prefix __maybe_unused)
 {
+	const char default_sort_order[] = "avg, max, switch, runtime";
+	struct perf_sched sched = {
+		.tool = {
+			.sample		 = perf_sched__process_tracepoint_sample,
+			.comm		 = perf_event__process_comm,
+			.lost		 = perf_event__process_lost,
+			.fork		 = perf_event__process_fork,
+			.ordered_samples = true,
+		},
+		.cmp_pid	      = LIST_HEAD_INIT(sched.cmp_pid),
+		.sort_list	      = LIST_HEAD_INIT(sched.sort_list),
+		.start_work_mutex     = PTHREAD_MUTEX_INITIALIZER,
+		.work_done_wait_mutex = PTHREAD_MUTEX_INITIALIZER,
+		.curr_pid	      = { [0 ... MAX_CPUS - 1] = -1 },
+		.sort_order	      = default_sort_order,
+		.replay_repeat	      = 10,
+		.profile_cpu	      = -1,
+		.next_shortname1      = 'A',
+		.next_shortname2      = '0',
+	};
 	const struct option latency_options[] = {
 	OPT_STRING('s', "sort", &sched.sort_order, "key[,key2...]",
 		   "sort by key(s): runtime, switch, avg, max"),
diff --git a/tools/perf/perf.h b/tools/perf/perf.h
index 6128be7..32bd102 100644
--- a/tools/perf/perf.h
+++ b/tools/perf/perf.h
@@ -3,8 +3,6 @@
 
 #include <asm/unistd.h>
 
-#include <stdbool.h>
-
 #if defined(__i386__)
 #define rmb()		asm volatile("lock; addl $0,0(%%esp)" ::: "memory")
 #define cpu_relax()	asm volatile("rep; nop" ::: "memory");
diff --git a/tools/perf/scripts/python/Perf-Trace-Util/Context.c b/tools/perf/scripts/python/Perf-Trace-Util/Context.c
index 57d3aa3..315067b 100644
--- a/tools/perf/scripts/python/Perf-Trace-Util/Context.c
+++ b/tools/perf/scripts/python/Perf-Trace-Util/Context.c
@@ -19,10 +19,6 @@
  *
  */
 
-#ifdef __mips__
-#include <sgidefs.h>
-#endif
-
 #include <Python.h>
 #include "../../../perf.h"
 #include "../../../util/trace-event.h"
diff --git a/tools/perf/tests/attr.c b/tools/perf/tests/attr.c
index f045c2c..00218f5 100644
--- a/tools/perf/tests/attr.c
+++ b/tools/perf/tests/attr.c
@@ -71,7 +71,7 @@ static int store_event(struct perf_event_attr *attr, pid_t pid, int cpu,
 	char path[PATH_MAX];
 
 	snprintf(path, PATH_MAX, "%s/event-%d-%llu-%d", dir,
-		 attr->type, (unsigned long long)attr->config, fd);
+		 attr->type, attr->config, fd);
 
 	file = fopen(path, "w+");
 	if (!file) {
@@ -80,7 +80,7 @@ static int store_event(struct perf_event_attr *attr, pid_t pid, int cpu,
 	}
 
 	if (fprintf(file, "[event-%d-%llu-%d]\n",
-		    attr->type, (unsigned long long)attr->config, fd) < 0) {
+		    attr->type, attr->config, fd) < 0) {
 		perror("test attr - failed to write event file");
 		fclose(file);
 		return -1;
@@ -96,10 +96,10 @@ static int store_event(struct perf_event_attr *attr, pid_t pid, int cpu,
 	/* struct perf_event_attr */
 	WRITE_ASS(type,   PRIu32);
 	WRITE_ASS(size,   PRIu32);
-	__WRITE_ASS(config,        "llu", (unsigned long long)attr->config);
-	__WRITE_ASS(sample_period, "llu", (unsigned long long)attr->sample_period);
-	__WRITE_ASS(sample_type,   "llu", (unsigned long long)attr->sample_type);
-	__WRITE_ASS(read_format,   "llu", (unsigned long long)attr->read_format);
+	WRITE_ASS(config,  "llu");
+	WRITE_ASS(sample_period, "llu");
+	WRITE_ASS(sample_type,   "llu");
+	WRITE_ASS(read_format,   "llu");
 	WRITE_ASS(disabled,       "d");
 	WRITE_ASS(inherit,        "d");
 	WRITE_ASS(pinned,         "d");
@@ -124,10 +124,10 @@ static int store_event(struct perf_event_attr *attr, pid_t pid, int cpu,
 	WRITE_ASS(exclude_callchain_user, "d");
 	WRITE_ASS(wakeup_events, PRIu32);
 	WRITE_ASS(bp_type, PRIu32);
-	__WRITE_ASS(config1,            "llu", (unsigned long long)attr->config1);
-	__WRITE_ASS(config2,            "llu", (unsigned long long)attr->config2);
-	__WRITE_ASS(branch_sample_type, "llu", (unsigned long long)attr->branch_sample_type);
-	__WRITE_ASS(sample_regs_user,   "llu", (unsigned long long)attr->sample_regs_user);
+	WRITE_ASS(config1, "llu");
+	WRITE_ASS(config2, "llu");
+	WRITE_ASS(branch_sample_type, "llu");
+	WRITE_ASS(sample_regs_user,   "llu");
 	WRITE_ASS(sample_stack_user,  PRIu32);
 
 	fclose(file);
diff --git a/tools/perf/tests/bp_signal.c b/tools/perf/tests/bp_signal.c
index bf3a094..68daa28 100644
--- a/tools/perf/tests/bp_signal.c
+++ b/tools/perf/tests/bp_signal.c
@@ -74,7 +74,7 @@ static int bp_event(void *fn, int setup_signal)
 
 	fd = sys_perf_event_open(&pe, 0, -1, -1, 0);
 	if (fd < 0) {
-		pr_debug("failed opening event %llx\n", (unsigned long long)pe.config);
+		pr_debug("failed opening event %llx\n", pe.config);
 		return TEST_FAIL;
 	}
 
diff --git a/tools/perf/tests/bp_signal_overflow.c b/tools/perf/tests/bp_signal_overflow.c
index 3662b15..fe7ed28 100644
--- a/tools/perf/tests/bp_signal_overflow.c
+++ b/tools/perf/tests/bp_signal_overflow.c
@@ -87,7 +87,7 @@ int test__bp_signal_overflow(void)
 
 	fd = sys_perf_event_open(&pe, 0, -1, -1, 0);
 	if (fd < 0) {
-		pr_debug("failed opening event %llx\n", (unsigned long long)pe.config);
+		pr_debug("failed opening event %llx\n", pe.config);
 		return TEST_FAIL;
 	}
 
diff --git a/tools/perf/util/annotate.c b/tools/perf/util/annotate.c
index c0ec9f5..d102716 100644
--- a/tools/perf/util/annotate.c
+++ b/tools/perf/util/annotate.c
@@ -898,7 +898,7 @@ fallback:
 	snprintf(command, sizeof(command),
 		 "%s %s%s --start-address=0x%016" PRIx64
 		 " --stop-address=0x%016" PRIx64
-		 " -d %s %s -C %s|grep -v %s|sed 's/\t/        /g'",
+		 " -d %s %s -C %s|grep -v %s|expand",
 		 objdump_path ? objdump_path : "objdump",
 		 disassembler_style ? "-M " : "",
 		 disassembler_style ? disassembler_style : "",
diff --git a/tools/perf/util/include/linux/compiler.h b/tools/perf/util/include/linux/compiler.h
index d0c6cd6..96b919d 100644
--- a/tools/perf/util/include/linux/compiler.h
+++ b/tools/perf/util/include/linux/compiler.h
@@ -4,7 +4,6 @@
 #ifndef __always_inline
 #define __always_inline	inline
 #endif
-#undef __user
 #define __user
 #ifndef __attribute_const__
 #define __attribute_const__
diff --git a/tools/perf/util/scripting-engines/trace-event-python.c b/tools/perf/util/scripting-engines/trace-event-python.c
index 0aa746f..e87aa5d 100644
--- a/tools/perf/util/scripting-engines/trace-event-python.c
+++ b/tools/perf/util/scripting-engines/trace-event-python.c
@@ -19,10 +19,6 @@
  *
  */
 
-#ifdef __mips__
-#include <sgidefs.h>
-#endif
-
 #include <Python.h>
 
 #include <stdio.h>
-- 
2.1.0

